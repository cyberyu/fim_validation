{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n<fim-suffix><fim-middle>UpdateData::~UpdateData()\n{\n    delete(m_doc);\n}"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/type\/Price.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/Boolean.h> #include <strategy\/calculated_property\/CalculatedPropertyFilter.h> #include <strategy\/TreeNodeParameters.h> #include <strategy\/parameter\/StrategyParameters.h> #include <strategy\/parameter\/StrategyInstanceParameters.h> CLANG_RESTORE_WARNINGS #include <set> using namespace tbricks; enum class PreferencesStorageKind { Common = 0, Wing, CCS, SVI, MyCustom = 100000 }; std::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind); \/** * Struct representing the various settings common to all VMs; it is subclassed by structs * containing additional parameters relevant for particular VMs *\/ class PreferencesStorage: public Printable { public: PreferencesStorage(); protected: PreferencesStorage(const PreferencesStorage & storage) = default; PreferencesStorage & operator=(const PreferencesStorage & storage) = default; public: virtual ~PreferencesStorage(); virtual PreferencesStorageKind GetKind() const = 0; virtual void Clear(); virtual void Copy(const PreferencesStorage & preferencesStorage); virtual bool FillFromTreeNodeParameters(const TreeNodeParameters & parameters); virtual bool FillFromStrategyParameters(const StrategyParameters & parameters); virtual bool FillFromStrategyInstanceParameters(const StrategyInstanceParameters & parameters); virtual bool GetParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetParameters(TreeNodeParameters & parameters) const; virtual void GetParameters(StrategyParameters & parameters) const; virtual void GetParameters(StrategyInstanceParameters & parameters) const; virtual bool GetNonDefaultParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetNonDefaultParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetNonDefaultParameters(TreeNodeParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyInstanceParameters & parameters) const; \/\/ Update local values with non-empty values from the passed in<fim-suffix><fim-middle>preferences storage;     \/\/ return true if something got changed as a result, false otherwise"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default;<fim-suffix>JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value &<fim-middle>JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods);"}
{"content":"<fim-prefix>#pragma once\n#include <shared\/API.h>\n#include \"tbricks_definitions.h\"\n\nclass TimerController : public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n<fim-suffix><fim-middle>    {\n    public:\n        virtual ~IHandler() = default;\n        virtual void HandleTimerEventHit() = 0;"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility model types template <class ModelTypePtr> ModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel); template <class ModelTypePtr> ModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel); template <class ModelTypeRef> ModelTypeRef vol_model_cast(volatility::IVolatilityModel & model); template <class ModelTypeRef> ModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model); #define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\ { \\ if (TB_UNLIKELY(!pModel)) { \\ return<fim-suffix>} \\ \\ if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model*>(pModel); \\ } #define VOL_MODEL_REF_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model & vol_model_cast(specifier volatility::IVolatilityModel & rModel) \\<fim-middle>nullptr; \\"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice();<fim-suffix><fim-middle>double GetLastPrice();"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n<fim-suffix><fim-middle>    GetParameters().Merge(parameters);"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__<fim-suffix>} bool DeribitMdp::IsMarketDataSupported(const<fim-middle><< \", item = \" << item);"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\ntypedef std::pair<DeribitMethod, std::string> Method;\n\nstatic std::vector<Method> GetAvailableMethods()\n{\n    return {\n            {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)},\n            {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)},\n            {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)},\n            {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)},\n            {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)},\n            {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)},\n            {DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)},\n<fim-suffix><fim-middle>            {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)},\n            {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}};\n}"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem<fim-suffix><fim-middle>& item) override;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n\nUpdateData::~UpdateData()\n{\n    delete (m_doc);\n}\n<fim-suffix><fim-middle>std::string_view UpdateData::ToString()\n{\n    m_doc->buffer.Clear();\n    Writer<StringBuffer> writer(m_doc->buffer);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream &<fim-suffix>{ ostm.write(&val, sizeof(char)); return ostm; }<fim-middle>ostm, const char val)"}
{"content":"<fim-prefix>#include \"ReversalManager.h\" #include \"tbricks_definitions.h\" #include <map> using namespace tbricks; ReversalManager::ReversalManager(IHandler& callback) : m_callback(callback) , m_scheduledTimer(*this) , m_positionRetriever(*this) { } void ReversalManager::Start( const PortfolioIdentifier& portfolioId, const Integer& priceSource, const Time& startTime) { m_portfolioId = portfolioId; m_priceSource = priceSource; m_scheduledTimer.Start(startTime); } void ReversalManager::Stop() { m_scheduledTimer.Stop(); m_positionRetriever.Stop(); } void ReversalManager::HandleTimerEvent(Timer & timer) { TBDEBUG(__func__); m_positionRetriever.RetreivePositions(m_portfolioId);<fim-suffix><fim-middle>} void ReversalManager::HandleError(const tbricks::String& error)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p<fim-suffix><fim-middle>+ l); } };"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { \/\/<fim-suffix><fim-middle>Here is where we would open the DistributedValues::Stream }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final {} void HandleInstrumentManagerFailed(const tbricks::String& reason) final;<fim-suffix>const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument; } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate; } private: bool CheckRunningRequirement();<fim-middle>const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup; }"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return<fim-suffix><fim-middle>\"*\"; case DeribitKind::FUTURE: return \"future\";"}
{"content":"<fim-prefix>#pragma once<fim-suffix>#include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod<fim-middle>#include <string>"}
{"content":"<fim-prefix>#pragma once #include <third_party\/include\/rapidjson\/document.h> #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker;<fim-suffix>DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t); void OnHeartbeat(deribit::JsonReply && incoming); void OnTestReply(SingleTransaction & t); void OnSubscribeReply(SingleTransaction & t); void OnSubscriptionUpdate(deribit::JsonReply && incoming); void OnInstrumentDownload(SingleTransaction & t); private: SingleTransaction & NewTransaction(const tbricks::Identifier & uuid = tbricks::Uuid::Create()); protected: void PerformTransaction(SingleTransaction & t); private: IHandler & m_handler; std::unique_ptr<TbWebsocketClient> m_ws; TbWebsocketClient::Config m_conf; Session m_session;<fim-middle>DeribitSubscription subscription = DeribitSubscription::NONE;"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ <<<fim-suffix><fim-middle>\": \" << stream);"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n\n    m_client->DownloadInstruments(Uuid::Create(), DeribitCurrency::BTC);\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)\n    {\n<fim-suffix><fim-middle>        HandleTickerUpdate(ticker, \"{}\");\n    }\n    SetState(StrategyState::PAUSED);\n}"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long<fim-suffix><fim-middle>timeout_idle = 0;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n<fim-suffix><fim-middle>{\n    if (not m_tcp.IsOpen())\n        return;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one<fim-suffix>void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream & data);<fim-middle>fragment, text, 130=one fragment, binary, 136=close connection.     \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information."}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\";<fim-suffix>return {}; } } namespace deribit { using Method = std::pair<DeribitMethod, std::string>; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods()<fim-middle>default:"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n<fim-suffix><fim-middle>    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s);<fim-suffix>ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg<fim-middle>}"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument); \/\/ app parameters tbricks::StringParameter m_clientID;<fim-suffix>std::unique_ptr<DeribitClient> m_client; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::DistributedValuesRequest> m_requestMap; tbricks::Set<tbricks::Identifier> m_supported_values;<fim-middle>tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char val) { ostm.write(&val, sizeof(char)); return<fim-suffix><fim-middle>ostm; }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename T> void write(const T & t) { tbricks::Binary vec; vec.Set(reinterpret_cast<const void *>(&t), sizeof(T)); write(vec); } void write(const std::string & s) { write(s.c_str(), s.size()); } void write(const char * p, size_t size) { m_data.Append(p, size); } private: tbricks::Binary m_data; }; template <typename T> Binary_istream & operator>>(Binary_istream & istm, T & val) { istm.read(val); return istm; } template <typename T><fim-suffix>{<fim-middle>Binary_ostream & operator<<(Binary_ostream & ostm, const T & val)"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n<fim-suffix><fim-middle>static std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbChildOrder : public OrderExecutor, public tbricks::StrategyStream::IHandler, public tbricks::IRequestReplyHandler { public: TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app); ~TbChildOrder(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ StrategyStream::IHandler void HandleStrategyUpdate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyUpdate & update) final; void HandleStrategyInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyIdentifier & id) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const<fim-suffix>private: tbricks::Strategy& m_app; tbricks::StrategyStream m_stream; tbricks::Hash<tbricks::Identifier,tbricks::StrategyIdentifier> m_requests; tbricks::Hash<tbricks::InstrumentVenueIdentification,tbricks::StrategyIdentifier> m_childMap;<fim-middle>tbricks::String& status_text) override; private:"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel {<fim-suffix>~DeribitModel() noexcept =<fim-middle>public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n<fim-suffix><fim-middle>    {\n        isTest = test->value.GetBool();\n    }\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n<fim-suffix><fim-middle>    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \":<fim-suffix><fim-middle>id=\" << id << \", value=\" << value);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status); ~PositionsData(); void Stop();<fim-suffix>const Data& GetData() const { return m_data; } protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream)<fim-middle>public: using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction()) , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency()) , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_startTime(instrument_enricher::strategy_parameters::StartTime()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) , m_timerController(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { ImportNow(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); const StrategyParameters& parameters = modifier.GetParameters(); GetParameters().Merge(parameters); MergeAttributes(modifier.GetAttributes()); if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction())) { Integer action; parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action); HandleAction(action); } if (parameters.GetParameter(m_startTime) or parameters.GetParameter(m_importFrequency)) { m_timerController.Update(parameters); } m_instrument_enricherAppAction.Clear(); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.GetItem(m_instrument_enricherAppAction).SetDirection(direction); auto &action_vi = context.GetItem(m_instrument_enricherAppAction); std::vector<Integer> allowed_actions; if (GetState().IsRunning()) { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer); } else { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer); allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow); } action_vi.SetValidValues(allowed_actions); action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT); if (not GetState().IsRunning()) { auto& freqValidationItem = context.GetItem(m_importFrequency); Duration frequency; freqValidationItem.GetValue(frequency); if (not frequency.Empty()<fim-suffix>{ freqValidationItem.SetValue(Duration::Seconds(1)); m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\"; } freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT); } context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } return true; } void InstrumentEnricherPlugin::HandleAction(const Integer & action) { TBDEBUG(__func__ << \" : \" << action); if(TB_UNLIKELY(action.Empty())) { TBDEBUG(\"Action is empty, skipping\"); } switch (action.GetInt()) { case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer: Start(); break; case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer: Stop(); break; case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow: ImportNow(); break; default: TBDEBUG(\"Unknown action\"); break; } } void InstrumentEnricherPlugin::Start() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_timerController.Start(); } SetState(StrategyState::RUNNING); } void InstrumentEnricherPlugin::Stop() { TBDEBUG(__func__); if (GetState().IsPaused()) { TBDEBUG(\"Already stopped\"); return; } if (m_timerController.IsActive()) { m_timerController.Stop(); } m_instrumentManager.Stop(); Strategy::SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::ImportNow() { TBDEBUG(__func__); m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); } void InstrumentEnricherPlugin::HandleImportComplete(const String& status) { TBDEBUG(__func__ << \" : \" << status); m_plugInStatusDescription = status + \" at \" + DateTime::Now().ToString(); if (not m_timerController.IsActive()) { Stop(); } } void InstrumentEnricherPlugin::HandleInstrumentManagerFailed(const String& reason) { TBWARNING(__func__ << \" : Instrument manager failed with reason = \" << reason); HandlePauseRequest(); } void InstrumentEnricherPlugin::HandleTimerEventHit()<fim-middle>and frequency < Duration::Seconds(1))"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nusing InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>;\nusing UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>;\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n<fim-suffix><fim-middle>    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n<fim-suffix><fim-middle>        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n<fim-suffix><fim-middle>template <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext &<fim-suffix><fim-middle>context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults<fim-suffix>\/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming<fim-middle>to no timeout. long timeout_request = 0;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95; const int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally; const double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1; const double CCS_MODEL_MINIMAL_STRIKE = 1.0e-6; const double CCS_MODEL_MINIMAL_SMOOTHNESS = 0.0; const double CCS_MODEL_DEFAULT_SMOOTHNESS = 1.0; const int CCS_MODEL_MINIMAL_NUMBER_OF_CCS_POINTS = 2; const int CCS_MODEL_MAXIMAL_NUMBER_OF_CCS_POINTS = 30; const double CCS_MODEL_DEFAULT_SLOPE_LEFT = -0.05; const double CCS_MODEL_DEFAULT_SLOPE_RIGHT = 0.05; const double CCS_MODEL_DEFAULT_BREAKPOINT_SCALE_FACTOR = 1.0; const double CCS_MODEL_MINIMAL_BREAKPOINT_SCALE_FACTOR = 0.0; const int CCS_MODEL_DEFAULT_ABSCISSA = 0; const double CCS_MODEL_DEFAULT_SLOPE_MULT = 1; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER = 1.0; const double CCS_MODEL_DEFAULT_CCS_BASE_SMILE_WEIGHT = 1.0; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER_SMILE_WEIGHT = 0.0; const double CCS_MODEL_DEFAULT_MULTIPLIER_RATIO = 0.0; const double SVI_MODEL_DEFAULT_A = 0.04; const double SVI_MODEL_DEFAULT_B = 0.4; const double SVI_MODEL_DEFAULT_RHO = -0.4; const double SVI_MODEL_DEFAULT_M = 0.05; const double SVI_MODEL_DEFAULT_SIGMA = 0.1; \/* * Volatility managers need Forward price to fit volatility model parameters * so when there is empty volatility model initially, Pricing cannot calculate * Forward price for underlyings paying capped dividends because the reference volatility is required * for its calculation thus giving us so called chicken-and-egg problem. * 20% volatility is<fim-suffix>* that it does not influence significantly in most<fim-middle>assumed to be a good starting point taking into account"}
{"content":"<fim-prefix>#include \"TbChildOrder.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbChildOrder::TbChildOrder(IExecutionHandler& handler, Strategy& app)\n: OrderExecutor(handler)\n, m_app(app)\n, m_stream(*this)\n{\n    StrategyStream::Options opts;\n    opts.SetFilter(StrategyByParentFilter(app.GetIdentifier()));\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, opts, StrategyStream::ToStrategyEngine);\n    TBDEBUG(__func__ << \" opened stream with options: \" << opts);\n}\n\nTbChildOrder::~TbChildOrder()\n{\n    m_stream.Close();\n    DeleteOrders();\n}\n\nvoid TbChildOrder::DeleteOrders()\n{\n    TBDEBUG(__func__);\n    for (const auto& [ivid,childId] : m_childMap)\n    {\n        if (m_childData[childId].GetState().IsDeleted())\n        {\n            continue;\n        }\n        Strategy::SendDeleteRequest(childId);\n        TBDUMP(\"Sent deletion for \" << childId << \" [\" << ivid << \"]\");\n    }\n}\n\nvoid TbChildOrder::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume,\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n<fim-suffix><fim-middle>    StrategyOptions opts{plug_ins::Order()}; \/\/ very few app definitions in this namespace"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const<fim-middle>& stream_id, const tbricks::DistributedValues::Update & update) override;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const<fim-suffix>virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/<fim-middle>tbricks::String & error) = 0;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n        Channel channel; \/\/ should be always sorted\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\nprivate:\n    void OnLoginReply(SingleTransaction & t);\n    void OnSetHeartbeatReply(SingleTransaction & t);\n    void OnHeartbeat(deribit::JsonReply && incoming);\n    void OnTestReply(SingleTransaction & t);\n\n    void OnSubscribeReply(SingleTransaction & t);\n    void OnSubscriptionUpdate(deribit::JsonReply && incoming);\n<fim-suffix><fim-middle>private:\n    SingleTransaction & NewTransaction(const tbricks::Identifier & uuid = tbricks::Uuid::Create());"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default;<fim-suffix>const tbricks::StreamIdentifier & GetStreamId() const { return<fim-middle>void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n<fim-suffix><fim-middle>void public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}"}
{"content":"<fim-prefix>#include \"PositionReversalsPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nPositionReversalsPlugin::PositionReversalsPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_manager(*this)\n    , m_portfolio(position_reversals::strategy_parameters::Portfolio())\n    , m_startTime(position_reversals::strategy_parameters::PositionReversalStartTime())\n    , m_priceSource(position_reversals::strategy_parameters::PositionReversalPriceSource())\n    , m_status(position_reversals::strategy_parameters::StatusInformationText())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    if (GetTransactionOperation().IsRun())\n    {\n        DoRun();\n    }\n\n}\n\nbool PositionReversalsPlugin::CanRun(tbricks::String& error)\n{\n    TBDEBUG(__func__);\n\n    if (m_portfolio.GetPortfolioIdentifier().Empty())\n    {\n        error = \"No portfolio selected\";\n        return false;\n    }\n\n    if (m_startTime.GetTime().Empty())\n    {\n        error = \"No start time selected\";\n        return false;\n    }\n\n    if (m_priceSource.GetInteger().Empty())\n    {\n        error = \"No price source selected\";\n        return false;\n    }\n\n    return true;\n}\n\nvoid PositionReversalsPlugin::DoRun()\n{\n    TBDEBUG(__func__);\n\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n    String error;\n    if (CanRun(error))\n    {\n        m_manager.Start(m_portfolio.GetPortfolioIdentifier(),\n                        m_priceSource.GetInteger(),\n                        m_startTime.GetTime());\n\n        SetState(StrategyState::RUNNING);\n    }\n    else\n    {\n        m_status = error;\n        SetTransactionFail(error);\n    }\n}\n\nvoid PositionReversalsPlugin::DoPause()\n{\n    m_manager.Stop();\n    SetState(StrategyState::PAUSED);\n}\n\nvoid PositionReversalsPlugin::HandleRunRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n    }\n    else\n    {\n        DoRun();\n    }\n}\n\nvoid PositionReversalsPlugin::HandlePauseRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsPaused())\n    {\n        TBDEBUG(\"Already paused\");\n    }\n    else\n    {\n        DoPause();\n    }\n}\n\nvoid PositionReversalsPlugin::HandleDeleteRequest(void)\n{\n    TBDEBUG(__func__);\n    DoPause();\n    SetState(StrategyState::DELETED);\n}\n\nvoid PositionReversalsPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" modifier: \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid PositionReversalsPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" constext:\"  << context);\n\n    context.SendReply();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewCreate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewUpdate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n\n    m_status = \"\";\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewDelete(visualization::models::AppViewModel& viewModel)\n{\n    TBDEBUG(__func__);\n}\n\nvoid PositionReversalsPlugin::HandleGridViewUpdate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \" update = \" << update);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"shared\/API.h\"\n#include \"execution\/IExecutionHandler.h\"\n\nclass PositionsData;\n\n<fim-suffix><fim-middle>namespace execution {\nclass OrderExecutor;\n}"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin : public tbricks::Pricing { public: ExampleCalcAppPlugin(const tbricks::PricingRequest & request); void<fim-suffix>private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override {}; void HandleRunRequest() override {}; void HandlePauseRequest() override<fim-middle>HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override;"}
{"content":"<fim-prefix>#pragma once #include<fim-suffix>class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/<fim-middle><shared\/API.h>"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm,<fim-suffix>int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <><fim-middle>std::string & val) {"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp<fim-suffix>{ public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem<fim-middle>: public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n<fim-suffix><fim-middle>private:\n    tbricks::Binary m_data;\n    size_t m_index;\n};"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n<fim-suffix><fim-middle>    std::vector<std::string> reqChannels;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewUpdate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    auto it = update.begin();\n    while (it != update.end())\n    {\n        TBDUMP(it.GetCell().GetCalculatedProperty() << \" \" << it.GetCell().GetCellValue());\n\n        auto & calcProp = it.GetCell().GetCalculatedProperty().GetDefinition();\n        auto & cellValue = it.GetCell().GetCellValue();\n\n        if (calcProp == instrument_enricher::calculated_properties::strategy::ImportFrequency())\n        {\n            m_importFrequency = cellValue.GetDuration();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::InstrumentGroup())\n        {\n            m_instrumentGroup = cellValue.GetInstrumentGroupIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::UnderlyingInstrument())\n        {\n            m_underlyingInstrument = cellValue.GetInstrumentIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::StartTime())\n        {\n            m_startTime = cellValue.GetDateTime();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::MaturityDate())\n        {\n            m_maturityDate = cellValue.GetDateTime();\n        }\n\n        ++it;\n    }\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n<fim-suffix><fim-middle>    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n<fim-suffix><fim-middle>    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument*<fim-suffix>}; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding();<fim-middle>m_doc;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n    TBDUMP(update);\n}\n\nstd::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream)\n{\n    auto it_streams = m_streams.find(stream);\n    if (it_streams == m_streams.end())\n    {\n        return std::nullopt;\n    }\n<fim-suffix><fim-middle>    return GetModel(it_streams->second);\n}"}
{"content":"<fim-prefix>#include \"Values.h\"\n#include \"ValuesRequest.h\"\n\nvoid ImpliedValue::Clear()\n{\n    implied_volatility.Clear();\n}\n\nstd::ostream & ImpliedValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"] \" << implied_volatility;\n    return strm;\n}\n\nFairPriceValue & FairPriceValue::operator += (const FairPriceValue & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.fair_price.Empty()) {\n        fair_price += fair_price_value.fair_price;\n    } else if (fair_price_value.fair_price.HasError()) {\n        fair_price.SetError(fair_price_value.fair_price.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue & FairPriceValue::operator += (const Double & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.Empty()) {\n        fair_price += fair_price_value;\n    } else if (fair_price_value.HasError()) {\n        fair_price.SetError(fair_price_value.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue FairPriceValue::operator * (const Double & mult) const\n{\n    FairPriceValue fair_price_value = *this;\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price_value.fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price_value.fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price_value.fair_price.Clear();\n    }\n    return fair_price_value;\n}\n\nFairPriceValue & FairPriceValue::operator *= (const Double & mult)\n{\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nvoid FairPriceValue::Clear()\n{\n    fair_price.Clear();\n}\n\nbool FairPriceValue::SetError(const String & error)\n{\n    if (error == fair_price.GetError()) {\n        return false;\n    }\n\n    fair_price.SetError(error);\n    return true;\n}\n\nstd::ostream & FairPriceValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"]\" << fair_price;\n    return strm;\n}\n\nGreeks & Greeks::operator += (const Greeks & greeks)\n{\n#define TB_GREEKS_ADD(value) \\\n<fim-suffix><fim-middle>    if (!value.Empty() && !greeks.value.Empty()) { \\\n        value += greeks.value; \\\n    } else if (greeks.value.HasError()) { \\\n        value.SetError(greeks.value.GetError()); \\"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n        Channel channel; \/\/ should be always sorted\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\nprivate:\n    void OnLoginReply(SingleTransaction & t);\n    void OnSetHeartbeatReply(SingleTransaction & t);\n    void OnHeartbeat(deribit::JsonReply && incoming);\n    void OnTestReply(SingleTransaction & t);\n\n    void OnSubscribeReply(SingleTransaction & t);\n    void OnSubscriptionUpdate(deribit::JsonReply && incoming);\n    void OnInstrumentDownload(SingleTransaction & t);\n\nprivate:\n    SingleTransaction & NewTransaction(const tbricks::Identifier & uuid = tbricks::Uuid::Create());\n\nprotected:\n    void PerformTransaction(SingleTransaction & t);\n<fim-suffix><fim-middle>private:\n    IHandler & m_handler;\n    std::unique_ptr<TbWebsocketClient> m_ws;\n    TbWebsocketClient::Config m_conf;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n\nprivate:\n    std::string_view type;\n};\n\nclass subscriptions : public JsonCall\n{\npublic:\n    subscriptions(const std::string_view id, DeribitMethod method);\n<fim-suffix><fim-middle>    void AddChannel(const std::string & channel);\n};"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with<fim-suffix>status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency);<fim-middle>just the start time         m_startTimerEvent.Start(m_startTime);"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n<fim-suffix><fim-middle>{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nusing InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>;\nusing UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>;\n<fim-suffix><fim-middle>class InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider<fim-suffix>void HandleUnsubscribe(tbricks::MarketDataItem<fim-middle>void HandleSubscribe(tbricks::MarketDataItem & item) override;"}
{"content":"<fim-prefix>#pragma once #include<fim-suffix><fim-middle><shared\/API.h> #include <deribit\/DeribitClient.h>"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n<fim-suffix><fim-middle>std::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str);<fim-suffix>class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double<fim-middle>protected: RapidDocument* m_doc; };"}
{"content":"<fim-prefix>#include \"PositionsData.h\" #include \"tbricks_definitions.h\" #include <strategy\/Logger.h> #include <strategy\/stream_filter\/PositionByPortfolioFilter.h> #include <strategy\/SparseSet.h> #include <sstream> #include <vector> using namespace tbricks; namespace cps = go_flat::calculated_properties::position; PositionsData::PositionsData(const PortfolioIdentifier& portfolioId, StringParameter& status) : m_appStatus(status) , m_stream(*this) { TBDEBUG(__func__ << \" : \" << portfolioId); CalculatedPropertiesTable::Stream::Options options; options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {}); options.AddProperty(cps::Instrument()); options.AddProperty(cps::Venue()); options.AddProperty(cps::MIC()); options.AddProperty(cps::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS()); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); TBDUMP(\"Stream opened with options: \" << options); } PositionsData::~PositionsData() { TBDEBUG(__func__); m_stream.Close(); } void PositionsData::Stop() { TBDEBUG(__func__); m_stream.Close(); } void PositionsData::HandleStreamOpen(const StreamIdentifier& stream) {<fim-suffix>} void PositionsData::HandleStreamStale(const StreamIdentifier& stream) { m_appStatus = \"STALE STREAM for positions data\"; } void PositionsData::HandleStreamFailed(const StreamIdentifier& stream) { m_appStatus = \"FAILED STREAM for positions data\"; } void PositionsData::HandleSnapshotEnd(const StreamIdentifier& stream) { TBDEBUG(__func__ << \" : \" << stream); RefreshStatusText(); } void PositionsData::HandleCalculatedProperties(const StreamIdentifier & stream_id, const CalculatedPropertiesTable::Update & update) {<fim-middle>m_appStatus = \"Waiting for positions data\";"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/<fim-suffix><fim-middle>ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final;"}
{"content":"<fim-prefix>#include \"ReversalManager.h\"\n#include \"tbricks_definitions.h\"\n#include <map>\n\nusing namespace tbricks;\n\nReversalManager::ReversalManager(IHandler& callback)\n: m_callback(callback)\n, m_scheduledTimer(*this)\n, m_positionRetriever(*this)\n{\n}\n\nvoid ReversalManager::Start( const PortfolioIdentifier& portfolioId,\n            const Integer& priceSource,\n            const Time& startTime)\n{\n    m_portfolioId = portfolioId;\n    m_priceSource = priceSource;\n    m_scheduledTimer.Start(startTime);\n}\n\nvoid ReversalManager::Stop()\n{\n    m_scheduledTimer.Stop();\n    m_positionRetriever.Stop();\n}\n\nvoid ReversalManager::HandleTimerEvent(Timer & timer)\n{\n    TBDEBUG(__func__);\n    m_positionRetriever.RetreivePositions(m_portfolioId);\n}\n<fim-suffix><fim-middle>void ReversalManager::HandleError(const tbricks::String& error)\n{\n    m_callback.HandleError(error);\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); \/\/ Perform an operation SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ?<fim-suffix><fim-middle>ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n<fim-suffix><fim-middle>    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n<fim-suffix><fim-middle>{\npublic:\n    Binary_istream()\n        : m_index(0)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n<fim-suffix><fim-middle>class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);\n\n     if (id.second != m_tickerId)\n    {\n        TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);\n        return;\n    }\n\n    if (value.Empty() or (value == \"{}\") or value.HasError())\n    {\n        Price emptyPrice;\n        Volume emptyVolume {0};\n        iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale);\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\");\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        bbo.SetAskPrice(emptyPrice);\n        bbo.SetBidPrice(emptyPrice);\n        bbo.SetAskVolume(emptyVolume);\n        bbo.SetBidVolume(emptyVolume);\n        return;\n    }\n\n    iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk);\n    iStatus.SetVenueInstrumentMarketDataStatus(\"OK\");\n\n    deribit::ticker_update update(value);\n\n    if (update.IsOpen())\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed);\n    }\n    else\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed);\n    }\n\n    bbo.SetAskPrice(update.GetAsk());\n    bbo.SetBidPrice(update.GetBid());\n    bbo.SetAskVolume(update.GetAskVolume());\n    bbo.SetBidVolume(update.GetBidVolume());\n    auto millis = update.GetTimestamp();\n    DateTime timestamp = DateTime::Now();\n    if (millis > 0)\n    {\n        timestamp = DateTime::Create(millis \/ 1000);\n    }\n    bbo.SetExchangeModifiedDatetime(timestamp);\n    \n    stats.SetLastPrice(update.GetLastPrice());\n    stats.SetOpenInterest(update.GetOpenInterest());\n    stats.SetDailySettlementPrice(update.GetSettlementPrice());\n    stats.SetHighPrice(update.GetMaxPrice());\n    stats.SetLowPrice(update.GetMinPrice());\n}\n\nvoid DeribitModel::Reset()\n<fim-suffix><fim-middle>{\n    InstrumentStatus status;\n    BestPrice bbo;\n    Price emptyPrice;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; private: \/\/ App parameters<fim-suffix><fim-middle>};"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/<fim-suffix>status = \"Timer started, repeats \" +<fim-middle>start with just the frequency         m_startTimerEvent.Start(m_frequency);"}
{"content":"<fim-prefix>#include \"TimerController.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nTimerController::TimerController(IHandler& handler)\n    : m_handler(handler)\n    , m_startTimerEvent(*this)\n{\n}\n\nvoid TimerController::HandleTimerEvent(Timer& timer)\n{\n    TBDEBUG(__func__ );\n    m_timerLastFired = DateTime::Now();\n\n    if (timer == m_startTimerEvent)\n    {\n        m_handler.HandleTimerEventHit();\n    }\n}\n\nvoid TimerController::Update(const StrategyParameters& strategyParameters)\n{\n    TBDEBUG(__func__);\n    TBDUMP(strategyParameters);\n\n    strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime);\n    strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency);\n}\n\nvoid TimerController::Start()\n{\n    TBDEBUG(__func__);\n    String status;\n\n    if (m_frequency.Empty() and m_startTime.Empty())\n    {\n<fim-suffix><fim-middle>        m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true);\n        return;\n    }"}
{"content":"<fim-prefix>#pragma once\n\n#include <string_view>\n#include <strategy\/type\/String.h>\n\nnamespace deribit {\n\nstruct RapidDocument;\n\nclass UpdateData\n{\npublic:\n    UpdateData();\n    virtual ~UpdateData();\n\n    std::string_view ToString();\n    void Parse(const tbricks::String & str);\n\nprotected:\n    RapidDocument * m_doc;\n};\n\nclass ticker_update : public UpdateData\n<fim-suffix><fim-middle>{\npublic:\n    ticker_update(const tbricks::String & str);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification<fim-suffix>void SendSnapshotDoneIfNeeded(); private:<fim-middle>& id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double,<fim-suffix><fim-middle>HedgeAskImpliedVolatility)"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc;<fim-suffix>{ public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double<fim-middle>}; class ticker_update : public UpdateData"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index;<fim-suffix>{ public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename T> void write(const T & t) { tbricks::Binary vec; vec.Set(reinterpret_cast<const void *>(&t), sizeof(T)); write(vec); } void write(const std::string & s) { write(s.c_str(), s.size()); } void write(const char * p, size_t size) { m_data.Append(p, size); } private: tbricks::Binary m_data; }; template <typename T> Binary_istream & operator>>(Binary_istream & istm, T & val) { istm.read(val);<fim-middle>}; class Binary_ostream"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n<fim-suffix><fim-middle>        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\"\n#include \"tbricks_definitions.h\"\n\n#include <sstream>\n#include <string>\n\nusing namespace tbricks;\n\nPositionRetriever::PositionRetriever(IHandler& callback)\n    : m_callback(callback)\n    , m_positionStream(*this)\n{\n}\n\nvoid PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId)\n{\n    TBDEBUG(__func__ << \" portfolio: \" << portfolioId);\n\n    m_positions.clear();\n    m_wasStreamStale = false;\n\n    TBDEBUG(__func__);\n\n    if (m_positionStream.IsOpen())\n    {\n        m_positionStream.Close();\n    }\n\n    m_positionStream.Open(  Stream::SNAPSHOT,\n                            portfolioId,\n                            Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET,\n                            AnyPositionFilter());\n}\n\nvoid PositionRetriever::Stop()\n{\n    m_positionStream.Close();\n    m_positions.clear();\n}\n\nvoid PositionRetriever::HandleStreamOpen(const StreamIdentifier& stream_id)\n{\n    if (m_positionStream.GetIdentifier() == stream_id)\n    {\n        if (not m_wasStreamStale)\n        {\n            TBDEBUG(__func__ << \" Stream opened: \" << stream_id);\n        }\n        else\n        {\n            TBNOTICE(\"Stream reconnected\");\n            m_wasStreamStale = false;\n        }\n    }\n    else\n    {\n        TBDEBUG(__func__ << \" Unknown opened stream: \" << stream_id);\n    }\n}\n\nvoid PositionRetriever::HandleStreamStale(const StreamIdentifier& stream_id)\n{\n    if (m_positionStream.GetIdentifier() == stream_id)\n    {\n        TBWARNING(__func__ << \" Stream became stale: \" << stream_id);\n        m_wasStreamStale = true;\n    }\n    else\n    {\n        TBWARNING(__func__ << \" Unknown stale stream: \" << stream_id);\n    }\n}\n\nvoid PositionRetriever::HandleStreamFailed(const StreamIdentifier& stream_id)\n{\n    if (m_positionStream.GetIdentifier() == stream_id)\n    {\n        std::stringstream error;\n        error << \"Stream failed: \" << stream_id;\n        m_callback.HandleError(error.str());\n    }\n    else\n    {\n        TBWARNING(__func__ << \" Unknown failed stream: \" << stream_id);\n    }\n}\n\nvoid PositionRetriever::HandleSnapshotEnd(const StreamIdentifier& stream_id)\n{\n    if (m_positionStream.GetIdentifier() == stream_id)\n    {\n        TBDEBUG(__func__ << \" Snapshot end received on stream: \" << stream_id);\n        m_callback.HandlePositions(m_positions);\n    }\n    else\n    {\n        TBDEBUG(__func__ << \" Received snapshot end on unknown stream: \" << stream_id);\n    }\n}\n\nvoid PositionRetriever::HandlePosition(const tbricks::StreamIdentifier & stream_id,\n                                    const tbricks::Position & position)\n{\n    TBDEBUG(__func__ << \" \" << stream_id);\n    TBDUMP(position);\n\n    if (m_positionStream.GetIdentifier() == stream_id)\n    {\n        m_positions.emplace(position.GetIdentifier(), position);\n    }\n    else\n    {\n        TBDEBUG(__func__ << \" Received position on unknown stream: \" << stream_id);\n    }\n}\n\nvoid PositionRetriever::HandlePositionInvalidate(  const tbricks::StreamIdentifier & stream_id,\n                                                const tbricks::Identifier & id)\n<fim-suffix><fim-middle>{\n    if (m_positionStream.GetIdentifier() == stream_id)\n    {\n        TBDEBUG(__func__ << \" Received invalidated position on stream: \" << stream_id);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include<fim-suffix>using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual<fim-middle><strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats); void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem; tbricks::Identifier m_tickerId; bool<fim-suffix><fim-middle>m_snapshotDone {false}; };"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price,<fim-suffix>EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetIndexPrice, index_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetCurrentFunding, current_funding, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetBid,<fim-middle>0)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const<fim-suffix><fim-middle>tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n\nprotected:\n    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;\n    void HandleStreamClose(tbricks::TCPStream & stream) final;\n\n    void UpgradeWs();\n\nprivate:\n    std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept;\n\n    void ParseHttpReply(const tbricks::Binary & data);\n    std::size_t ReadWsReply(std::istream & data);\n    void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length);\n\nprivate:\n    IWebsocketHandler & m_handler;\n    tbricks::TCPStream m_tcp;\n    std::random_device m_rd;\n    std::shared_ptr<std::string> nonce_base64;\n\n    Config m_config;\n\n    std::string host;\n    unsigned short port;\n    std::string path;\n    bool m_handshake_done = false;\n\n<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include<fim-suffix>#include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public:<fim-middle><strategy\/type\/String.h>"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator &<fim-suffix>void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem; tbricks::Identifier m_tickerId; bool m_snapshotDone {false};<fim-middle>it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/order_minion\/OrderMinionController.h\" #include \"shared\/order_minion\/OrderMinionRequest.h\" namespace execution { class TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler { public: TbOrderMinion(IExecutionHandler& handler, tbricks::Strategy& app, const tbricks::InitializationReason& reason, const tbricks::StrategyParameters& parameters); ~TbOrderMinion(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume,<fim-suffix>void MonitorInstrument(const tbricks::InstrumentVenueIdentification& ivid); protected: \/\/ OrderMinionRequest::IHandler void HandleOrderMinionUpdate( const OrderMinionUpdate& update ) override; private: void UpdateStats(const OrderMinionUpdate& update, const<fim-middle>"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing) VOLATILITY(custom,<fim-suffix><fim-middle>Custom) VOLATILITY(my_custom, MyCustom)"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen();<fim-suffix><fim-middle>double GetSettlementPrice(); double GetOpenInterest();"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double<fim-suffix>double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double GetBid();<fim-middle>GetSettlementPrice();"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0;<fim-suffix>return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out =<fim-middle>istm.read(size); if (size <= 0)"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/order_minion\/OrderMinionController.h\" #include \"shared\/order_minion\/OrderMinionRequest.h\" namespace execution { class TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler { public: TbOrderMinion(IExecutionHandler& handler, tbricks::Strategy& app, const tbricks::InitializationReason& reason, const tbricks::StrategyParameters& parameters); ~TbOrderMinion(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; void MonitorInstrument(const tbricks::InstrumentVenueIdentification& ivid); protected:<fim-suffix>private: void<fim-middle>"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0;<fim-suffix>const double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95; const int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally; const double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1; const double CCS_MODEL_MINIMAL_STRIKE = 1.0e-6; const double CCS_MODEL_MINIMAL_SMOOTHNESS = 0.0; const double CCS_MODEL_DEFAULT_SMOOTHNESS = 1.0; const int CCS_MODEL_MINIMAL_NUMBER_OF_CCS_POINTS = 2; const int CCS_MODEL_MAXIMAL_NUMBER_OF_CCS_POINTS = 30; const double<fim-middle>const double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char val) { ostm.write(&val, sizeof(char)); return<fim-suffix><fim-middle>ostm; }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size<fim-suffix>\/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server;<fim-middle>= (std::numeric_limits<std::size_t>::max)();"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n    \n    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);\n    \n<fim-suffix><fim-middle>    if (read > 0 && read < m_buffer.GetSize())\n    {\n        Binary fragment(&static_cast<char *>(m_buffer.GetData())[read], "}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just<fim-suffix><fim-middle>the frequency         m_startTimerEvent.Start(m_frequency);"}
{"content":"<fim-prefix>#include \"PositionReversalsPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nPositionReversalsPlugin::PositionReversalsPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_manager(*this)\n    , m_portfolio(position_reversals::strategy_parameters::Portfolio())\n    , m_startTime(position_reversals::strategy_parameters::PositionReversalStartTime())\n    , m_priceSource(position_reversals::strategy_parameters::PositionReversalPriceSource())\n    , m_status(position_reversals::strategy_parameters::StatusInformationText())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    if (GetTransactionOperation().IsRun())\n    {\n        DoRun();\n    }\n\n}\n\nbool PositionReversalsPlugin::CanRun(tbricks::String& error)\n{\n    TBDEBUG(__func__);\n\n    if (m_portfolio.GetPortfolioIdentifier().Empty())\n    {\n        error = \"No portfolio selected\";\n        return false;\n    }\n\n    if (m_startTime.GetTime().Empty())\n    {\n        error = \"No start time selected\";\n        return false;\n    }\n\n    if (m_priceSource.GetInteger().Empty())\n    {\n        error = \"No price source selected\";\n        return false;\n    }\n\n    return true;\n}\n\nvoid PositionReversalsPlugin::DoRun()\n{\n    TBDEBUG(__func__);\n\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n    String error;\n    if (CanRun(error))\n    {\n        m_manager.Start(m_portfolio.GetPortfolioIdentifier(),\n                        m_priceSource.GetInteger(),\n                        m_startTime.GetTime());\n\n        SetState(StrategyState::RUNNING);\n    }\n    else\n    {\n        m_status = error;\n        SetTransactionFail(error);\n    }\n}\n\nvoid PositionReversalsPlugin::DoPause()\n{\n    m_manager.Stop();\n    SetState(StrategyState::PAUSED);\n}\n\nvoid PositionReversalsPlugin::HandleRunRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n    }\n    else\n    {\n        DoRun();\n    }\n}\n\nvoid PositionReversalsPlugin::HandlePauseRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsPaused())\n    {\n        TBDEBUG(\"Already paused\");\n    }\n    else\n    {\n        DoPause();\n    }\n}\n\nvoid PositionReversalsPlugin::HandleDeleteRequest(void)\n{\n    TBDEBUG(__func__);\n    DoPause();\n    SetState(StrategyState::DELETED);\n}\n\nvoid PositionReversalsPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" modifier: \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid PositionReversalsPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" constext:\"  << context);\n\n    context.SendReply();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewCreate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewUpdate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n\n    m_status = \"\";\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewDelete(visualization::models::AppViewModel& viewModel)\n{\n    TBDEBUG(__func__);\n}\n\nvoid PositionReversalsPlugin::HandleGridViewUpdate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n    viewModel.RejectUnconfirmedModifications();\n}\n\nvoid PositionReversalsPlugin::HandleGridViewDelete(visualization::models::GridViewModel& viewModel)\n{\n    TBDEBUG(__func__);\n}\n<fim-suffix><fim-middle>void PositionReversalsPlugin::HandleGridViewCreate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    HandleGridViewUpdate(viewModel, update);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"IExecutionHandler.h\"\n#include \"shared\/API.h\"\n\nnamespace execution {\n<fim-suffix><fim-middle>class OrderExecutor\n{\npublic:\n    virtual ~OrderExecutor() = default;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/test\/TestEngine.h>\n\nusing namespace tbricks;\nusing namespace tbricks::test;\n<fim-suffix><fim-middle>#ifndef TIMEOUT\n#define TIMEOUT tbricks::Duration::Seconds(5)\n#endif"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier<fim-suffix><fim-middle>& stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem &<fim-suffix><fim-middle>item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"shared\/API.h\"\n<fim-suffix><fim-middle>class ExampleCalcAppPlugin2 : public tbricks::Pricing\n{\npublic:"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n<fim-suffix><fim-middle>    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double,<fim-suffix><fim-middle>UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void<fim-suffix>void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest &<fim-middle>HandleModifyRequest(const tbricks::StrategyModifier & modifier) override;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionReverser :<fim-suffix>{ public: PositionReverser() = default; ~PositionReverser() = default; void ReversePosition( const tbricks::Position& position, const tbricks::Price& atPrice); \/\/ IRequestReplyHandler method<fim-middle>public tbricks::IRequestReplyHandler"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <deribit\/DeribitInstrument.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0; virtual void HandleInstrumentManagerReady() = 0; virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0; virtual void HandleInstrumentError(const tbricks::String & error) = 0; }; explicit InstrumentManager(IHandler & handler); ~InstrumentManager() override; \/\/ Add instruments from Deribit<fim-suffix><fim-middle>void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument);"}
{"content":"<fim-prefix>#pragma once<fim-suffix>#include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream<fim-middle>#include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\""}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize())<fim-suffix><fim-middle>throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\" class PositionsData; namespace execution { class OrderExecutor; } namespace misc { class AsyncProcessor; } class GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler { public: GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ Strategy methods void HandleDeleteRequest() override; void HandleRunRequest() override; void HandlePauseRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override; void HandleValidateRequest(tbricks::ValidationContext &context) override; void HandleScheduledEvent(tbricks::UserData&& data) override; \/\/ OrderHandler::IHandler void PanicStop(const tbricks::String& msg) override; void AllDone(const execution::Stats& stats) override; private: \/\/ app parameters tbricks::PortfolioIdentifierParameter m_portfolio; tbricks::StringParameter m_statusText;<fim-suffix>tbricks::EventProcessor m_proc; std::unique_ptr<misc::AsyncProcessor><fim-middle>std::unique_ptr<PositionsData> m_positions; std::unique_ptr<execution::OrderExecutor> m_orders;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void<fim-suffix>{ m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <=<fim-middle>Binary_ostream::write(const tbricks::Binary & in)"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n<fim-suffix><fim-middle>{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>DeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual<fim-suffix>void Parse(const tbricks::String & str);<fim-middle>~UpdateData(); std::string_view ToString();"}
{"content":"<fim-prefix>#pragma once #include \"IExecutionHandler.h\" #include \"shared\/API.h\" namespace execution { class OrderExecutor { public: virtual ~OrderExecutor()<fim-suffix><fim-middle>= default;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t); void OnHeartbeat(deribit::JsonReply && incoming); void OnTestReply(SingleTransaction & t); void OnSubscribeReply(SingleTransaction & t); void OnSubscriptionUpdate(deribit::JsonReply && incoming); private: SingleTransaction & NewTransaction(const tbricks::Identifier & uuid<fim-suffix><fim-middle>= tbricks::Uuid::Create()); protected: void PerformTransaction(SingleTransaction & t);"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired) VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel) VOLATILITY_MODEL_WRAP(None,ConstantVolatility)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(MyCustom,MyCustomVolatilityModel)"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n<fim-suffix><fim-middle>{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)\n    {\n        HandleTickerUpdate(ticker, \"{}\");\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n<fim-suffix><fim-middle>{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n    {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats); tbricks::DistributedValues::Stream<fim-suffix><fim-middle>m_stream; tbricks::MarketDataItem m_mdItem;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json();<fim-suffix>std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod<fim-middle>Json(Json &&);"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\" #include \"shared\/order_minion\/OrderMinionCancelRequest.h\" #include \"shared\/order_minion\/tbricks_definitions.h\" #include \"shared\/sdk_definitions.h\" using namespace tbricks; namespace execution { TbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters) : OrderExecutor(handler) , m_controller( reason, app) { TBDEBUG(__func__); } TbOrderMinion::~TbOrderMinion() { TBDEBUG(__func__); DeleteOrders(); } void TbOrderMinion::CreateOrder( const InstrumentVenueIdentification& ivid, const Volume& volume, \/\/ negative for sell const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio); OrderMinionRequest req(this); req.SetExecution(enumerations::OrderMinionExecutionHitRepeatedly); req.SetIVID(ivid); req.SetMarketDataIVID(ivid); req.SetPortfolio(portfolio); req.SetSide((volume > 0.0 ? Side::BUY : Side::SELL)); req.SetVolume(volume.Abs()); req.SetPriceMode(enumerations::OrderMinionPrice::OrderMinionPriceBestPossible); auto result = m_controller.Request(req); if (result == OrderMinionController::FAILURE) { m_handler.PanicStop(result.GetError()); return; } m_requests[ivid] = req; } void TbOrderMinion::DeleteOrders() { TBDEBUG(__func__); m_controller.Stop(); } void TbOrderMinion::MonitorInstrument(const InstrumentVenueIdentification &ivid) { m_controller.Prepare(ivid); } void TbOrderMinion::HandleOrderMinionUpdate( const OrderMinionUpdate& update ) { TBDEBUG(__func__ << \" : \" << update); if (update.DidFail()) { m_handler.PanicStop(update.GetError()); } else if (update.IsFinished()) { const auto& reqId = update.GetRequestID(); auto it = std::find_if(m_requests.begin(), m_requests.end(), [&reqId](const auto& req){ return req.second.GetRequestID() == reqId; }); if (it == m_requests.end()) { TBWARNING(\"Received update for unknown request\"); return; } TBDEBUG(\"Completed order for \" << it->second.GetIVID()); UpdateStats(update, it->second); m_requests.erase(it); } if (m_requests.empty()) { m_handler.AllDone(m_stats); } } void TbOrderMinion::UpdateStats(const OrderMinionUpdate& update, const OrderMinionRequest& request) { if (request.GetSide().IsBuy()) { m_stats.bought += update.GetFilledVolume(); m_stats.valueBought += (update.GetFilledVolume() * update.GetAveragePaid()); } else<fim-suffix>m_stats.valueSold += (update.GetFilledVolume() * update.GetAveragePaid()); } } } \/\/ namespace execution<fim-middle>{ m_stats.sold += update.GetFilledVolume();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier<fim-suffix><fim-middle>&modifier) final;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume {0}; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail() { InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::SendSnapshotDoneIfNeeded() { TBDEBUG(__func__); if (TB_UNLIKELY(!m_snapshotDone)) { m_mdItem.SendSnapshotDone(); m_snapshotDone<fim-suffix><fim-middle>= true; }"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void<fim-suffix><fim-middle>TryError(SingleTransaction & t); protected:"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n<fim-suffix><fim-middle>{\n    m_doc = new RapidDocument();\n}"}
{"content":"<fim-prefix>#include \"..\/shared_config.h\" #include \"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/tbricks_definitions.h\" #include <tests\/shared\/test_utils\/TestUtils.h> \/** This test is designed for the version of GoFlatPlugin using TbOrderManager (no TbOrderMinion). Please set the hardcoded flag of the app m_useMinions = false *\/ void Test(TestEngine& te) { \/* Test variables *\/ VenueInstrumentIdentifier viidOne; Instrument instrumentOne; StrategyIdentifier appId; PortfolioIdentifier portfolioId{go_flat::GetPortfolioId()}; TBSTATUS(\"Initialize instruments\"); { VenueIdentifier venueId = go_flat::GetTestVenueId(); viidOne.SetMIC(\"XXXX\"); viidOne.SetVenueIdentifier(venueId); viidOne.Add(\"symbol\", \"ONE\"); std::vector<VenueInstrumentIdentifier> viids = {viidOne}; Instrument::Options options; options.SetShortName(\"ONE\"); options.SetVenueInstrumentIdentifiers(viids); instrumentOne = te.GetIS().CreateInstrument(options); } TBSTATUS(\"Prepare calculated properties\"); { CalculatedPropertiesTableUpdate cpUpdate; auto rowId = Uuid::Create(); cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Instrument(), instrumentOne.GetIdentifier()); cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Venue(), go_flat::GetTestVenueId()); cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::MIC(), MIC{\"XXXX\"}); cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS(), Volume{100}); CalculatedPropertiesTable::Stream::Options options; options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {}); cpUpdate.SetFilter(options.GetFilter()); cpUpdate.SetRowDataType(static_cast<CalculatedPropertiesTable::RowDataType>(5)); te.GetXE().UpdateCalculatedProperties(cpUpdate); } TBSTATUS(\"Prepare market data\"); { BestPrice best; best.SetBidPrice(38.0); best.SetBidVolume(100); best.SetAskPrice(39.0); best.SetAskVolume(100); te.GetMD(go_flat::GetTestVenueId()).UpdateBestPrice(viidOne, best); } TBSTATUS(\"Prepare trading information\"); { tbricks::test::InstrumentTradingInformation iti; iti.SetCurrency(\"USD\"); iti.SetDefaultTick(Price(0.1)); iti.SetLotVolume(Volume(10)); iti.SetMinimumVolume(Volume(10)); TestEngine::Get().GetTRD(viidOne.GetVenueIdentifier()).CreateInstrumentTradingInformation(viidOne, iti); } TBSTATUS(\"Setup the app\"); { StrategyOptions options(go_flat::plug_ins::GoFlat()); appId = te.CreatePlugin(options, {}, true); StrategyModifier modifier; StrategyParameters params; params.SetParameter(go_flat::strategy_parameters::Portfolio(), portfolioId); modifier.SetParameters(params); te.ModifyPlugin(appId, modifier, true); } TBSTATUS(\"Run the app\"); { te.FlushAllQueues(); te.FlushAllQueues(); te.FlushAllQueues(); te.FlushAllQueues(); te.FlushAllQueues(); te.FlushAllQueues(); te.RunPlugin(appId, true); } TBSTATUS(\"Wait order creation\"); { auto orderReq = te.GetTR(go_flat::GetTestVenueId()).WaitOrderCreate(); ASSERT_TRUE(orderReq.GetSide() == Side::SELL, \"Wrong side of the<fim-suffix>ASSERT_TRUE(orderReq.GetPrice()<fim-middle>order. Expected SELL\"); ASSERT_TRUE(orderReq.GetActiveVolume() == Volume{100}, \"Wrong volume of the order. Expected 100\");"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n<fim-suffix><fim-middle>void DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n<fim-suffix><fim-middle>        SimpleWeb::CaseInsensitiveMultimap header;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n<fim-suffix><fim-middle>    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }"}
{"content":"<fim-prefix>#pragma once\n\n#include <string_view>\n#include <strategy\/type\/String.h>\n\nnamespace deribit {\n\nstruct RapidDocument;\n\nclass UpdateData\n{\npublic:\n    UpdateData();\n    virtual ~UpdateData();\n\n    std::string_view ToString();\n    void Parse(const tbricks::String& str);\n\nprotected:\n    RapidDocument* m_doc;\n};\n\nclass ticker_update : public UpdateData\n{\npublic:\n    ticker_update(const tbricks::String& str);\n<fim-suffix><fim-middle>    std::string_view GetInstrumentName();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus<fim-suffix><fim-middle>& iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason &<fim-suffix>\/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context)<fim-middle>reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model);<fim-suffix><fim-middle>m_streams.emplace(model.GetStreamId(), instrument_id); }"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; };<fim-suffix>{ public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const;<fim-middle>class JsonCall : public Json"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n\n    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;\n\n    bool ParallelVerticalShift() const;\n\n    const InstrumentGroup & GetCurrentProductGroup() const { return m_instrumentGroup.GetInstrumentGroup(); }\n    const InstrumentGroup & GetReferenceInstrumentGroup() const { return m_refInstrumentGroup.GetInstrumentGroup(); }\n\n    const InstrumentIdentifier & GetFocusInstrumentIdentifier() const { return m_followedInstrumentId.GetInstrumentIdentifier(); }\n    const Integer & GetFocusInstrumentGroupType() const { return m_instrumentGroupType.GetInteger(); }\n\n    bool NoLayoutInterfaceMode() const { return !m_noLayoutInterfaceMode.Empty() && m_noLayoutInterfaceMode.GetBoolean(); }\n\n    bool GlobalAutoApplyManualFit() const { return !m_globalAutoApplyManualFit.Empty() && m_globalAutoApplyManualFit.GetBoolean(); }\n\n    bool GlobalAutoSuggest() const { return !m_globalAutoSuggest.Empty() && m_globalAutoSuggest.GetBoolean(); }\n\n    int CurveShiftUnits() const;\n\n    bool UseExoticOptions() const { return m_currentProductCommonValuesHandler.UseExoticOptions(); }\n    const CalculatedPropertyFilter & GetInstrumentFilter() const { return m_currentProductCommonValuesHandler.GetInstrumentFilter(); }\n<fim-suffix><fim-middle>    bool IsLiveFeedDisabled() const { return !m_disableLiveFeed.Empty() && m_disableLiveFeed.GetBoolean(); }"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return false;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n<fim-suffix><fim-middle>DEFINE_STRATEGY_ENTRY(DeribitMdp)"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool<fim-suffix>double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice();<fim-middle>IsOpen(); double GetSettlementPrice();"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nusing InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>;\nusing UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>;\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n\n    InstrumentManager(IHandler& handler);\n    ~InstrumentManager();\n    void Start();\n    void Stop();\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;\n\n<fim-suffix><fim-middle>    void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {};"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler<fim-suffix>const tbricks::CalculatedInstrumentValues::Update & update) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final; private: void OpenInstrumentStream(); void OpenIAPStream(); void OpenCIVStream(); void EnrichInstruments(); void ModifyGroup(); void CheckResolutionStatus(); void CheckModificationStatus(); void PopulateGrid(); struct InstrumentDetails { tbricks::Instrument instrument; tbricks::DateTime maturityDate; tbricks::InstrumentIdentifier underlyingInstrument; tbricks::Price underlyingPrice; tbricks::RowEntityIdentifier gridRowIdentifier;<fim-middle>interface     void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId,"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context)<fim-suffix><fim-middle>final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public<fim-suffix>, public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final;<fim-middle>tbricks::Strategy , public InstrumentManager::IHandler"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n<fim-suffix><fim-middle>        return {};\n    }\n}"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)\n    {\n        strm << \"  subscription : \" << Resolve(subscription) << \"\\n\";\n    }\n    if (interval != DeribitInterval::NONE)\n    {\n        strm << \"  interval : \" << Resolve(interval) << \"\\n\";\n    }\n    strm << \"  channel : \" << channel << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nDeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type)\n    : m_handler(handler)\n    , m_timer(*this, \"deribit_refresh\")\n{\n    TBDEBUG(__func__ << \" : \" << endpoint);\n\n    std::string url(endpoint.GetCString());\n    auto found = url.find(\":\/\/\");\n    if (found != std::string::npos)\n    {\n        url = url.substr(found + 3);\n    }\n    m_session.host_port_path = url;\n\n    std::vector<String> slices;\n    m_session.host_port_path.Split(':', slices);\n    TBDUMP(slices);\n    switch (type)\n    {\n    case DeribitHost::NONE:\n        m_conf.header.insert({\"Host\", slices[0].GetCString()});\n        break;\n    default:\n        m_conf.header.insert({\"Host\", Resolve(type)});\n        break;\n    }\n}\n\nDeribitClient::~DeribitClient()\n{\n    TBDEBUG(__func__);\n    Disconnect();\n}\n\nvoid DeribitClient::Connect(const String & userId, const String & secret)\n{\n    TBDEBUG(__func__ << \" : userId=\" << userId << \" secret=\" << secret);\n    m_session.userId = userId;\n    m_session.secret = secret;\n\n    m_ws = std::make_unique<TbWebsocketClient>(*this, m_session.host_port_path, m_conf);\n    m_ws->Connect();\n}\n\nvoid DeribitClient::Disconnect()\n{\n    TBDEBUG(__func__);\n    if (m_ws)\n    {\n        m_session.logged_in = false;\n        m_ws->Shutdown();\n    }\n}\n\nvoid DeribitClient::SetHeartbeat(int seconds)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \" : \" << seconds << \"s\");\n    m_session.hb = seconds;\n    if (m_ws)"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"WingPreferencesStorage.h\"\n#include \"CCSPreferencesStorage.h\"\n#include \"SVIPreferencesStorage.h\"\n#include \"MyCustomPreferencesStorage.h\"\n#include <shared\/Macros.h>\n#include <shared\/SuppressSfApiClangWarnings.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/Exception.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\nusing namespace tbricks;\n\nclass BadPreferencesStorageCast: public Exception\n{\nprivate:\n    static String PreferenceKindsToString(const PreferencesStorageKind from,\n                                          const PreferencesStorageKind to)\n    {\n        std::stringstream sstrm;\n        sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to;\n        return std::move(sstrm).str();\n    }\n\npublic:\n    BadPreferencesStorageCast(const PreferencesStorageKind from,\n                              const PreferencesStorageKind to) :\n        Exception(PreferenceKindsToString(from, to))\n    {}\n};\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage);\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage);\n\ntemplate <class PreferencesStorageRef>\nPreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage);\n\ntemplate <class PreferencesStorageRef>\nPreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage);\n\n#define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\\n    template <> \\\n    inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\\n    { \\\n        if (TB_UNLIKELY(!pPreferencesStorage)) { \\\n            return nullptr; \\\n        } \\\n        \\\n        if (TB_UNLIKELY((pPreferencesStorage->GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\\n            throw BadPreferencesStorageCast(pPreferencesStorage->GetKind(), kind); \\\n        } \\\n        \\\n        return reinterpret_cast<specifier type*>(pPreferencesStorage); \\\n    }\n<fim-suffix><fim-middle>#define PREFERENCES_STORAGE_REF_CAST_IMPL(specifier, type, kind) \\\n    template <> \\\n    inline specifier type & pref_storage_cast(specifier PreferencesStorage & preferencesStorage) \\\n    { \\"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override; \/\/ MDTracker::IHandler void HandleBBOUpdate( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::BestPrice& before, const tbricks::BestPrice& change ) override; void<fim-suffix>private:<fim-middle>HandleSnapshotEnd(const tbricks::InstrumentVenueIdentification& ivid) override;"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    if (not m_client)\n    {\n        m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_PROD);\n    }\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n\n    m_instrumentManager.Start();\n    m_client->DownloadInstruments(Uuid::Create(), DeribitCurrency::BTC);\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)\n    {\n        HandleTickerUpdate(ticker, \"{}\");\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n<fim-suffix><fim-middle>    {\n        TBWARNING(\"Received unknown instrument ticker: \" << ticker);\n        return;\n    }"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp>\n#include <shared\/SuppressSfApiClangWarnings.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/Price.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/Boolean.h>\n#include <strategy\/calculated_property\/CalculatedPropertyFilter.h>\n#include <strategy\/TreeNodeParameters.h>\n#include <strategy\/parameter\/StrategyParameters.h>\n#include <strategy\/parameter\/StrategyInstanceParameters.h>\nCLANG_RESTORE_WARNINGS\n#include <set>\n\nusing namespace tbricks;\n\nenum class PreferencesStorageKind\n{\n    Common = 0,\n    Wing,\n    CCS,\n    SVI,\n    MyCustom = 100000\n};\n\nstd::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind);\n\n\/**\n * Struct representing the various settings common to all VMs; it is subclassed by structs\n * containing additional parameters relevant for particular VMs\n *\/\nclass PreferencesStorage: public Printable\n{\npublic:\n    PreferencesStorage();\n\nprotected:\n    PreferencesStorage(const PreferencesStorage & storage) = default;\n    PreferencesStorage & operator=(const PreferencesStorage & storage) = default;\n\npublic:\n    virtual ~PreferencesStorage();\n\n    virtual PreferencesStorageKind GetKind() const = 0;\n\n    virtual void Clear();\n    virtual void Copy(const PreferencesStorage & preferencesStorage);\n\n    virtual bool FillFromTreeNodeParameters(const TreeNodeParameters & parameters);\n    virtual bool FillFromStrategyParameters(const StrategyParameters & parameters);\n    virtual bool FillFromStrategyInstanceParameters(const StrategyInstanceParameters & parameters);\n\n    virtual bool GetParameter(const TreeNodeParameterDefinition & def, AnyType & value) const;\n    virtual bool GetParameter(const ParameterDefinition & def, AnyType & value) const;\n\n    virtual void GetParameters(TreeNodeParameters & parameters) const;\n    virtual void GetParameters(StrategyParameters & parameters) const;\n    virtual void GetParameters(StrategyInstanceParameters & parameters) const;\n\n    virtual bool GetNonDefaultParameter(const TreeNodeParameterDefinition & def, AnyType & value) const;\n    virtual bool GetNonDefaultParameter(const ParameterDefinition & def, AnyType & value) const;\n\n    virtual void GetNonDefaultParameters(TreeNodeParameters & parameters) const;\n    virtual void GetNonDefaultParameters(StrategyParameters & parameters) const;\n    virtual void GetNonDefaultParameters(StrategyInstanceParameters & parameters) const;\n\n    virtual bool Merge(const PreferencesStorage & preferencesStorage);\n\n    virtual std::ostream & Print(std::ostream & strm) const override;\n\n    virtual const std::set<TreeNodeParameterDefinition> & GetLevelAnchoredParameters() const { return m_scopeLevelAnchoredPreferences; }\n\n<fim-suffix><fim-middle>    static const CalculatedPropertyFilter dummyFilter;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in);<fim-suffix><fim-middle>} template <>"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionRetriever : public tbricks::PositionStream::IHandler<fim-suffix>class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId); void Stop(); \/\/ Common Stream methods void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final; void HandleStreamStale(const tbricks::StreamIdentifier &stream)<fim-middle>{ public:"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest &<fim-suffix><fim-middle>request) override;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { Price emptyPrice; Volume emptyVolume {0}; iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); deribit::ticker_update update(value); \/\/ Handle the trading phase if (update.IsOpen()) { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed); } else { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed); } \/\/ BBO bbo.SetAskPrice(update.GetAsk()); bbo.SetBidPrice(update.GetBid()); bbo.SetAskVolume(update.GetAskVolume()); bbo.SetBidVolume(update.GetBidVolume()); auto millis = update.GetTimestamp(); DateTime timestamp = DateTime::Now(); if (millis > 0) { timestamp = DateTime::Create(millis \/ 1000); } bbo.SetExchangeModifiedDatetime(timestamp); \/\/ Statistics stats.SetLastPrice(update.GetLastPrice()); stats.SetOpenInterest(update.GetOpenInterest()); stats.SetDailySettlementPrice(update.GetSettlementPrice()); stats.SetHighPrice(update.GetMaxPrice()); stats.SetLowPrice(update.GetMinPrice()); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail() { InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::SendSnapshotDoneIfNeeded() { TBDEBUG(__func__); if (TB_UNLIKELY(!m_snapshotDone)) { m_mdItem.SendSnapshotDone();<fim-suffix><fim-middle>m_snapshotDone = true;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin2 : public tbricks::Pricing { public: ExampleCalcAppPlugin2(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; bool HandlePartialPricingModifyRequest(const tbricks::CalculatedValuesRequestUpdate &update) override; private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override {}; void HandleRunRequest() override {}; void HandlePauseRequest() override {}; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override {}; void HandleValidateRequest(tbricks::ValidationContext &context) override {}; void Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request); void Calculate(const tbricks::Uuid& rowId, const<fim-suffix>RequestAndIVIDs m_rows; };<fim-middle>tbricks::Uuid& columnId, const tbricks::Double& x);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; private: void<fim-suffix>\/\/ app parameters<fim-middle>FailWithReason(const tbricks::String & reason);"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n<fim-suffix><fim-middle>    std::vector<std::string> reqChannels;"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include \"shared\/app\/app.h\"\nCLANG_RESTORE_WARNINGS\n\n#include <limits>\n\nusing namespace tbricks;\n\nclass ValuesRequest;\n\nstruct ImpliedValue\n{\n    void Clear();\n\n    friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value)\n    { return value.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    Double implied_volatility;\n};\n\nstruct FairPriceValue\n{\n    FairPriceValue & operator += (const FairPriceValue & fair_price_value);\n    FairPriceValue & operator += (const Double & value);\n    FairPriceValue   operator *  (const Double & mult) const;\n    FairPriceValue & operator *= (const Double & mult);\n\n    void Clear();\n\n    bool SetError(const String & error);\n\n    friend std::ostream & operator << (std::ostream & strm, const FairPriceValue & price)\n    { return price.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    Double fair_price;\n};\n\nstruct Greeks\n{\n    Greeks & operator += (const Greeks & greeks);\n    Greeks   operator  * (const Double & mult) const;\n    Greeks & operator *= (const Double & mult);\n\n    void Clear();\n    void ClearNoncombinationValues();\n\n    void Set(const Greeks & greeks);\n\n    bool SetError(const String & error);\n\n    void SetErrorToCCSVolatilityModelGreeks(const String & error);\n    void SetErrorToWingVolatilityModelGreeks(const String & error);\n    void SetErrorToMyCustomVolatilityModelGreeks(const String & error);\n\n    void ZeroFill();\n\n    friend std::ostream & operator << (std::ostream & strm, const Greeks & greeks)\n    { return greeks.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    Double forward_price;\n    Double quanto_forward_price;\n    Double spot_price;\n    Double strike_price;\n    Double delta;\n    Double gamma;\n    Double option_equivalent_gamma;\n    Double vega;\n    Double option_equivalent_vega;\n    Double rho;\n    Double rho_discounting;\n    Double vanna;\n    Double vomma;\n    Double skew_delta;\n    Double skew_gamma;\n    Double calendar_theta;\n    Double volatility_theta;\n    Double rate_theta;\n    Double calendar_charm;\n    Double calendar_skew_charm;\n    Double calendar_color;\n    Double opening_theta;\n    Double opening_charm;\n    Double opening_skew_charm;\n    Double opening_color;\n    Double overnight_theta;\n    Double overnight_charm;\n    Double overnight_skew_charm;\n    Double overnight_color;\n    Double divit;\n    Double speed;\n    Double skew_speed;\n    Double zomma;\n    Double volatility;\n    Double at_the_money_volatility;\n    Double at_the_money_straddle_price;\n    Double straddle_price;\n    Boolean exercise_boundary_reached;\n    Boolean exercise_boundary_div_reached;\n    Integer moneyness;\n    Double simple_put_moneyness;\n    Double wing_slope_sensitivity;\n    Double wing_call_curvature_sensitivity;\n    Double wing_put_curvature_sensitivity;\n    Double ccs_left_slope_sensitivity;\n    Double ccs_right_slope_sensitivity;\n    Double asian_average_fix;\n    Double delta_ytm;\n    Double gamma_ytm;\n    Double fair_ytm;\n    Double implicit_atm_forward;\n    Double implicit_atm_volatility;\n    Double implicit_wing_atm_slope;\n    Double equity_leg_override_price;\n    Double yield;\n    Double synthetic_yield;\n    Double dividend_equivalent_yield;\n    Double tenor_rate_sensitivity;\n    Double bond_duration;\n    Double bond_dv01;\n    Double cash_delta_base;\n    Double cash_gamma_base;\n    Double cash_vega_base;\n    Double param_1;\n    Double param_2;\n};\n\nstruct GreeksCompact\n{\n    enum class Items {\n        forward_price = 0,\n        spot_price,\n        delta,\n        gamma,\n        option_equivalent_gamma,\n        vega,\n        option_equivalent_vega,\n        rho,\n        rho_discounting,\n        vanna,\n        vomma,\n        skew_delta,\n        skew_gamma,\n        calendar_theta,\n        volatility_theta,\n        rate_theta,\n        calendar_charm,\n        calendar_skew_charm,\n        calendar_color,\n        opening_theta,\n        opening_charm,\n        opening_skew_charm,\n        opening_color,\n        overnight_theta,\n        overnight_charm,\n        overnight_skew_charm,\n        overnight_color,\n        divit,\n        speed,\n        skew_speed,\n        zomma,\n        volatility,\n        at_the_money_volatility,\n        at_the_money_straddle_price,\n        straddle_price,\n        wing_slope_sensitivity,\n        wing_call_curvature_sensitivity,\n        wing_put_curvature_sensitivity,\n        ccs_left_slope_sensitivity,\n        ccs_right_slope_sensitivity,\n        asian_average_fix,\n        delta_ytm,\n        gamma_ytm,\n        fair_ytm,\n        implicit_atm_forward,\n        implicit_atm_volatility,\n        implicit_wing_atm_slope,\n        equity_leg_override_price,\n        quanto_forward_price,\n        strike_price,\n        yield,\n        synthetic_yield,\n        dividend_equivalent_yield,\n        tenor_rate_sensitivity,\n        bond_duration,\n        bond_dv01,\n        cash_delta_base,\n        cash_gamma_base,\n        cash_vega_base,\n        param_1,\n        param_2\n    };\n\n    void Clear();\n\n    void Decode(const ValuesRequest & request, Greeks & greeks) const;\n    void Encode(const ValuesRequest & request, const Greeks & greeks);\n\n    friend std::ostream & operator << (std::ostream & strm, Items & item);\n    friend std::ostream & operator << (std::ostream & strm, const GreeksCompact & greeks)\n    { return greeks.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    typedef std::pair<short, Double> GreekValue;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    std::vector<GreekValue> values;\n    Boolean exercise_boundary_reached;\n    Boolean exercise_boundary_div_reached;\n    Integer moneyness;\n    Double simple_put_moneyness;\n};\n<fim-suffix><fim-middle>struct UnderlyingPriceIndependentGreeks\n{\n    UnderlyingPriceIndependentGreeks()\n    {}"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType) { return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType)); } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs; #undef VOLATILITY_MODEL_WRAP } } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilitySurfaceParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs;<fim-suffix>}<fim-middle>#undef VOLATILITY_MODEL_WRAP }"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler, visualization::Grid& instrumentsGrid)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n    , m_tasksDone(false)\n    , m_instrumentsGrid(instrumentsGrid)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n    m_tasksDone = false;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::OpenCIVStream()\n{\n    CalculatedInstrumentValues::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrumentVenueIdentification(InstrumentVenueIdentification(instId));\n    }\n    options.AddValue(calculated_values::UnderlyingPrice());\n\n    auto throttle = MaximumUpdateTimeThrottle(Duration::Seconds(5));\n    options.SetThrottle(throttle);\n    m_calculatedValuesStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened calculated instrument values stream : \" << m_calculatedValuesStream.GetIdentifier() << \" with options : \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n        OpenCIVStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrument.GetIdentifier());\n    TBDUMP(instrument);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char<fim-suffix>{ ostm.write(&val, sizeof(char));<fim-middle>val)"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n<fim-suffix><fim-middle>        {\n            if (method.second == m)\n            {\n                return method.first;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n\npublic_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n{\n}\n<fim-suffix><fim-middle>heartbeat::heartbeat(JsonReply && base)\n    : JsonReply(std::move(base))\n    , type {Pointer(\"\/params\/type\").Get(msg)->GetString()}\n{"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h>\n#include <shared\/volatility\/ClampedCubicSpline.h>\n#include <shared\/volatility\/StochasticVolatilityInspired.h>\n#include <shared\/volatility\/WingVolatilityModel.h>\n\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypeRef>\nModelTypeRef vol_model_cast(volatility::IVolatilityModel & model);\n\ntemplate <class ModelTypeRef>\nModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model);\n\n#define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\\n    template <> \\\n    inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\\n    { \\\n        if (TB_UNLIKELY(!pModel)) { \\\n            return nullptr; \\\n        } \\\n        \\\n<fim-suffix><fim-middle>        if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\\n            TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\\n            throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\\n        } \\"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp<fim-suffix><fim-middle>: public tbricks::MarketDataProvider"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n<fim-suffix><fim-middle>    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n<fim-suffix><fim-middle>PersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\" #include <third_party\/include\/rapidjson\/pointer.h> #include <algorithm> #define SET_STRING_VIEW(key, string) \\ auto & params = msg[\"params\"]; \\ Value v; \\ v.SetString(string.data(), string.size(), msg.GetAllocator()); \\ params.AddMember(#key, v, msg.GetAllocator()); #define SET_INTEGER(key, number) \\ auto & params = msg[\"params\"]; \\ Value v; \\ v.SetInt(number); \\ params.AddMember(#key, v, msg.GetAllocator()); namespace deribit { using namespace rapidjson; Json::Json() { msg.SetObject(); auto & allocator = msg.GetAllocator(); Value v; v.SetString(\"2.0\"); msg.AddMember(\"jsonrpc\", v, allocator); } Json::Json(Json && o) : msg(std::move(o.msg)) { } std::string_view Json::ToString() { buffer.Clear(); Writer<StringBuffer> writer(buffer); msg.Accept(writer); return {buffer.GetString()}; } std::string_view Json::GetId() { assert(msg[\"id\"].IsString()); return {msg[\"id\"].GetString()}; } void Json::Parse(std::string_view str) { msg.Clear(); StringStream s(str.data()); msg.ParseStream(s); } DeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods) { Parse(str); if (msg.HasMember(\"method\")) { std::string_view m(msg[\"method\"].GetString()); for (auto & method : methods) { if (method.second == m) { return method.first; } } } return DeribitMethod::NONE; } JsonCall::JsonCall(const std::string_view id, DeribitMethod method) : Json() { auto & allocator = msg.GetAllocator(); Value v; v.SetString(id.data(), id.size(), msg.GetAllocator()); msg.AddMember(\"id\", v, allocator); auto m = Resolve(method); v.SetString(m.data(), m.size(), msg.GetAllocator()); msg.AddMember(\"method\", v, allocator); v.Clear(); v.SetObject(); msg.AddMember(\"params\", v, allocator); } JsonReply::JsonReply(std::string_view json) : Json() { msg.Clear(); Parse(json); if (msg.HasMember(\"error\")) { isError = true; auto errp = Pointer(\"\/error\").Get(msg); if (errp->HasMember(\"code\")) { err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt(); } if (errp->HasMember(\"message\")) { err.message = Pointer(\"\/error\/message\").Get(msg)->GetString(); } if (errp->HasMember(\"data\")) { err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject()); } } auto test = msg.FindMember(\"testnet\"); if (test != msg.MemberEnd()) { isTest = test->value.GetBool(); } } JsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods) : JsonReply(json) { if (msg.HasMember(\"method\")) { std::string_view m(msg[\"method\"].GetString()); for (auto & method : methods) { if (method.second == m) { jrpcMethod = method.first; break; } } } } JsonReply::JsonReply(JsonReply && o) : Json(std::move(o)) , err(std::move(o.err)) , isTest(o.isTest) , isError(o.isError) , jrpcMethod(o.jrpcMethod) { } bool JsonReply::IsError() const { return isError; } const JsonReply::Error & JsonReply::GetError() const { return err; } bool JsonReply::IsTest() const { return isTest; } const Value & JsonReply::GetResult() { return msg.FindMember(\"result\")->value; } std::string_view JsonReply::GetResultString() { Writer<StringBuffer> writer(buffer); msg[\"result\"].Accept(writer); return {buffer.GetString()}; } const DeribitMethod JsonReply::GetMethod() const { return jrpcMethod; } public_auth::public_auth(const std::string_view id) : JsonCall(id, DeribitMethod::PUBLIC_Auth) { } void public_auth::SetGrantType(public_auth::GrantType type) { auto & params = msg[\"params\"]; Value v; switch (type) { case GrantType::CLIENT_CREDENTIALS: v.SetString(\"client_credentials\"); break; case GrantType::CLIENT_SIGNATURE: v.SetString(\"client_signature\"); break; case GrantType::REFRESH_TOKEN: v.SetString(\"refresh_token\"); break; default: break; } params.AddMember(\"grant_type\", v, msg.GetAllocator()); } void public_auth::SetClientId(const std::string_view val) { SET_STRING_VIEW(client_id, val); } void public_auth::SetClientSecret(const std::string_view val) { SET_STRING_VIEW(client_secret, val); } void public_auth::SetRefreshToken(const std::string_view val) { SET_STRING_VIEW(refresh_token, val); } public_set_heartbeat::public_set_heartbeat(const std::string_view id) : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat) { }<fim-suffix><fim-middle>void public_set_heartbeat::SetInterval(int seconds) {"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override;<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) {<fim-suffix><fim-middle>switch (e)"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin2 : public tbricks::Pricing { public: ExampleCalcAppPlugin2(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; bool HandlePartialPricingModifyRequest(const<fim-suffix>using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override {}; void HandleRunRequest() override {}; void HandlePauseRequest() override {}; void HandleModifyRequest(const<fim-middle>tbricks::CalculatedValuesRequestUpdate &update) override; private:"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_importOnce(false)\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n<fim-suffix><fim-middle>    context.SendReply();\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/EventProcessor.h>\n#include <future>\n\nnamespace misc {\n\nclass AsyncProcessor\n{\nprivate:\n    const tbricks::EventProcessor& m_proc;\n    tbricks::StrategyIdentifier m_id;\n    std::string m_result;\n\npublic:\n<fim-suffix><fim-middle>    AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc), m_id(appId) {};"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string><fim-suffix>{ return { {DeribitMethod::SUBSCRIPTION,<fim-middle>Method; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods()"}
{"content":"<fim-prefix>#pragma once\n\n#include \"shared\/API.h\"\n#include \"execution\/IExecutionHandler.h\"\n\nclass PositionsData;\n\nnamespace execution {\nclass OrderExecutor;\n}\n\nnamespace misc {\nclass AsyncProcessor;\n}\nclass GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler\n{\npublic:\n    GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\nprotected:\n    void HandleDeleteRequest() override;\n    void HandleRunRequest() override;\n    void HandlePauseRequest() override;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override;\n    void HandleValidateRequest(tbricks::ValidationContext &context) override;\n\n    void HandleScheduledEvent(tbricks::UserData&& data) override;\n\n    void PanicStop(const tbricks::String& msg) override;\n    void AllDone(const execution::Stats& stats) override;\n\nprivate:\n    tbricks::PortfolioIdentifierParameter m_portfolio;\n    tbricks::StringParameter m_statusText;\n\n    std::unique_ptr<PositionsData> m_positions;\n    std::unique_ptr<execution::OrderExecutor> m_orders;\n<fim-suffix><fim-middle>    tbricks::EventProcessor m_proc;\n    std::unique_ptr<misc::AsyncProcessor> m_async;"}
{"content":"<fim-prefix>#include \"..\/..\/my_custom_pricing\/tbricks_definitions.h\" constexpr VolatilityModel VolatilityModelMyCustom<fim-suffix><fim-middle>= VolatilityModel(custom::pricing::extended_enums::VolatilityModelMyCustom); #endif \/\/ TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n<fim-suffix><fim-middle>    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\" #include \"PositionsData.h\" #include \"tbricks_definitions.h\" #include \"execution\/TbOrderManager.h\" #include \"execution\/TbOrderMinion.h\" #include \"execution\/TbChildOrder.h\" #include <AsyncTask.h> #include <memory> using namespace tbricks; namespace sp = go_flat::strategy_parameters; GoFlatPlugin::GoFlatPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_portfolio(sp::Portfolio()) , m_statusText(sp::PlugInStatusDescription()) , m_executorType(execution::OrderExecutorType::ORDER_MANAGER) { TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered()); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); switch (m_executorType) { case execution::OrderExecutorType::ORDER_MANAGER: m_orders = std::make_unique<execution::TbOrderManager>(*this); break; case execution::OrderExecutorType::CHILD_ORDER: m_orders = std::make_unique<execution::TbChildOrder>(*this, *this); break; case execution::OrderExecutorType::ORDER_MINION: m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters); break; } m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier()); } void GoFlatPlugin::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); \/\/m_async->DoAsync(); \/\/ UNCOMMENT if you want to fire minion orders after the async task if (not m_positions or m_positions->GetData().empty()) { SetTransactionFail(\"No positions\", StrategyState::PAUSED); return; } if (m_orders) { if (not m_positions->GetData().empty()) { for (const auto& [ivid, pos] : m_positions->GetData()) { if (m_executorType == execution::OrderExecutorType::ORDER_MINION) { execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get()); minion->MonitorInstrument(ivid); \/\/continue; \/\/ UNCOMMENT if you want to fire minion orders after the async task } TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos); if (not pos.Empty() and pos != 0.0) { \/\/ we want to flatten the position so invert the volume m_orders->CreateOrder(ivid, -pos, m_portfolio.GetPortfolioIdentifier()); } } \/\/ we don't want more position updates from now m_positions->Stop(); SetState(StrategyState::RUNNING); return; } } SetState(StrategyState::PAUSED); } void GoFlatPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if<fim-suffix><fim-middle>(m_orders) { m_orders->DeleteOrders();"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n<fim-suffix><fim-middle>{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\";<fim-suffix>return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string><fim-middle>case DeribitKind::FUTURE:"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\""}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public<fim-suffix>{ public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem &<fim-middle>tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewUpdate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    auto it = update.begin();\n    while (it != update.end())\n    {\n        TBDUMP(it.GetCell().GetCalculatedProperty() << \" \" << it.GetCell().GetCellValue());\n\n        auto & calcProp = it.GetCell().GetCalculatedProperty().GetDefinition();\n        auto & cellValue = it.GetCell().GetCellValue();\n\n        if (calcProp == instrument_enricher::calculated_properties::strategy::ImportFrequency())\n        {\n            m_importFrequency = cellValue.GetDuration();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::InstrumentGroup())\n        {\n            m_instrumentGroup = cellValue.GetInstrumentGroupIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::UnderlyingInstrument())\n        {\n            m_underlyingInstrument = cellValue.GetInstrumentIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::StartTime())\n        {\n            m_startTime = cellValue.GetDateTime();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::MaturityDate())\n        {\n            m_maturityDate = cellValue.GetDateTime();\n        }\n\n        ++it;\n    }\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       m_importOnce = true;\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_instrumentsGrid.RemoveAllRows();\n        m_plugInStatusDescription.Clear();\n        m_timerController.Start();\n    }\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::Stop()\n{\n    TBDEBUG(__func__);\n\n    if (m_timerController.IsActive())\n    {\n        m_timerController.Stop();\n    }\n    m_instrumentManager.Stop();\n    m_importOnce = false;\n\n    if (GetState().IsPaused())\n<fim-suffix><fim-middle>    {\n        TBDEBUG(\"Already stopped\");\n        return;\n    }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override;<fim-suffix>void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument); \/\/ app parameters tbricks::StringParameter<fim-middle>void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override;"}
{"content":"<fim-prefix>#pragma once<fim-suffix><fim-middle>#include \"shared\/API.h\" class ExampleCalcAppPlugin2 : public tbricks::Pricing"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewUpdate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    auto it = update.begin();\n    while (it != update.end())\n    {\n        TBDUMP(it.GetCell().GetCalculatedProperty() << \" \" << it.GetCell().GetCellValue());\n\n        auto & calcProp = it.GetCell().GetCalculatedProperty().GetDefinition();\n        auto & cellValue = it.GetCell().GetCellValue();\n\n        if (calcProp == instrument_enricher::calculated_properties::strategy::ImportFrequency())\n        {\n            m_importFrequency = cellValue.GetDuration();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::InstrumentGroup())\n        {\n            m_instrumentGroup = cellValue.GetInstrumentGroupIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::UnderlyingInstrument())\n        {\n            m_underlyingInstrument = cellValue.GetInstrumentIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::StartTime())\n        {\n            m_startTime = cellValue.GetDateTime();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::MaturityDate())\n        {\n            m_maturityDate = cellValue.GetDateTime();\n        }\n\n        ++it;\n    }\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n<fim-suffix><fim-middle>    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t<fim-suffix>{ return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define<fim-middle>!= msg.MemberEnd())"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem<fim-suffix>void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void<fim-middle>& item) override;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n<fim-suffix><fim-middle>using namespace tbricks;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp()<fim-suffix>auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto&<fim-middle>{ auto& msg = m_doc->msg;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n\npublic_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n{\n}\n\nheartbeat::heartbeat(JsonReply && base)\n    : JsonReply(std::move(base))\n    , type {Pointer(\"\/params\/type\").Get(msg)->GetString()}\n{\n}\n\nstd::string_view heartbeat::GetType() const\n{\n    return type;\n}\n\nbool heartbeat::IsTestRequest() const\n<fim-suffix><fim-middle>{\n    return type == \"test_request\" ? true : false;\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n    Binary_ostream() { }\n    void close()\n    {\n        m_data.Clear();\n    }\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n    template <typename T>\n    void write(const T & t)\n    {\n        tbricks::Binary vec;\n        vec.Set(reinterpret_cast<const void *>(&t), sizeof(T));\n        write(vec);\n    }\n    void write(const std::string & s)\n    {\n        write(s.c_str(), s.size());\n    }\n    void write(const char * p, size_t size)\n    {\n        m_data.Append(p, size);\n    }\n\nprivate:\n    tbricks::Binary m_data;\n};\n\ntemplate <typename T>\nBinary_istream & operator>>(Binary_istream & istm, T & val)\n{\n    istm.read(val);\n<fim-suffix><fim-middle>    return istm;\n}"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n\nUpdateData::~UpdateData()\n{\n    delete(m_doc);\n}\n\nstd::string_view UpdateData::ToString()\n{\n    m_doc->buffer.Clear();\n    Writer<StringBuffer> writer(m_doc->buffer);\n    m_doc->msg.Accept(writer);\n    return {m_doc->buffer.GetString()};\n}\n\nvoid UpdateData::Parse(const tbricks::String& str)\n{\n    m_doc->msg.Clear();\n    StringStream s(str.GetCString());\n    m_doc->msg.ParseStream(s);\n}\n\nticker_update::ticker_update(const tbricks::String& str)\n: UpdateData()\n{\n    Parse(str);\n}\n\nstd::string_view ticker_update::GetInstrumentName()\n{\n    auto& msg = m_doc->msg;\n    auto i = msg.FindMember(\"instrument_name\");\n    if (i != msg.MemberEnd())\n    {\n        return i->value.GetString();\n    }\n    return {};\n}\n<fim-suffix><fim-middle>int64_t ticker_update::GetTimestamp()\n{\n    auto& msg = m_doc->msg;\n    auto t = msg.FindMember(\"timestamp\");"}
{"content":"<fim-prefix>#include \"TimerController.h\"\n#include \"tbricks_definitions.h\"\n<fim-suffix><fim-middle>using namespace tbricks;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters&<fim-suffix>void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); } const tbricks::DateTime& GetTimerLastFired() const { return m_timerLastFired; } private: IHandler& m_handler; tbricks::Timer m_startTimerEvent; tbricks::DateTime m_startTime; tbricks::Duration m_frequency; tbricks::DateTime m_timerLastFired;<fim-middle>strategyParameters); void Start();"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\" class PositionsData; namespace execution { class OrderExecutor; } namespace misc { class AsyncProcessor; } class<fim-suffix>{ public: GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ Strategy methods void HandleDeleteRequest() override; void HandleRunRequest() override; void HandlePauseRequest() override;<fim-middle>GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n<fim-suffix><fim-middle>    {\n        return m_index;\n    }\n    bool seekg(size_t pos)"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n<fim-suffix><fim-middle>public_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) {<fim-suffix>void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update);<fim-middle>"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n<fim-suffix><fim-middle>using namespace rapidjson;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const<fim-suffix>return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char *<fim-middle>char * get_internal_data() {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <optional> struct DeribitInstrument { tbricks::String instrument_name; tbricks::String instrument_type; tbricks::String kind; tbricks::String settlement_currency; tbricks::String settlement_period; tbricks::String quote_currency; tbricks::String counter_currency; tbricks::String option_type; \/\/ \"call\" or \"put\" for options std::optional<tbricks::Double> strike; \/\/ Only for options tbricks::DateTime expiration_timestamp; tbricks::Double tick_size; tbricks::Double contract_size; tbricks::Boolean is_active; \/\/ Constructor that safely extracts<fim-suffix>DeribitInstrument data; \/\/ Required fields - if any of these are missing, return nullopt if (!value.HasMember(\"instrument_name\") || !value[\"instrument_name\"].IsString() || !value.HasMember(\"kind\") || !value[\"kind\"].IsString() || !value.HasMember(\"settlement_currency\") || !value[\"settlement_currency\"].IsString() || !value.HasMember(\"counter_currency\") || !value[\"counter_currency\"].IsString() || !value.HasMember(\"is_active\") || !value[\"is_active\"].IsBool()) { return std::nullopt; } data.instrument_name = value[\"instrument_name\"].GetString(); data.kind = value[\"kind\"].GetString(); data.settlement_currency = value[\"settlement_currency\"].GetString(); data.counter_currency = value[\"counter_currency\"].GetString(); data.is_active =<fim-middle>data from rapidjson Value     static std::optional<DeribitInstrument> FromJson(const rapidjson::Value& value) {"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } Strategy::SetState(StrategyState::RUNNING); return true; }<fim-suffix>{ TBDEBUG(__func__ << \" :<fim-middle>void InstrumentEnricherPlugin::HandleImportComplete(const String& status)"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n<fim-suffix><fim-middle>{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; };<fim-suffix>{ m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state<fim-middle>UpdateData::UpdateData()"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/String.h> #include <strategy\/type\/Volume.h> namespace execution { struct Stats { tbricks::Volume bought; tbricks::Volume sold; tbricks::Double valueBought; tbricks::Double valueSold; }; enum class OrderExecutorType { ORDER_MANAGER, CHILD_ORDER, ORDER_MINION };<fim-suffix>{ public: ~IExecutionHandler() = default; virtual void AllDone(const<fim-middle>class IExecutionHandler"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" #include \"MyCustomVolatilityModel.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return<fim-suffix><fim-middle>nullptr; #undef VOLATILITY_MODEL_WRAP"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public: subscriptions(const std::string_view id, DeribitMethod method); void AddChannel(const std::string & channel); }; class subscriptions_reply<fim-suffix>public: subscriptions_reply(JsonReply && base); std::vector<std::string_view> GetChannels() const; }; class subscription_update : public JsonReply { public: subscription_update(JsonReply && base); std::string_view GetChannel() const; std::string_view GetData(); private: rapidjson::StringBuffer dataBuffer; }; class public_get_instruments : public JsonCall { public: public_get_instruments(const std::string_view id); void SetCurrency(DeribitCurrency ccy); void SetKind(DeribitKind kind); void SetExpired(bool expired = false); };<fim-middle>: public JsonReply {"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n<fim-suffix><fim-middle>    {\n        isTest = test->value.GetBool();\n    }\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n\nprotected:\n    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;\n    void HandleStreamClose(tbricks::TCPStream & stream) final;\n\n    void UpgradeWs();\n\nprivate:\n    std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept;\n\n    void ParseHttpReply(const tbricks::Binary & data);\n    std::size_t ReadWsReply(std::istream & data);\n    void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length);\n\nprivate:\n    IWebsocketHandler & m_handler;\n    tbricks::TCPStream m_tcp;\n    std::random_device m_rd;\n    std::shared_ptr<std::string> nonce_base64;\n<fim-suffix><fim-middle>    Config m_config;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>DeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>();<fim-suffix><fim-middle>case VolatilityModelSVI: return std::make_unique<SVIPreferencesStorage>();"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\" #include \"shared\/order_minion\/OrderMinionCancelRequest.h\" #include \"shared\/order_minion\/tbricks_definitions.h\" #include \"shared\/sdk_definitions.h\" using namespace tbricks; namespace execution { TbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters) : OrderExecutor(handler) , m_controller( reason, app) { TBDEBUG(__func__); } TbOrderMinion::~TbOrderMinion() { TBDEBUG(__func__); DeleteOrders(); } void TbOrderMinion::CreateOrder( const InstrumentVenueIdentification& ivid, const Volume& volume, \/\/ negative for sell const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio); OrderMinionRequest req(this); req.SetExecution(enumerations::OrderMinionExecutionHitRepeatedly); req.SetIVID(ivid); req.SetMarketDataIVID(ivid); req.SetPortfolio(portfolio); req.SetSide((volume > 0.0 ? Side::BUY : Side::SELL)); req.SetVolume(volume.Abs()); req.SetPriceMode(enumerations::OrderMinionPrice::OrderMinionPriceBestPossible); auto result = m_controller.Request(req); if (result == OrderMinionController::FAILURE) { m_handler.PanicStop(result.GetError()); return; } m_requests[ivid] = req; } void TbOrderMinion::DeleteOrders() { TBDEBUG(__func__); m_controller.Stop(); } void TbOrderMinion::MonitorInstrument(const InstrumentVenueIdentification &ivid) { m_controller.Prepare(ivid); } void TbOrderMinion::HandleOrderMinionUpdate( const OrderMinionUpdate& update ) { TBDEBUG(__func__ << \" : \" << update); if (update.DidFail()) { m_handler.PanicStop(update.GetError()); } else if (update.IsFinished()) { const auto& reqId = update.GetRequestID(); auto it = std::find_if(m_requests.begin(), m_requests.end(), [&reqId](const auto& req){ return req.second.GetRequestID() == reqId; }); if (it == m_requests.end()) { TBWARNING(\"Received update for unknown request\"); return; } TBDEBUG(\"Completed order for \" << it->second.GetIVID()); UpdateStats(update, it->second); m_requests.erase(it); } if (m_requests.empty()) { m_handler.AllDone(m_stats); } } void TbOrderMinion::UpdateStats(const OrderMinionUpdate& update, const OrderMinionRequest& request) { if (request.GetSide().IsBuy()) { m_stats.bought += update.GetFilledVolume(); m_stats.valueBought += (update.GetFilledVolume() * update.GetAveragePaid()); } else { m_stats.sold += update.GetFilledVolume(); m_stats.valueSold += (update.GetFilledVolume() * update.GetAveragePaid()); } } } \/\/<fim-suffix><fim-middle>namespace execution"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } namespace deribit { using Method = std::pair<DeribitMethod, std::string>; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods()<fim-suffix>{DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)}, {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)}, {DeribitMethod::PUBLIC_SetHeartbeat,<fim-middle>{ return {"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\""}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n<fim-suffix><fim-middle>    m_mdItem.Flush();\n}"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; }<fim-suffix><fim-middle>Binary_ostream & operator<<(Binary_ostream & ostm, const char * val)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason)<fim-suffix><fim-middle>= 0;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n<fim-suffix><fim-middle>class heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \", item = \" << item);\n}"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); } const tbricks::DateTime& GetTimerLastFired() const { return m_timerLastFired; } private: IHandler& m_handler; tbricks::Timer m_startTimerEvent; tbricks::DateTime<fim-suffix><fim-middle>m_startTime; tbricks::Duration m_frequency; tbricks::DateTime m_timerLastFired;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String<fim-suffix><fim-middle>& reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument);"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from,<fim-suffix><fim-middle>const PreferencesStorageKind to)"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n<fim-suffix><fim-middle>    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewUpdate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    auto it = update.begin();\n    while (it != update.end())\n    {\n        TBDUMP(it.GetCell().GetCalculatedProperty() << \" \" << it.GetCell().GetCellValue());\n\n        auto & calcProp = it.GetCell().GetCalculatedProperty().GetDefinition();\n        auto & cellValue = it.GetCell().GetCellValue();\n\n        if (calcProp == instrument_enricher::calculated_properties::strategy::ImportFrequency())\n        {\n            m_importFrequency = cellValue.GetDuration();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::InstrumentGroup())\n        {\n            m_instrumentGroup = cellValue.GetInstrumentGroupIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::UnderlyingInstrument())\n        {\n            m_underlyingInstrument = cellValue.GetInstrumentIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::StartTime())\n        {\n            m_startTime = cellValue.GetDateTime();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::MaturityDate())\n        {\n            m_maturityDate = cellValue.GetDateTime();\n        }\n\n        ++it;\n    }\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       m_importOnce = true;\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_instrumentsGrid.RemoveAllRows();\n        m_plugInStatusDescription.Clear();\n        m_timerController.Start();\n    }\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::Stop()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status); ~PositionsData(); void Stop(); public: using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>; const Data& GetData() const { return m_data; } protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream)<fim-suffix>private: void RefreshStatusText(); private: tbricks::StringParameter& m_appStatus; tbricks::CalculatedPropertiesTable m_table; tbricks::CalculatedPropertiesTable::Stream m_stream;<fim-middle>final; \/\/ CalculatedPropertiesTable::Stream::IHandler     void HandleCalculatedProperties(const tbricks::StreamIdentifier & stream_id, const tbricks::CalculatedPropertiesTable::Update & update) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"shared\/API.h\"\n\nclass ExampleCalcAppPlugin2 : public tbricks::Pricing\n{\npublic:\n\n    ExampleCalcAppPlugin2(const tbricks::PricingRequest & request);\n    void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override;\n    bool HandlePartialPricingModifyRequest(const tbricks::CalculatedValuesRequestUpdate &update) override;\n\nprivate:\n<fim-suffix><fim-middle>    using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0;<fim-suffix>const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4;<fim-middle>const double VM_DEFAULT_VOLATILITY_TIME = 1.0;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues<fim-suffix><fim-middle>Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n<fim-suffix><fim-middle>{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindPreferencesStorageByScopeDefinition(const ScopeDefinition & scope) const\n{\n    switch (scope.type)\n    {\n    case enumerations::VolatilityManagerPersistentPreferencesScopeUser:\n        return (scope.id == m_provider.GetUserIdentifier().GetUuid()) ? m_pUserScopePreferencesStorage.get() : nullptr;\n    case enumerations::VolatilityManagerPersistentPreferencesScopeProduct:\n        return FindProductScopePreferencesStorage(scope.id);\n    case enumerations::VolatilityManagerPersistentPreferencesScopeMaturity:\n        return FindMaturityScopePreferencesStorage(scope.id);\n    default:\n        return nullptr;\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductGroupIdsWithExistingPersistentPreferences(SparseSet<InstrumentGroupIdentifier> & productGroupIds) const\n{\n    productGroupIds.clear();\n    productGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & pair: m_productScopePreferencesStorages) {\n        TB_UNUSED(productGroupIds.insert(pair.first));\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductAndMaturityGroupIdsWithExistingPersistentPreferences(SparseHash<InstrumentGroupIdentifier, SparseSet<InstrumentGroupIdentifier>> & productAndMaturityGroupIds) const\n{\n    productAndMaturityGroupIds.clear();\n    productAndMaturityGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & [productGroupId, _]: m_productScopePreferencesStorages) {\n        TB_UNUSED(productAndMaturityGroupIds[productGroupId]);\n    }\n\n    for(const auto & pair: m_maturityScopePreferencesStoragesByProductGroupId) {\n        const InstrumentGroupIdentifier & productGroupId = pair.first;\n        SparseSet<InstrumentGroupIdentifier> & maturityGroupIds = productAndMaturityGroupIds[productGroupId];\n        maturityGroupIds.insert(pair.second.first);\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetMaturityGroupIdsWithExistingPersistentPreferences(const InstrumentGroupIdentifier & productGroupId,\n                                                                                            SparseSet<InstrumentGroupIdentifier> & maturityGroupIds) const\n{\n    if (TB_UNLIKELY(productGroupId.Empty())) {\n        return;\n    }\n\n    const auto [maturitiesBeginIt, maturitiesEndIt] = m_maturityScopePreferencesStoragesByProductGroupId.equal_range(productGroupId);\n    for (auto it = maturitiesBeginIt; it != maturitiesEndIt; it++) {\n        maturityGroupIds.insert(it->second.first);\n    }\n}\n\nbool PersistentPreferencesManagerCore::GetAggregatePreferencesForProductScope(const InstrumentGroupIdentifier & productGroupId,\n                                                                              PreferencesStorage & preferencesStorage) const\n{\n    TBDEBUG(\"PersistentPreferencesManagerCore::GetAggregatePreferencesForProductScope: product group id = \" << productGroupId);\n\n    preferencesStorage.Clear();\n\n    if (m_provider.IsPreferencesPersistenceDisabled())\n    {\n        if (TB_UNLIKELY(!m_pNonPersistentUserScopePreferences)) {\n            NOTIFY_WARNING(\"persistence of preferences is disabled but non-persistent in-memory storage is not allocated\");\n            return false;\n        }\n\n        preferencesStorage.Copy(*m_pNonPersistentUserScopePreferences);\n        return true;\n    }\n\n    preferencesStorage.Copy(*m_pUserScopePreferencesStorage);\n\n    const Integer & currentPreferencesScope = m_provider.GetCurrentPreferencesScope();\n<fim-suffix><fim-middle>    if (!currentPreferencesScope.Empty() && (currentPreferencesScope.GetInt32() == enumerations::VolatilityManagerPersistentPreferencesScopeUser)) {\n        TBDEBUG(\"Ignoring the actual product scope preferences because preferences scope is set to user\");\n        return true;\n    }"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n<fim-suffix><fim-middle>    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetState(StrategyState::RUNNING); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void<fim-suffix><fim-middle>DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest &<fim-suffix><fim-middle>request) override;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin : public tbricks::Pricing { public: ExampleCalcAppPlugin(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override {}; void HandleRunRequest() override {}; void<fim-suffix>void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override {}; void HandleValidateRequest(tbricks::ValidationContext &context) override {}; void Calculate(const RequestAndIVIDs & values,<fim-middle>HandlePauseRequest() override {};"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n        Channel channel; \/\/ should be always sorted\n\n<fim-suffix><fim-middle>        std::ostream & Print(std::ostream & strm) const final;\n    };"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n<fim-suffix><fim-middle>        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE,<fim-suffix>PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe:<fim-middle>PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test,"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats); void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem<fim-suffix><fim-middle>m_mdItem; tbricks::Identifier m_tickerId;"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (m_volatility_model->IsInterpolated()) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group\n    , const InstrumentGroupAggregateParameters::Update & update)\n{\n    return HandleVolatilityGroupParameters(&update);\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group)\n{\n    PDEBUGN(\"Handle volatility group parameters snapshot done\");\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerSnapshot(m_group);\n    }\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType()\n{\n    PDEBUGN(\"VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType\");\n    if (SwitchVolatilityModel()) {\n        for (auto subscriber : m_subscribers) {\n            subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n        }\n    }\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParameters(const InstrumentGroupAggregateParameters::Update * update)\n{\n    PDEBUGN(\"Handle volatility group parameters\");\n    if (update) {\n        PDUMPN(\"Update = \" << *update);\n    }\n\n    bool changed = false;\n\n    changed |= SwitchVolatilityModel();\n    if (!changed && m_volatility_model) {\n        if (update) {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*update, *m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        } else {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        }\n    }\n\n    if (changed) {\n        m_volatility_models.clear();\n    }\n\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n    }\n<fim-suffix><fim-middle>    return changed;\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED);<fim-suffix><fim-middle>} void InstrumentEnricherPlugin::HandleDeleteRequest() {"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n<fim-suffix><fim-middle>        return {};\n    }\n}"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType) { return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType)); } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\ return<fim-suffix>} switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs; #undef VOLATILITY_MODEL_WRAP } } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel<fim-middle>defs; \\"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return false; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument<fim-suffix>} }<fim-middle>\" << diagnostics.GetDiagnosticKey();"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n<fim-suffix><fim-middle>void DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n<fim-suffix><fim-middle>    SetState(StrategyState::PAUSED);\n}"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier<fim-middle>"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace<fim-suffix><fim-middle>deribit {"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const<fim-suffix><fim-middle>tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status);"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document<fim-suffix><fim-middle>msg; StringBuffer buffer;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/VisualizationApp.h> #include <strategy\/visualization\/ViewModelUpdate.h> #include <strategy\/visualization\/ICellValue.h> #include <strategy\/visualization\/Grid.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::VisualizationApp , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VisualizationApp methods void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewDelete(tbricks::visualization::models::AppViewModel & viewModel) final { } void HandleGridViewCreate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } void HandleGridViewUpdate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } \/\/ TimerController::IHandler void HandleTimerEventHit() final; void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final; private: bool CheckRunningRequirement(); void HandleAction(const tbricks::Integer<fim-suffix>void Start(); void Stop(); void ImportNow(); \/\/ app parameters tbricks::IntegerParameter m_instrument_enricherAppAction; tbricks::DurationParameter m_importFrequency; tbricks::InstrumentGroupParameter m_instrumentGroup;<fim-middle>& action);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void<fim-suffix>void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request)<fim-middle>HandleValidateRequest(tbricks::ValidationContext & context) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void<fim-suffix><fim-middle>HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update<fim-suffix><fim-middle>& update);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument); private:<fim-middle>tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override;"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id,<fim-suffix>\/\/ MDTracker::IHandler void HandleBBOUpdate( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::BestPrice& before, const tbricks::BestPrice& change ) override; void HandleSnapshotEnd(const tbricks::InstrumentVenueIdentification& ivid) override; private: void EmergencyStop(); void DeleteSingleOrder(const tbricks::OrderIdentifier& id);<fim-middle>tbricks::Status status, const tbricks::String& status_text) override;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;\n    }\n}\n\nvoid InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n    {\n        const int total = m_instrumentCache.size();\n\n        std::stringstream result;\n        result << \"Total instruments = \" << total << \", successful = \" << total - m_failed\n               << \", failed = \" << m_failed;\n\n        m_handler.HandleImportComplete(result.str());\n    }\n}\n\nvoid InstrumentManager::EnrichInstruments()\n{\n    TBDEBUG(__func__);\n\n    for (const auto& [instID, instrument] : m_instrumentCache)\n    {\n        InstrumentModifier instrumentModifier(instID);\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        if (tbMaturityDate != m_handler.GetMaturityDate())\n        {\n            InstrumentAttributes attributes;\n            attributes.SetAttribute(instrument_attributes::MaturityDate(), m_handler.GetMaturityDate());\n            instrumentModifier.SetAttributes(attributes);\n            Instrument::RequestResult result = Instrument::SendModifyRequest(instrumentModifier, *this);\n            m_instrumentModifyRequests.emplace(result.GetRequestIdentifier(), instID);\n        }\n    }\n\n    ModifyGroup();\n    CheckModificationStatus();\n}\n\nvoid InstrumentManager::ModifyGroup()\n{\n    TBDEBUG(__func__);\n\n    InstrumentGroupIdentifier groupID = m_handler.GetInstrumentGroup().GetIdentifier();\n    std::vector<InstrumentParameterDefinition> defs;\n    defs.push_back(instrument_parameters::UnderlyingInstrument());\n\n    InstrumentGroupParameters groupParams(groupID, defs);\n    InstrumentIdentifier underlyingInstrument;\n    groupParams.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingInstrument);\n\n    InstrumentGroupParameters::Modifier modifier;\n    if (underlyingInstrument.Empty())\n    {\n        modifier.SetParameter(instrument_parameters::UnderlyingInstrument(), m_handler.GetUnderlyingInstrument());\n    }\n    else\n    {\n        TBNOTICE(\"Not changing existing underlying instrument for group\");\n    }\n\n    if (not modifier.Empty())\n    {\n        Identifier id = InstrumentGroupParameters::SendModifyRequest(groupID, modifier, *this);\n        m_groupModifyRequests.emplace(id, groupID);\n    }\n}\n<fim-suffix><fim-middle>void InstrumentManager::HandleRequestReply(const Identifier& id, class Status status, const String& status_text)\n{\n    TBDEBUG(__func__ << \" : \" << id);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n<fim-suffix><fim-middle>    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields<fim-suffix><fim-middle>to send when performing WebSocket upgrade.         \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol."}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n<fim-suffix><fim-middle>void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem<fim-suffix><fim-middle>& item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override;"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS)<fim-suffix><fim-middle>VOLATILITY(svi, SVI)"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start<fim-suffix>status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \"<fim-middle>time m_startTimerEvent.Start(m_startTime);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs();<fim-suffix><fim-middle>private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; explicit InstrumentManager(IHandler& handler); ~InstrumentManager(); void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& streamID) final; void HandleStreamStale(const tbricks::StreamIdentifier& streamID) final; void HandleStreamFailed(const tbricks::StreamIdentifier& streamID) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& streamID) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& streamID, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& streamID, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status,<fim-suffix>private: void OpenInstrumentStream(); void OpenIAPStream(); void EnrichInstruments(); void ModifyGroup(); void CheckModificationStatus(); IHandler& m_handler; tbricks::InstrumentStream m_instrumentStream; tbricks::InstrumentAggregateParameters::Stream m_iapStream; InstrumentCache m_instrumentCache; UnderlyingCache m_underlyingCache; int m_failed; std::map<tbricks::Identifier, tbricks::InstrumentGroupIdentifier> m_groupModifyRequests; std::map<tbricks::Identifier, tbricks::InstrumentIdentifier> m_instrumentModifyRequests; };<fim-middle>const tbricks::String& status_text) final;"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice();<fim-suffix>double GetBid(); double GetAsk(); double GetBidVolume(); double GetAskVolume(); }; }<fim-middle>double GetIndexPrice(); double GetCurrentFunding();"}
{"content":"<fim-prefix>#pragma once #include \"IExecutionHandler.h\" #include \"shared\/API.h\" namespace execution { class OrderExecutor { public: virtual ~OrderExecutor() = default; OrderExecutor(IExecutionHandler& handler) : m_handler(handler) { m_stats.bought = 0.0; m_stats.sold = 0.0; m_stats.valueBought = 0.0; m_stats.valueSold = 0.0; } virtual void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio)<fim-suffix>protected: IExecutionHandler& m_handler; Stats<fim-middle>= 0; virtual void DeleteOrders() = 0;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm;<fim-suffix>} Binary_ostream & operator<<(Binary_ostream & ostm, const char val) { ostm.write(&val, sizeof(char)); return<fim-middle>ostm.write(val, size); return ostm;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/test\/TestEngine.h> using namespace tbricks; using namespace tbricks::test; #ifndef TIMEOUT #define TIMEOUT tbricks::Duration::Seconds(5) #endif void Test(TestEngine &te);<fim-suffix>int main(int \/*argc*\/, char * \/*argv*\/[]) { TestEngine te(\"..\/system.xml\", \"..\/engine.xml\"); te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\"); te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString()); te.RunTest(Test, TIMEOUT); return 0; } namespace go_flat { tbricks::VenueIdentifier GetTestVenueId() { return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"}; } tbricks::PortfolioIdentifier GetPortfolioId() { return {\"2eb2249c-bc89-11ee-a950-d946a31b499d\"}; } } \/\/ namespace go_flat #include <filesystem> namespace fs = std::filesystem; tbricks::String get_current_root() { fs::path<fim-middle>tbricks::String get_current_root(); tbricks::String get_apps_relative();"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n<fim-suffix><fim-middle>    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item);<fim-suffix><fim-middle>}"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void<fim-suffix><fim-middle>DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/VisualizationApp.h>\n#include <strategy\/visualization\/ViewModelUpdate.h>\n#include <strategy\/visualization\/ICellValue.h>\n#include <strategy\/visualization\/Grid.h>\n#include \"InstrumentManager.h\"\n#include \"TimerController.h\"\n\nclass InstrumentEnricherPlugin : public tbricks::VisualizationApp\n                               , public InstrumentManager::IHandler\n                               , public TimerController::IHandler\n\n{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n\n    void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel,\n                                  const tbricks::visualization::ViewModelUpdate & update) final;\n    void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel,\n                                  const tbricks::visualization::ViewModelUpdate & update) final;\n    void HandleStrategyViewDelete(tbricks::visualization::models::AppViewModel & viewModel) final { }\n    void HandleGridViewCreate(tbricks::visualization::models::GridViewModel & viewModel,\n                              const tbricks::visualization::ViewModelUpdate & update) final { }\n    void HandleGridViewUpdate(tbricks::visualization::models::GridViewModel & viewModel,\n                              const tbricks::visualization::ViewModelUpdate & update) final { }\n    void HandleImportComplete(const tbricks::String& status) final;\n    void HandleInstrumentManagerFailed(const tbricks::String& reason) final;\n    const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); }\n<fim-suffix><fim-middle>    const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); }\n    const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); }"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction()) , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency()) , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_startTime(instrument_enricher::strategy_parameters::StartTime()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_importOnce(false) , m_instrumentManager(*this) , m_timerController(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { ImportNow(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier) { TBSTATUS(__func__ << \" : \" << modifier); const StrategyParameters& parameters = modifier.GetParameters(); GetParameters().Merge(parameters); MergeAttributes(modifier.GetAttributes()); if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction())) { Integer action; parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action); HandleAction(action); } if (parameters.GetParameter(m_startTime) or parameters.GetParameter(m_importFrequency)) { m_timerController.Update(parameters); } m_instrument_enricherAppAction.Clear(); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.GetItem(m_instrument_enricherAppAction).SetDirection(direction); auto &action_vi = context.GetItem(m_instrument_enricherAppAction); std::vector<Integer> allowed_actions; if (GetState().IsRunning()) { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer); } else { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer); allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow); } action_vi.SetValidValues(allowed_actions); action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT); if (not GetState().IsRunning()) { auto& freqValidationItem = context.GetItem(m_importFrequency); Duration frequency; freqValidationItem.GetValue(frequency); if (not frequency.Empty() and frequency < Duration::Seconds(1)) { freqValidationItem.SetValue(Duration::Seconds(1)); m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\"; } freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT); } context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } return true; } void InstrumentEnricherPlugin::HandleAction(const Integer & action) { TBDEBUG(__func__ << \" : \" << action); if(TB_UNLIKELY(action.Empty())) { TBDEBUG(\"Action is empty, skipping\"); } switch (action.GetInt()) { case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer: Start(); break; case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer: Stop(); break; case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow: m_importOnce = true; ImportNow(); break; default: TBDEBUG(\"Unknown action\"); break; } } void InstrumentEnricherPlugin::Start() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_timerController.Start(); } SetState(StrategyState::RUNNING); } void InstrumentEnricherPlugin::Stop() { TBDEBUG(__func__); if (m_timerController.IsActive()) {<fim-suffix>if (GetState().IsPaused()) { TBDEBUG(\"Already stopped\"); return; } Strategy::SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::ImportNow() { TBDEBUG(__func__); m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); } void InstrumentEnricherPlugin::HandleImportComplete(const String& status) { TBDEBUG(__func__ << \" : \" << status); m_plugInStatusDescription = status + \" at \" + DateTime::Now().ToString(); if (m_importOnce) { Stop(); } } void InstrumentEnricherPlugin::HandleInstrumentManagerFailed(const String& reason) { TBWARNING(__func__ << \" : Instrument manager failed with reason =<fim-middle>m_timerController.Stop(); } m_instrumentManager.Stop(); m_importOnce = false;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; private: void FailWithReason(const<fim-suffix><fim-middle>tbricks::String & reason); \/\/ app parameters     tbricks::StringParameter m_clientID;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n<fim-suffix><fim-middle>    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price,<fim-suffix>EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetIndexPrice, index_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetCurrentFunding, current_funding, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetBid, best_bid_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetAsk, best_ask_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetBidVolume, best_bid_amount, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetAskVolume, best_ask_amount,<fim-middle>0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); }<fim-suffix>void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final; private: bool CheckRunningRequirement(); void HandleAction(const tbricks::Integer & action); void Start(); void Stop(); void ImportNow(); \/\/ app parameters tbricks::IntegerParameter m_instrument_enricherAppAction; tbricks::DurationParameter m_importFrequency; tbricks::InstrumentGroupParameter m_instrumentGroup; tbricks::DateTimeParameter m_maturityDate; tbricks::StringParameter m_plugInStatusDescription; tbricks::DateTimeParameter m_startTime;<fim-middle>"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->Reset();\n    }\n    else\n    {\n        TBDEBUG(\"Unknown stream\");\n    }\n}\n\nvoid DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->Fail();\n    }\n    else\n    {\n        TBDEBUG(\"Unknown stream\");\n    }\n}\n\nvoid DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n    TBDUMP(update);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->HandleDistributedValuesUpdate(update);\n    }\n    else\n    {\n        TBDEBUG(\"No Deribit model associated with stream: \" << stream);\n    }\n}\n\nstd::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream)\n{\n    auto it_streams = m_streams.find(stream);\n    if (it_streams == m_streams.end())\n    {\n        return std::nullopt;\n    }\n\n    return GetModel(it_streams->second);\n}\n\nstd::optional<DeribitModel *> DeribitMdp::GetModel(const InstrumentIdentifier & instrument)\n{\n    auto it_models = m_models.find(instrument);\n    if (it_models == m_models.end())\n<fim-suffix><fim-middle>    {\n        return std::nullopt;\n    }"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); }<fim-suffix>{ return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\<fim-middle>if (not state.empty() and state.compare(\"open\") == 0)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument); \/\/ app parameters tbricks::StringParameter m_clientID;<fim-suffix><fim-middle>tbricks::StringParameter m_clientSecret;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"..\/VolatilityManagerSettings.h\"\n#include \"..\/ImpliedVolatilitySourcesManagerCore.h\"\n#include \"..\/..\/preferences_editor\/tbricks_definitions.h\" \/\/ FIXME: Remove when cp definitions are generated for shared\/system meta (TB-103467)\n#include <shared\/Macros.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/String.h>\n#include <strategy\/Instrument.h>\n#include <strategy\/Definitions.h>\n#include <strategy\/Logger.h>\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n#include <iostream>\n#include <cmath>\n<fim-suffix><fim-middle>const CalculatedPropertyFilter PreferencesStorage::dummyFilter = CalculatedPropertyFilter::Condition(\n    vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::NE, Integer());"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status,<fim-suffix><fim-middle>const std::string & reason = \"\");"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n\nprivate:\n    std::string_view type;\n};\n\nclass subscriptions : public JsonCall\n{\npublic:\n    subscriptions(const std::string_view id, DeribitMethod method);\n\n    void AddChannel(const std::string & channel);\n};\n\nclass subscriptions_reply : public JsonReply\n{\npublic:\n    subscriptions_reply(JsonReply && base);\n\n    std::vector<std::string_view> GetChannels() const;\n};\n<fim-suffix><fim-middle>class subscription_update : public JsonReply\n{\npublic:\n    subscription_update(JsonReply && base);"}
{"content":"<fim-prefix>#pragma once<fim-suffix>#include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply<fim-middle>#include \"DeribitMethods.h\""}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n<fim-suffix><fim-middle>{\npublic:\n    class IHandler\n    {"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm,<fim-suffix><fim-middle>const char val)"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::CalculatedInstrumentValues::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n\n    InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid);\n    ~InstrumentManager() noexcept override;\n    void Start();\n    void Stop();\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;\n\n    void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {};\n<fim-suffix><fim-middle>    void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID,\n                                             const tbricks::InstrumentIdentifier & instrumentID,\n                                             const tbricks::InstrumentAggregateParameters::Update & update) override;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel<fim-suffix>private: std::map<tbricks::StreamIdentifier, tbricks::InstrumentIdentifier> m_streams; std::map<tbricks::InstrumentIdentifier, DeribitModel> m_models;<fim-middle>*> GetModel(const tbricks::InstrumentIdentifier & instrument);"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return false; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { {<fim-suffix><fim-middle>diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n<fim-suffix><fim-middle>    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it,<fim-suffix><fim-middle>tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#include \"shared\/API.h\"\n#include \"InstrumentPricing.h\"\n#include \"util\/Log.h\"\n#include \"PricingPlugin.h\"\n#include \"InstrumentFilterSubscriber.h\"\n#include \"Underlying.h\"\n#include \"payments\/DividendInstrument.h\"\n#include \"payments\/PaymentInstrument.h\"\n#include \"UnderlyingComponentsManager.h\"\n#include \"price_providers\/BarrierInstrument.h\"\n#include \"models\/ModelCalculatorFactory.h\"\n#include \"models\/TurboOptionModelCalculator.h\"\n#include \"models\/TurboOptionWithDividendsModelCalculator.h\"\n#include \"models\/MiniFutureModelCalculator.h\"\n#include \"models\/CallableBullBearContractModelCalculator.h\"\n#include \"models\/CBBCWithDividendsModelCalculator.h\"\n#include \"models\/CBBCBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/CBBCWithDividendsBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/BondModelCalculator.h\"\n#include \"models\/EquityReturnModelCalculator.h\"\n#include \"price_providers\/PriceProviderEmpty.h\"\n#include \"price_providers\/PriceProviderSingle.h\"\n#include \"price_providers\/PriceProviderQuote.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/interest_rate\/YieldCurveWrapper.h\"\n#include \"UserPreferencesSubscriber.h\"\n#include \"time\/TimeOptions.h\"\n#include \"time\/TimeValues.h\"\n#include \"time\/VolatilityTimeWeights.h\"\n#include \"time\/CalendarUtils.h\"\n#include <cmath>\n#include <algorithm>\n#include <type_traits>\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include \"shared\/combination\/ICombinationModel.h\"\n#include \"shared\/Macros.h\"\n#include <shared\/instrument_types\/InstrumentTypes.h>\n#include <shared\/metaprogramming\/Defer.hpp>\n\n#include \"util\/Tokens.h\"\n\n#include \"models\/EquityModelCalculator.h\"\n#include \"models\/ExternalModelCalculator.h\"\n#include \"models\/ExternalTaylorModelCalculator.h\"\n#include \"models\/ExternalModelDistributionCalculator.h\"\n\n#include \"models\/PricingCombinationModel.h\"\n#include \"models\/util\/MiscCalculations.h\"\n#include \"models\/util\/DividendsUtil.h\"\n\n#include \"shared\/datetime_helpers\/DateTimeHelpers.h\"\n#include \"shared\/smart_pointers\/IntrusiveWeakPointer.hpp\"\n\n#include <shared\/time\/TimeParser.h>\n#include <shared\/StateRestorer.hpp>\n\n#include \"tbricks_definitions.h\"\n#include \"shared\/pricing\/tbricks_constants.h\"\n\nusing namespace tbricks;\n\nstd::ostream & operator<<(std::ostream & os, const RelativeValuationTime val_time)\n{\n    using RVT = RelativeValuationTime;\n    switch (val_time) {\n    case RVT::NOW:                 return os << \"Now\";\n    case RVT::TODAY_CLOSE:         return os << \"Today close\";\n    case RVT::NEXT_OPEN:           return os << \"Next open\";\n    case RVT::NEXT_DAY:            return os << \"Next day\";\n    default:                       return os << \"Unrecognized valuation time\";\n    }\n}\n\nInstrumentPricing::InstrumentPricing(PricingPlugin & plugin, const InstrumentIdentification & id,\n                                     const InstrumentVenueIdentification & ivid,\n                                     std::shared_ptr<SnapshotToken> snapshot_token,\n                                     std::shared_ptr<ModificationToken> modification_token,\n                                     const LegSettingsPtr & leg_settings) :\n    m_id(id),\n    m_plugin(plugin),\n    m_ivid(new InstrumentVenueIdentification(ivid)),\n    m_leg_settings(leg_settings),\n    m_instrument(new Instrument()),\n    m_override_prices(new IPriceProvider::OverridePriceContainer()),\n    m_q(GetCalculationSettings().GetYield()),\n    m_today_values(new TimeValues()),\n    m_plugin_modify_version(plugin.GetPluginModifyVersion()),\n    m_snapshot_token(snapshot_token),\n    m_modification_token(modification_token)\n{\n    PDEBUGN(\"Create instrument pricing: \" << *m_ivid << \" row id = \" << GetRowIdentifier());\n\n    m_calculated_values_pool.reset(new CalculatedInstrumentValuesPool(plugin, *this));\n    PDEBUGN(\"Instrument size is \" << sizeof(*this) << \", pool size is \" << sizeof(*m_calculated_values_pool));\n\n    if (m_ivid->GetInstrumentIdentifier().Empty()) {\n        ResetSnapshotTokens();\n        m_snapshot_done = true;\n        return;\n    }\n\n    if (m_calculated_values_pool->GetValuesRequest().TimeGreeksIsActive()) {\n        m_today_close_values.reset(new TimeValues());\n        m_next_trading_open_values.reset(new TimeValues());\n        m_next_trading_day_values.reset(new TimeValues());\n    }\n<fim-suffix><fim-middle>    InitializeDefaultParameters();\n    InitializeCalculatedValues();"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\";<fim-suffix><fim-middle>case DeribitHost::DERIBIT_PROD:"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler, visualization::Grid& instrumentsGrid)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n    , m_tasksDone(false)\n    , m_instrumentsGrid(instrumentsGrid)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n    m_tasksDone = false;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::OpenCIVStream()\n{\n    CalculatedInstrumentValues::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrumentVenueIdentification(InstrumentVenueIdentification(instId));\n    }\n    options.AddValue(calculated_values::UnderlyingPrice());\n\n    auto throttle = MaximumUpdateTimeThrottle(Duration::Seconds(5));\n    options.SetThrottle(throttle);\n    m_calculatedValuesStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened calculated instrument values stream : \" << m_calculatedValuesStream.GetIdentifier() << \" with options : \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n        OpenCIVStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n<fim-suffix><fim-middle>    {\n        m_instrumentCache[instrument.GetIdentifier()].instrument = instrument;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n\nprotected:\n<fim-suffix><fim-middle>    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;\n    void HandleStreamClose(tbricks::TCPStream & stream) final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler interface void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId, const tbricks::CalculatedInstrumentValues::Update & update) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status<fim-suffix><fim-middle>status, const tbricks::String& status_text) final;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool<fim-suffix><fim-middle>DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n<fim-suffix><fim-middle>        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void<fim-suffix><fim-middle>HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler);<fim-suffix><fim-middle>~DeribitModel() noexcept = default;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received<fim-suffix><fim-middle>an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\" #include \"PricingPlugin.h\" #include \"volatility\/CustomVolatilityModel.h\" #include \"shared\/volatility\/InterpolatedVolatilityModel.h\" #include <utility> using namespace tbricks; VolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin , const StreamSettingsPtr & stream_settings_ptr , const InstrumentGroupIdentifier & group , const DateTime & maturity_date) : m_plugin(plugin) , m_maturity_date(maturity_date) , m_group(group) , m_stream_settings_ptr(stream_settings_ptr) { PDUMPN(\"Create volatility<fim-suffix>if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) { HandleVolatilityGroupParameters(); } } VolatilityCurveHandler::~VolatilityCurveHandler() { m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider); m_parameters_provider = nullptr; } bool VolatilityCurveHandler::IsSnapshotDone() const { if (!m_parameters_provider) return true; return m_parameters_provider->IsSnapshotDone(); } void VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber) { if (!subscriber) return; m_subscribers.push_back(subscriber); } void VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber) { auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber); if (found != m_subscribers.end()) { std::swap(*found, m_subscribers.back()); m_subscribers.pop_back(); } } bool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides) {<fim-middle>curve handler\"); m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n        Channel channel; \/\/ should be always sorted\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n<fim-suffix><fim-middle>private:\n    void OnLoginReply(SingleTransaction & t);\n    void OnSetHeartbeatReply(SingleTransaction & t);\n    void OnHeartbeat(deribit::JsonReply && incoming);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n<fim-suffix><fim-middle>    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum<fim-suffix>CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public: subscriptions(const<fim-middle>class GrantType {"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n    {\n        TBWARNING(\"Received unknown instrument ticker: \" << ticker);\n        return;\n    }\n    auto request = m_requestMap.find(id);\n    if (request != m_requestMap.end())\n    {\n        for (const auto & object : request->second.GetObjects())\n        {\n            InstrumentIdentifier instrument;\n            object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrument);\n            if (instrument == id)\n            {\n                for (const auto & value : request->second.GetValues())\n                {\n                    if (value.GetDefinition() == dv::DeribitTicker())\n                    {\n                        String data(json.data(), json.size());\n                        IDistributionApp::Update({object.GetIdentifier(), value.GetIdentifier()}, data);\n                        IDistributionApp::Send();\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n<fim-suffix><fim-middle>std::pair<bool, VenueInstrumentIdentifier> DeribitContributor::ExtractVIID(const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : \" << instrument.GetShortName());\n    bool compatible = false;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { \/\/ Here is where<fim-suffix>void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update<fim-middle>we would open the DistributedValues::Stream }"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin2 : public tbricks::Pricing { public: ExampleCalcAppPlugin2(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; bool HandlePartialPricingModifyRequest(const tbricks::CalculatedValuesRequestUpdate &update) override; private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override<fim-suffix><fim-middle>{}; void HandleRunRequest() override {};"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n<fim-suffix><fim-middle>    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; InstrumentManager(IHandler& handler); ~InstrumentManager(); void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final; private: void OpenInstrumentStream(); void OpenIAPStream(); void EnrichInstruments(); void ModifyGroup(); void CheckResolutionStatus(); void CheckModificationStatus(); IHandler&<fim-suffix>tbricks::InstrumentStream m_instrumentStream; tbricks::InstrumentAggregateParameters::Stream m_iapStream;<fim-middle>m_handler;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n<fim-suffix><fim-middle>    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n<fim-suffix><fim-middle>    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double,<fim-suffix>GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color,<fim-middle>Delta) GREEK(gamma, Double, Gamma)"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n<fim-suffix><fim-middle>    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired)<fim-suffix>VOLATILITY_MODEL_WRAP(None,ConstantVolatility)<fim-middle>VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel)"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n<fim-suffix><fim-middle>        return {};\n    }\n}"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);\n\n     if (id.second != m_tickerId)\n    {\n        TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);\n        return;\n    }\n\n    if (value.Empty() or (value == \"{}\") or value.HasError())\n    {\n        Price emptyPrice;\n        Volume emptyVolume {0};\n        iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale);\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\");\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        bbo.SetAskPrice(emptyPrice);\n        bbo.SetBidPrice(emptyPrice);\n        bbo.SetAskVolume(emptyVolume);\n        bbo.SetBidVolume(emptyVolume);\n        return;\n    }\n\n    iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk);\n    iStatus.SetVenueInstrumentMarketDataStatus(\"OK\");\n\n    deribit::ticker_update update(value);\n\n    if (update.IsOpen())\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed);\n    }\n    else\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed);\n    }\n\n    bbo.SetAskPrice(update.GetAsk());\n    bbo.SetBidPrice(update.GetBid());\n    bbo.SetAskVolume(update.GetAskVolume());\n    bbo.SetBidVolume(update.GetBidVolume());\n    auto millis = update.GetTimestamp();\n    DateTime timestamp = DateTime::Now();\n    if (millis > 0)\n    {\n        timestamp = DateTime::Create(millis \/ 1000);\n    }\n    bbo.SetExchangeModifiedDatetime(timestamp);\n    \n    stats.SetLastPrice(update.GetLastPrice());\n    stats.SetOpenInterest(update.GetOpenInterest());\n    stats.SetDailySettlementPrice(update.GetSettlementPrice());\n    stats.SetHighPrice(update.GetMaxPrice());\n    stats.SetLowPrice(update.GetMinPrice());\n}\n<fim-suffix><fim-middle>void DeribitModel::Reset()\n{\n    InstrumentStatus status;\n    BestPrice bbo;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n<fim-suffix><fim-middle>    {\n        FailWithReason(\"Missing endpoint\");\n    }"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n<fim-suffix><fim-middle>    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetIndexPrice, index_price,<fim-suffix>EXTRACT_DOUBLE_METHOD(ticker_update::GetBid, best_bid_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetAsk, best_ask_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetBidVolume, best_bid_amount,<fim-middle>0) EXTRACT_DOUBLE_METHOD(ticker_update::GetCurrentFunding, current_funding, 0)"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    TBSTATUS(\"Subscribing to ticker: \" << id);\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n    {\n        TBWARNING(\"Received unknown instrument ticker: \" << ticker);\n        return;\n    }\n    auto request = m_requestMap.find(id);\n    if (request != m_requestMap.end())\n    {\n        for (const auto & object : request->second.GetObjects())\n        {\n            InstrumentIdentifier instrument;\n            object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrument);\n            if (instrument == id)\n            {\n                for (const auto & value : request->second.GetValues())\n                {\n                    if (value.GetDefinition() == dv::DeribitTicker())\n                    {\n                        String data(json.data(), json.size());\n<fim-suffix><fim-middle>                        IDistributionApp::Update({object.GetIdentifier(), value.GetIdentifier()}, data);\n                        IDistributionApp::Send();\n                        return;\n                    }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason &<fim-suffix>\/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier&<fim-middle>reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const<fim-suffix>const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double<fim-middle>size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;\n    }\n}\n\nvoid InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n    {\n        const int total = m_instrumentCache.size();\n\n        std::stringstream result;\n        result << \"Total instruments = \" << total << \", successful = \" << total - m_failed\n               << \", failed = \" << m_failed;\n\n        m_handler.HandleImportComplete(result.str());\n    }\n}\n\nvoid InstrumentManager::EnrichInstruments()\n{\n    TBDEBUG(__func__);\n<fim-suffix><fim-middle>    for (const auto& [instID, instrument] : m_instrumentCache)\n    {\n        InstrumentModifier instrumentModifier(instID);\n        DateTime tbMaturityDate;"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" #include \"MyCustomVolatilityModel.h\" using<fim-suffix>IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const<fim-middle>namespace tbricks; using namespace volatility;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>bool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n<fim-suffix><fim-middle>    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats); void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream;<fim-suffix>tbricks::Identifier<fim-middle>tbricks::MarketDataItem m_mdItem;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::CalculatedInstrumentValues::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n\n    explicit InstrumentManager(IHandler& handler);\n    ~InstrumentManager() noexcept override;\n    void Start();\n    void Stop();\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;\n\n    void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {};\n\n    void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID,\n                                             const tbricks::InstrumentIdentifier & instrumentID,\n                                             const tbricks::InstrumentAggregateParameters::Update & update) override;\n\n<fim-suffix><fim-middle>    void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId,\n                                                  const tbricks::CalculatedInstrumentValues::Update & update) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/CalculatedPropertiesStream.h>\n#include <vector>\n\nclass PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler\n{\npublic:\n    PositionsData(const tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status);\n    ~PositionsData();\n\n    void Stop();\n\npublic:\n    using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>;\n<fim-suffix><fim-middle>    const Data& GetData() const { return m_data; }"}
{"content":"<fim-prefix>#include \"..\/..\/my_custom_pricing\/tbricks_definitions.h\"<fim-suffix><fim-middle>constexpr VolatilityModel VolatilityModelMyCustom = VolatilityModel(custom::pricing::extended_enums::VolatilityModelMyCustom);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n\npublic_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n{\n}\n\nheartbeat::heartbeat(JsonReply && base)\n    : JsonReply(std::move(base))\n    , type {Pointer(\"\/params\/type\").Get(msg)->GetString()}\n<fim-suffix><fim-middle>{\n}"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n<fim-suffix><fim-middle>{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS:<fim-suffix><fim-middle>return std::make_unique<CCSPreferencesStorage>();"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/<fim-suffix><fim-middle>Maximum size of incoming messages. Defaults to architecture maximum.         \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed."}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return<fim-suffix><fim-middle>m_stream.GetIdentifier(); }"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n<fim-suffix><fim-middle>    m_buffer << data;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;\n    }\n}\n\nvoid InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n    {\n        const int total = m_instrumentCache.size();\n\n        std::stringstream result;\n        result << \"Total instruments = \" << total << \", successful = \" << total - m_failed\n               << \", failed = \" << m_failed;\n\n        m_handler.HandleImportComplete(result.str());\n    }\n}\n\nvoid InstrumentManager::EnrichInstruments()\n{\n    TBDEBUG(__func__);\n\n    for (const auto& [instID, instrument] : m_instrumentCache)\n    {\n        InstrumentModifier instrumentModifier(instID);\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        if (tbMaturityDate != m_handler.GetMaturityDate())\n        {\n            InstrumentAttributes attributes;\n            attributes.SetAttribute(instrument_attributes::MaturityDate(), m_handler.GetMaturityDate());\n            instrumentModifier.SetAttributes(attributes);\n            Instrument::RequestResult result = Instrument::SendModifyRequest(instrumentModifier, *this);\n            m_instrumentModifyRequests.emplace(result.GetRequestIdentifier(), instID);\n        }\n    }\n\n    ModifyGroup();\n    CheckModificationStatus();\n}\n\nvoid InstrumentManager::ModifyGroup()\n{\n    TBDEBUG(__func__);\n\n    InstrumentGroupIdentifier groupID = m_handler.GetInstrumentGroup().GetIdentifier();\n    std::vector<InstrumentParameterDefinition> defs;\n    defs.push_back(instrument_parameters::UnderlyingInstrument());\n\n    InstrumentGroupParameters groupParams(groupID, defs);\n    InstrumentIdentifier underlyingInstrument;\n    groupParams.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingInstrument);\n\n    InstrumentGroupParameters::Modifier modifier;\n    if (underlyingInstrument.Empty())\n    {\n        modifier.SetParameter(instrument_parameters::UnderlyingInstrument(), m_handler.GetUnderlyingInstrument());\n    }\n    else\n    {\n        TBNOTICE(\"Not changing existing underlying instrument for group\");\n    }\n\n    if (not modifier.Empty())\n    {\n        Identifier id = InstrumentGroupParameters::SendModifyRequest(groupID, modifier, *this);\n        m_groupModifyRequests.emplace(id, groupID);\n    }\n}\n\nvoid InstrumentManager::HandleRequestReply(const Identifier& id, class Status status, const String& status_text)\n{\n    TBDEBUG(__func__ << \" : \" << id);\n\n    if (const auto it = m_instrumentModifyRequests.find(id); it not_eq m_instrumentModifyRequests.end())\n    {\n        if (status not_eq Status::OK)\n<fim-suffix><fim-middle>        {\n            m_failed++;\n            TBWARNING(\"Instrument modification failed for = \" << it->second << \", reason = \" << status_text);\n        }"}
{"content":"<fim-prefix>#include \"PositionsData.h\" #include \"tbricks_definitions.h\" #include <strategy\/Logger.h> #include <strategy\/stream_filter\/PositionByPortfolioFilter.h> #include <strategy\/SparseSet.h> #include <sstream> #include <vector> using namespace tbricks; namespace cps = go_flat::calculated_properties::position; PositionsData::PositionsData(const PortfolioIdentifier& portfolioId,<fim-suffix>: m_appStatus(status) , m_stream(*this) { TBDEBUG(__func__ << \" : \" << portfolioId); CalculatedPropertiesTable::Stream::Options options; options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {}); options.AddProperty(cps::Instrument()); options.AddProperty(cps::Venue()); options.AddProperty(cps::MIC()); options.AddProperty(cps::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS()); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); TBDUMP(\"Stream opened with options: \" << options); } PositionsData::~PositionsData() { TBDEBUG(__func__); m_stream.Close(); } void PositionsData::Stop() { TBDEBUG(__func__); m_stream.Close(); } void PositionsData::HandleStreamOpen(const StreamIdentifier& stream) { m_appStatus = \"Waiting for positions data\"; } void PositionsData::HandleStreamStale(const StreamIdentifier& stream) { m_appStatus<fim-middle>StringParameter& status)"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n<fim-suffix><fim-middle>        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include<fim-suffix>{ public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/<fim-middle><deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler, public InstrumentManager::IHandler"}
{"content":"<fim-prefix>#include \"PositionReverser.h\" #include \"tbricks_definitions.h\" #include <cmath> using namespace tbricks; void PositionReverser::ReversePosition( const Position& position, const Price& atPrice) { Trade reversedTrade; Volume netPosition = position.GetNetPosition(); if (netPosition > 0) { reversedTrade.SetSide(Side::SELL); } else { reversedTrade.SetSide(Side::BUY); } reversedTrade.SetPrice(atPrice); reversedTrade.SetType(TradeType::POSITION_ADJUSTMENT); reversedTrade.SetCurrency(position.GetCurrency()); reversedTrade.SetClient(position.GetClient()); reversedTrade.SetVolume(std::fabs(position.GetNetPosition())); reversedTrade.SetCounterpart(position.GetCounterpart()); Trade::RequestResult reqCreate = Trade::SendCreateRequest(reversedTrade, *this); m_reversedPositions[reqCreate.GetRequestIdentifier()] = position.GetIdentifier(); TBDEBUG(\"Requested to reverse position: \" << position.GetIdentifier() << \" with trade: \" << reqCreate.GetTradeIdentifier()); } void PositionReverser::HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) {<fim-suffix>auto iterCreate<fim-middle>TBDEBUG(__func__ << \" \" << id << \" with status \" << status << \" \" << status_text);"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield,<fim-suffix>GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double,<fim-middle>Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity)"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n<fim-suffix><fim-middle>        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired =<fim-suffix>if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(),<fim-middle>DateTime::Now();"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final<fim-suffix><fim-middle>{} void HandleInstrumentManagerFailed(const tbricks::String& reason) final;"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired) VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(None,ConstantVolatility)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } protected:<fim-suffix><fim-middle>tbricks::DistributedValues::Stream m_stream;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n<fim-suffix><fim-middle>protected:\n    struct Session : public tbricks::Printable\n    {"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n<fim-suffix><fim-middle>    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)\n    {\n        strm << \"  subscription : \" << Resolve(subscription) << \"\\n\";\n    }\n    if (interval != DeribitInterval::NONE)\n    {\n        strm << \"  interval : \" << Resolve(interval) << \"\\n\";\n    }\n    strm << \"  channel : \" << channel << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nDeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type)\n    : m_handler(handler)\n    , m_timer(*this, \"deribit_refresh\")\n{\n    TBDEBUG(__func__ << \" : \" << endpoint);\n\n    std::string url(endpoint.GetCString());\n    auto found = url.find(\":\/\/\");\n    if (found != std::string::npos)\n    {\n        url = url.substr(found + 3);\n    }\n    m_session.host_port_path = url;\n\n    std::vector<String> slices;\n    m_session.host_port_path.Split(':', slices);\n    TBDUMP(slices);\n    switch (type)\n    {\n    case DeribitHost::NONE:\n        m_conf.header.insert({\"Host\", slices[0].GetCString()});\n        break;\n    default:\n        m_conf.header.insert({\"Host\", Resolve(type)});\n        break;\n    }\n}\n\nDeribitClient::~DeribitClient()\n{\n    TBDEBUG(__func__);\n    Disconnect();\n}\n\nvoid DeribitClient::Connect(const String & userId, const String & secret)\n{\n    TBDEBUG(__func__ << \" : userId=\" << userId << \" secret=\" << secret);\n    m_session.userId = userId;\n    m_session.secret = secret;\n\n    m_ws = std::make_unique<TbWebsocketClient>(*this, m_session.host_port_path, m_conf);\n    m_ws->Connect();\n}\n\nvoid DeribitClient::Disconnect()\n{\n    TBDEBUG(__func__);\n    if (m_ws)\n    {\n        m_session.logged_in = false;\n        m_ws->Shutdown();\n    }\n}\n\nvoid DeribitClient::SetHeartbeat(int seconds)\n{\n    TBDEBUG(__func__ << \" : \" << seconds << \"s\");\n    m_session.hb = seconds;\n    if (m_ws)\n    {\n        auto & t = NewTransaction();\n        t.method = DeribitMethod::PUBLIC_SetHeartbeat;\n        t.call = std::make_unique<deribit::public_set_heartbeat>(t.id.ToString().GetCString());\n        auto msg = dynamic_cast<deribit::public_set_heartbeat *>(t.call.get());\n        msg->SetInterval(seconds);\n        PerformTransaction(t);\n    }\n    else\n<fim-suffix><fim-middle>    {\n    }\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\ntypedef std::pair<DeribitMethod, std::string> Method;\n\nstatic std::vector<Method> GetAvailableMethods()\n{\n    return {\n            {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)},\n            {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)},\n            {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)},\n            {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)},\n            {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)},\n            {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)},\n            {DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)},\n            {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)},\n            {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}};\n}\n<fim-suffix><fim-middle>} \/\/ namespace deribit"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\" using namespace tbricks; InstrumentManager::InstrumentManager(IHandler& handler) : m_handler(handler) , m_instrumentStream(*this) , m_iapStream(*this) { TBDEBUG(__func__ << \" ctor\"); } InstrumentManager::~InstrumentManager() { TBDEBUG(__func__ << \" dtor\"); Stop(); } void InstrumentManager::Stop() { TBDEBUG(__func__); m_instrumentCache.clear(); m_underlyingCache.clear(); m_instrumentStream.Close(); } void InstrumentManager::Start() { TBDEBUG(__func__); Stop(); OpenInstrumentStream(); } void InstrumentManager::OpenInstrumentStream() { TBDEBUG(__func__); InstrumentStream::Options options; options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup())); m_instrumentStream.Open(Stream::SNAPSHOT, options); TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter()); } void InstrumentManager::OpenIAPStream() { TBDEBUG(__func__); tbricks::InstrumentAggregateParameters::Stream::Options options; for (const auto& [instId, _] : m_instrumentCache) { options.AddInstrument(instId); } options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()}); m_iapStream.Close(); m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options); TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options); } void InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); } void InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID) { TBWARNING(\"Instrument cache stream staled = \" << streamID); } void InstrumentManager::HandleStreamFailed(const StreamIdentifier& streamID) { m_handler.HandleInstrumentManagerFailed(\"Instrument stream failed\"); } void InstrumentManager::HandleSnapshotEnd(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); if (streamID == m_instrumentStream.GetIdentifier()) { TBDEBUG(\"Instruments snapshot done, enriching...\"); OpenIAPStream(); } else if (streamID == m_iapStream.GetIdentifier()) { \/\/ All data is collected, now perform the next steps EnrichInstruments(); } } void InstrumentManager::HandleInstrument(const StreamIdentifier& streamID, const Instrument& instrument) { TBDEBUG(__func__<fim-suffix>TBDUMP(instrument); if (streamID == m_instrumentStream.GetIdentifier()) { m_instrumentCache[instrument.GetIdentifier()] = instrument; } else<fim-middle><< \" : stream = \" << streamID << \", instrument ID = \" << instrument.GetIdentifier());"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n<fim-suffix><fim-middle>#define BUFFER_MIN_SIZE 4"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n<fim-suffix><fim-middle>    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo;<fim-suffix>for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { Price emptyPrice; Volume emptyVolume {0}; iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume);<fim-middle>InstrumentStatus status; Statistics stats;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { Price emptyPrice; Volume emptyVolume {0}; iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); deribit::ticker_update update(value); \/\/ Handle the trading phase if (update.IsOpen()) { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed); } else { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed); } \/\/ BBO bbo.SetAskPrice(update.GetAsk()); bbo.SetBidPrice(update.GetBid()); bbo.SetAskVolume(update.GetAskVolume()); bbo.SetBidVolume(update.GetBidVolume()); auto millis = update.GetTimestamp(); DateTime timestamp = DateTime::Now(); if (millis > 0) { timestamp = DateTime::Create(millis \/ 1000); } bbo.SetExchangeModifiedDatetime(timestamp); \/\/ Statistics stats.SetLastPrice(update.GetLastPrice()); stats.SetOpenInterest(update.GetOpenInterest()); stats.SetDailySettlementPrice(update.GetSettlementPrice()); stats.SetHighPrice(update.GetMaxPrice()); stats.SetLowPrice(update.GetMinPrice());<fim-suffix><fim-middle>} void DeribitModel::Reset() {"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto& msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } \\ EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetIndexPrice, index_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetCurrentFunding, current_funding, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetBid, best_bid_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetAsk, best_ask_price,<fim-suffix><fim-middle>0) EXTRACT_DOUBLE_METHOD(ticker_update::GetBidVolume, best_bid_amount, 0)"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \" + m_frequency.ToString(); } m_handler.HandleTimerControllerUpdate(status, \/*error =*\/ false); } void<fim-suffix>}<fim-middle>TimerController::Stop() { TBDEBUG(__func__); m_startTimerEvent.Stop();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument &<fim-suffix>tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint; std::unique_ptr<DeribitClient> m_client; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::DistributedValuesRequest> m_requestMap; tbricks::Set<tbricks::Identifier> m_supported_values; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::VenueInstrumentIdentifier> m_viidMap; tbricks::SparseHash<tbricks::String, tbricks::InstrumentIdentifier> m_symbolMap; tbricks::VenueIdentifier<fim-middle>instrument); \/\/ app parameters     tbricks::StringParameter m_clientID;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType {<fim-suffix>}; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions<fim-middle>CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\ntypedef std::pair<DeribitMethod, std::string> Method;\n\nstatic std::vector<Method> GetAvailableMethods()\n{\n    return {\n            {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)},\n            {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)},\n<fim-suffix><fim-middle>            {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)},\n            {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)},\n            {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)},\n            {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)},"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\" #include \"PricingPlugin.h\" #include \"volatility\/CustomVolatilityModel.h\" #include \"shared\/volatility\/InterpolatedVolatilityModel.h\" #include <utility> using namespace tbricks; VolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin , const StreamSettingsPtr & stream_settings_ptr , const InstrumentGroupIdentifier & group , const DateTime & maturity_date) : m_plugin(plugin) , m_maturity_date(maturity_date) , m_group(group) , m_stream_settings_ptr(stream_settings_ptr) { PDUMPN(\"Create volatility curve handler\"); m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true); if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) { HandleVolatilityGroupParameters(); } } VolatilityCurveHandler::~VolatilityCurveHandler() { m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider); m_parameters_provider = nullptr; } bool VolatilityCurveHandler::IsSnapshotDone() const { if (!m_parameters_provider) return true; return m_parameters_provider->IsSnapshotDone(); } void VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber) { if (!subscriber) return; m_subscribers.push_back(subscriber); } void VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber) { auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber); if (found != m_subscribers.end()) { std::swap(*found, m_subscribers.back()); m_subscribers.pop_back(); } } bool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides) { if (!m_parameters_provider) return false; return m_parameters_provider->UpdateOverrides(overrides); } std::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source) { if (!m_volatility_model) return {}; if (source.Empty()) return m_volatility_model; auto & weak = m_volatility_models[source]; auto ret = weak.lock(); if (ret) return ret; ret.reset(m_volatility_model->Clone()); weak = ret; return ret; } std::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source) { if (!m_volatility_model) return {}; if (m_volatility_model->IsInterpolated()) return {}; if (source.Empty()) return m_volatility_model; auto & weak = m_volatility_models[source]; auto ret = weak.lock(); if (ret) return ret; ret.reset(m_volatility_model->Clone()); weak = ret; return ret; } bool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group , const InstrumentGroupAggregateParameters::Update & update)<fim-suffix><fim-middle>{ return HandleVolatilityGroupParameters(&update);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm;<fim-suffix>Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char val) { ostm.write(&val, sizeof(char)); return ostm; }<fim-middle>}"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual<fim-suffix><fim-middle>~JsonReply() = default;"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price,<fim-suffix><fim-middle>UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed)"}
{"content":"<fim-prefix>#pragma once\n\n#include <string_view>\n#include <strategy\/type\/String.h>\n\nnamespace deribit {\n\nstruct RapidDocument;\n\nclass UpdateData\n{\npublic:\n    UpdateData();\n    virtual ~UpdateData();\n\n    std::string_view ToString();\n    void Parse(const tbricks::String & str);\n<fim-suffix><fim-middle>protected:\n    RapidDocument * m_doc;\n};"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"<fim-suffix>using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason,<fim-middle>#include \"tbricks_definitions.h\""}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n<fim-suffix><fim-middle>        std::ostream & Print(std::ostream & strm) const final;\n    };"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n\nprotected:\n    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;\n    void HandleStreamClose(tbricks::TCPStream & stream) final;\n\n    void UpgradeWs();\n\nprivate:\n    std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept;\n\n    void ParseHttpReply(const tbricks::Binary & data);\n    std::size_t ReadWsReply(std::istream & data);\n    void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length);\n\nprivate:\n    IWebsocketHandler & m_handler;\n    tbricks::TCPStream m_tcp;\n    std::random_device m_rd;\n    std::shared_ptr<std::string> nonce_base64;\n\n    Config m_config;\n<fim-suffix><fim-middle>    std::string host;\n    unsigned short port;\n    std::string path;\n    bool m_handshake_done = false;"}
{"content":"<fim-prefix>#pragma once #include \"IExecutionHandler.h\" #include \"shared\/API.h\" namespace execution { class OrderExecutor { public: virtual ~OrderExecutor() = default; OrderExecutor(IExecutionHandler& handler) : m_handler(handler) { m_stats.bought = 0.0; m_stats.sold = 0.0; m_stats.valueBought = 0.0; m_stats.valueSold = 0.0; } virtual void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) =<fim-suffix>protected: IExecutionHandler& m_handler; Stats m_stats; }; } \/\/ namespace<fim-middle>0; virtual void DeleteOrders() = 0;"}
{"content":"<fim-prefix>#include \"Values.h\"\n#include \"ValuesRequest.h\"\n<fim-suffix><fim-middle>void ImpliedValue::Clear()\n{\n    implied_volatility.Clear();\n}"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h><fim-suffix>using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0;<fim-middle>#include <third_party\/include\/rapidjson\/pointer.h> namespace deribit {"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n<fim-suffix><fim-middle>{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler<fim-suffix>InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters &<fim-middle>{ public:"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n<fim-suffix><fim-middle>    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);"}
{"content":"<fim-prefix>#pragma once #include<fim-suffix>{ public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const<fim-middle><shared\/API.h> class DeribitModel"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"PositionRetriever.h\" #include \"PositionReverser.h\" class ReversalManager : public PositionRetriever::IHandler, public tbricks::ITimerEventHandler { public: class IHandler; ReversalManager(IHandler& callback); ~ReversalManager() = default; void Start( const tbricks::PortfolioIdentifier& portfolioId, const tbricks::Integer& priceSource, const tbricks::Time& startTime); void Stop(); \/\/ Timer handler. void HandleTimerEvent(tbricks::Timer & timer) override; \/\/ PositionRetriever handler void HandleError(const tbricks::String& error) override; void HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions) override; private: IHandler& m_callback; tbricks::Timer m_scheduledTimer; tbricks::PortfolioIdentifier m_portfolioId; tbricks::Integer<fim-suffix>PositionReverser m_positionReverser; }; class ReversalManager::IHandler { public: virtual<fim-middle>m_priceSource; PositionRetriever m_positionRetriever;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::CalculatedInstrumentValues::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n<fim-suffix><fim-middle>    explicit InstrumentManager(IHandler& handler);\n    ~InstrumentManager() noexcept override;\n    void Start();\n    void Stop();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void<fim-suffix>protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats); void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem; tbricks::Identifier m_tickerId; bool<fim-middle>Fail();"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n<fim-suffix><fim-middle>        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS)<fim-suffix>VOLATILITY(wing, Wing) VOLATILITY(custom,<fim-middle>VOLATILITY(svi, SVI)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public<fim-suffix>,<fim-middle>tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\" #include \"tbricks_definitions.h\" #include <cstdlib> #include <set> using namespace tbricks; ExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin2::HandlePricingModifyRequest(const PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin2::Calculate(const RequestAndIVIDs & values, const CalculatedValuesRequestFull & request) { m_rows = values; for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, civ_it.GetColumnId(), x); } } else { TBERROR(\"System asked for calculation which the plugin does not support!\"); } } Send(); } void ExampleCalcAppPlugin2::Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x) { CalculatedValueIdentifier calc_id(rowId, columnId); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } bool ExampleCalcAppPlugin2::HandlePartialPricingModifyRequest(const CalculatedValuesRequestUpdate &update) { if (update.GetRowsBegin() != update.GetRowsEnd()) { return false; } for(auto it = update.GetColumnsBegin(), end = update.GetColumnsEnd(); it != end; ++it) { if (it.GetColumnInfo().GetState() == CalculatedValuesRequestUpdate::State::UPDATE) { if( it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; it.GetColumnInfo().GetStrategyParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, it.GetColumnId(), x); }<fim-suffix><fim-middle>} else { TBERROR(\"System asked for calculation which the plugin does not support!\");"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } namespace deribit { using Method = std::pair<DeribitMethod, std::string>; \/\/ Attempt to order by<fim-suffix>{ return { {DeribitMethod::HEARTBEAT,<fim-middle>frequency static std::vector<Method> GetAvailableMethods()"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI)<fim-suffix><fim-middle>VOLATILITY(wing, Wing) VOLATILITY(custom, Custom)"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <third_party\/include\/rapidjson\/document.h>\n#include <optional>\n\nstruct DeribitInstrument {\n    tbricks::String instrument_name;\n    tbricks::String instrument_type;\n    tbricks::String kind;\n    tbricks::String settlement_currency;\n    tbricks::String settlement_period;\n    tbricks::String quote_currency;\n    tbricks::String counter_currency;\n    tbricks::String option_type;  \/\/ \"call\" or \"put\" for options\n    std::optional<tbricks::Double> strike;  \/\/ Only for options\n    tbricks::DateTime expiration_timestamp;\n    tbricks::Double tick_size;\n    tbricks::Double contract_size;\n    tbricks::Boolean is_active;\n\n    static std::optional<DeribitInstrument> FromJson(const rapidjson::Value& value) {\n        DeribitInstrument data;\n        \n        if (!value.HasMember(\"instrument_name\") || !value[\"instrument_name\"].IsString() ||\n            !value.HasMember(\"kind\") || !value[\"kind\"].IsString() ||\n            !value.HasMember(\"settlement_currency\") || !value[\"settlement_currency\"].IsString() ||\n            !value.HasMember(\"counter_currency\") || !value[\"counter_currency\"].IsString() ||\n            !value.HasMember(\"is_active\") || !value[\"is_active\"].IsBool()) {\n            return std::nullopt;\n        }\n\n        data.instrument_name = value[\"instrument_name\"].GetString();\n        data.kind = value[\"kind\"].GetString();\n        data.settlement_currency = value[\"settlement_currency\"].GetString();\n        data.counter_currency = value[\"counter_currency\"].GetString();\n        data.is_active = value[\"is_active\"].GetBool();\n\n        data.instrument_type = value.HasMember(\"instrument_type\") && value[\"instrument_type\"].IsString() \n            ? value[\"instrument_type\"].GetString() : \"\";\n        data.quote_currency = value.HasMember(\"quote_currency\") && value[\"quote_currency\"].IsString()\n            ? value[\"quote_currency\"].GetString() : \"\";\n        data.option_type = value.HasMember(\"option_type\") && value[\"option_type\"].IsString()\n            ? value[\"option_type\"].GetString() : \"\";\n        data.settlement_period = value.HasMember(\"settlement_period\") && value[\"settlement_period\"].IsString()\n                ? value[\"settlement_period\"].GetString() : \"\";\n        \n        if (value.HasMember(\"strike\") && value[\"strike\"].IsNumber()) {\n            data.strike = value[\"strike\"].GetDouble();\n        }\n<fim-suffix><fim-middle>        if (value.HasMember(\"expiration_timestamp\") && value[\"expiration_timestamp\"].IsUint64()) {\n            data.expiration_timestamp = tbricks::DateTime::Create(value[\"expiration_timestamp\"].GetUint64() * 1000);"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"PositionRetriever.h\" #include \"PositionReverser.h\" class ReversalManager : public PositionRetriever::IHandler, public tbricks::ITimerEventHandler { public: class IHandler; ReversalManager(IHandler& callback); ~ReversalManager() = default;<fim-suffix><fim-middle>void Start( const tbricks::PortfolioIdentifier& portfolioId,"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n<fim-suffix><fim-middle>    if (not m_tcp.IsOpen())\n        return;"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t<fim-suffix>double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double GetBid(); double GetAsk(); double<fim-middle>GetTimestamp(); bool IsOpen();"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <><fim-suffix>{ if (val.size() <= 0)<fim-middle>Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbChildOrder : public OrderExecutor, public tbricks::StrategyStream::IHandler, public tbricks::IRequestReplyHandler { public: TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app); ~TbChildOrder(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid,<fim-suffix>protected: \/\/ Stream::IHandler void<fim-middle>const tbricks::Volume& volume, \/\/ negative for sell         const tbricks::PortfolioIdentifier& portfolio) override;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"..\/VolatilityManagerSettings.h\"\n#include \"..\/ImpliedVolatilitySourcesManagerCore.h\"\n#include \"..\/..\/preferences_editor\/tbricks_definitions.h\" \/\/ FIXME: Remove when cp definitions are generated for shared\/system meta (TB-103467)\n#include <shared\/Macros.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/String.h>\n#include <strategy\/Instrument.h>\n#include <strategy\/Definitions.h>\n#include <strategy\/Logger.h>\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n#include <iostream>\n#include <cmath>\n\nconst CalculatedPropertyFilter PreferencesStorage::dummyFilter = CalculatedPropertyFilter::Condition(\n    vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::NE, Integer());\n\nPreferencesStorage::PreferencesStorage() :\n    autoFit(false),\n    autoApplyAutoFit(false),\n    globalAvoidExtraFits(true),\n    globalUnderlyingTradingStatusTracking(true),\n    optionTradingStatusTracking(volatility_manager_settings::DEFAULT_AUTO_FIT_OPTION_TRADING_STATUS_TRACKING),\n    loggingMode(enumerations::VolatilityManagerLoggingModeVerbose),\n    maxAllowedFitRejects(),\n    maturityExcludedFromGlobalActions(false),\n    sendQuotingRecommendations(false),\n    quotingRecommendations(),\n    parallelShift(true),\n    curveShiftUnits(enumerations::VolatilityManagerCurveShiftUnitsVolatility),\n    ATMVolatilityShiftMode(ATM_VolatilityShiftModeShiftSingleATM_Point),\n    includeExoticOptions(volatility_manager_settings::DEFAULT_USE_EXOTIC_OPTIONS_OPTION),\n    autoFetchATMVolatilityPath(false),\n    globalAutoFetchATMVolatilityPath(volatility_manager_settings::DEFAULT_ATM_VOL_PATH_AUTO_FETCH_OPTION),\n    instrumentGroupType(VolatilityManagerInstrumentGroupTypeDerivative),\n    suggestContext(parameter_contexts::VM_Suggest()),\n    trackingAreaType(enumerations::VolatilityManagerTrackingAreaTypeBasedOnAllStrikes),\n    volatilityCurveSafetyCheckEnabled(false),\n    safetyParameterChange(volatility_manager_settings::DEFAULT_SAFETY_PARAMETERS_CHANGES),\n    safetyModelChange(volatility_manager_settings::DEFAULT_SAFETY_MODEL_CHANGES),\n    checkForStaticArbitrage(false),\n    calendarSpreadArbitrageTolerance(volatility_manager_settings::DEFAULT_CALENDAR_SPREAD_ARBITRAGE_TOLERANCE),\n    butterflyArbitrageTolerance(volatility_manager_settings::DEFAULT_BUTTERFLY_ARBITRAGE_TOLERANCE),\n    enableCurveQualityMetrics(false),\n    fitWeighting(FitWeightingInvertedSpread),\n    autocorrectFitWeights(true),\n    fitOnlyATMVol(false),\n    addVirtualBids(volatility_manager_settings::DEFAULT_ADD_VIRTUAL_BIDS),\n    virtualBidRatio(volatility_manager_settings::DEFAULT_VIRTUAL_BID_MULTIPLIER),\n    robustFittingOnWings(false),\n    robustFittingOnWingsStrength(volatility_manager_settings::DEFAULT_ROBUST_FITTING_ON_WINGS_STRENGTH),\n    autoResetSwimRefPriceToATM(false),\n    crossingProcessing(tbricks::enumerations::VolatilityManagerCrossingProcessingSkip),\n    anomalyDetection(false),\n    anomalyDetectionSensitivity(volatility_manager_settings::DEFAULT_ANOMALY_DETECTION_SENSITIVITY),\n    enableAmerican(true),\n    enableATM(true),\n    enableDeepITM(true),\n    enableDeepOTM(true),\n    enableEuropean(true),\n    enableITM(true),\n    enableCashDelivery(true),\n    enableCrossings(true),\n    enableLowBids(true),\n    enablePhysicalDelivery(true),\n    enableSmallDelta(true),\n    enableWideSpreads(true),\n    enableNoSpreads(true),\n    enableOTM(true),\n    enableLowVolumes(true),\n    minimumBidPrice(),\n    minimumVolume(),\n    manuallyToggledPoints(),\n    impliedVolatilitySources(),\n    tradingPhaseProcessing(enumerations::VolatilityManagerTradingPhaseProcessingAllTradingPhases),\n    showExcludedPoints(volatility_manager_settings::DEFAULT_SHOW_EXCLUDED_VOL_POINTS),\n    autocorrectVolatilityChartZooming(true),\n    deltaValueForVerticalLines(volatility_manager_settings::DEFAULT_DELTA_VALUE_FOR_VERTICAL_LINES),\n    showVerticalLinesAtGivenDelta(volatility_manager_settings::DEFAULT_SHOW_VERTICAL_LINES_AT_DELTA),\n    volatilityCurveChartAutoRangePadding(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_PADDING),\n    portfolio(),\n    preserveZooming(volatility_manager_settings::DEFAULT_PRESERVE_ZOOMING_OPTION),\n    distanceBetweenCurvePoints(volatility_manager_settings::CHART_DEFAULT_CURVE_DISTANCE_BETWEEN_DRAWN_POINTS),\n    autoRangeMode(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_MODE),\n    showReferenceVols(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_VOLS),\n    showReferenceCurve(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_CURVE),\n    showBidAskRange(volatility_manager_settings::DEFAULT_SHOW_BID_ASK_RANGE),\n    putCallColors(enumerations::VolatilityManagerPut_DIV_CallColorsDefault),\n    colorScheme(enumerations::VolatilityManagerChartColorSchemePale)\n{\n    Table impliedVolSources;\n    ImpliedVolatilitySourcesManagerCore::SetupTable(impliedVolSources, \/* useTreeNodes = *\/ true);\n    impliedVolatilitySources.SetDefault(impliedVolSources);\n\n    m_scopeLevelAnchoredPreferences = {\n        tree_node_parameters::VolatilityManagerAutomaticFit(),\n        tree_node_parameters::VolatilityManagerAutoApplyAutoFit(),\n        tree_node_parameters::VolatilityManagerAutoResetSwimReferencePrice(),\n        tree_node_parameters::VolatilityManagerMaturityExcluded(),\n        tree_node_parameters::VolatilityManagerManuallyToggledVolatilityPoints()\n    };\n\n    CalculatedPropertyFilter defaultInstrumentFilter = CalculatedPropertyFilter::Condition(\n        vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::EQ, Enumeration(Instrument::CFI_Variant::Undefined));\n\n    instrumentFilter.SetDefault(defaultInstrumentFilter);\n}\n\nPreferencesStorage::~PreferencesStorage()\n{}\n\nvoid PreferencesStorage::Clear()\n{\n    autoFit.ClearValue();\n    autoApplyAutoFit.ClearValue();\n    globalAvoidExtraFits.ClearValue();\n    globalUnderlyingTradingStatusTracking.ClearValue();\n    optionTradingStatusTracking.ClearValue();\n    loggingMode.ClearValue();\n    maxAllowedFitRejects.ClearValue();\n    maturityExcludedFromGlobalActions.ClearValue();\n    sendQuotingRecommendations.ClearValue();\n    quotingRecommendations.ClearValue();\n\n    parallelShift.ClearValue();\n    curveShiftUnits.ClearValue();\n    ATMVolatilityShiftMode.ClearValue();\n    includeExoticOptions.ClearValue();\n    autoFetchATMVolatilityPath.ClearValue();\n    globalAutoFetchATMVolatilityPath.ClearValue();\n    instrumentGroupType.ClearValue();\n    suggestContext.ClearValue();\n    trackingAreaType.ClearValue();\n    volatilityCurveSafetyCheckEnabled.ClearValue();\n    safetyParameterChange.ClearValue();\n    safetyModelChange.ClearValue();\n    checkForStaticArbitrage.ClearValue();\n    calendarSpreadArbitrageTolerance.ClearValue();\n    butterflyArbitrageTolerance.ClearValue();\n    enableCurveQualityMetrics.ClearValue();\n\n    fitWeighting.ClearValue();\n    autocorrectFitWeights.ClearValue();\n    fitOnlyATMVol.ClearValue();\n    addVirtualBids.ClearValue();\n    virtualBidRatio.ClearValue();\n    robustFittingOnWings.ClearValue();\n    robustFittingOnWingsStrength.ClearValue();\n    autoResetSwimRefPriceToATM.ClearValue();\n    crossingProcessing.ClearValue();\n    anomalyDetection.ClearValue();\n    anomalyDetectionSensitivity.ClearValue();\n\n    enableAmerican.ClearValue();\n    enableATM.ClearValue();\n    enableDeepITM.ClearValue();\n    enableDeepOTM.ClearValue();\n    enableEuropean.ClearValue();\n    enableITM.ClearValue();\n    enableCashDelivery.ClearValue();\n    enableCrossings.ClearValue();\n    enableLowBids.ClearValue();\n    enablePhysicalDelivery.ClearValue();\n    enableSmallDelta.ClearValue();\n    enableWideSpreads.ClearValue();\n    enableNoSpreads.ClearValue();\n    enableOTM.ClearValue();\n    enableLowVolumes.ClearValue();\n    minimumBidPrice.ClearValue();\n    minimumVolume.ClearValue();\n    manuallyToggledPoints.ClearValue();\n    impliedVolatilitySources.ClearValue();\n    instrumentFilter.ClearValue();\n    tradingPhaseProcessing.ClearValue();\n\n<fim-suffix><fim-middle>    showExcludedPoints.ClearValue();\n    autocorrectVolatilityChartZooming.ClearValue();\n    deltaValueForVerticalLines.ClearValue();"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\" #include \"ConstantVolatility.h\"<fim-suffix>#include \"ClampedCubicSpline.h\" #include<fim-middle>#include \"StochasticVolatilityInspired.h\""}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID)\n<fim-suffix><fim-middle>{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler, visualization::Grid& instrumentsGrid)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n    , m_tasksDone(false)\n    , m_instrumentsGrid(instrumentsGrid)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n    m_tasksDone = false;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::OpenCIVStream()\n{\n    CalculatedInstrumentValues::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrumentVenueIdentification(InstrumentVenueIdentification(instId));\n    }\n    options.AddValue(calculated_values::UnderlyingPrice());\n\n    auto throttle = MaximumUpdateTimeThrottle(Duration::Seconds(5));\n    options.SetThrottle(throttle);\n    m_calculatedValuesStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened calculated instrument values stream : \" << m_calculatedValuesStream.GetIdentifier() << \" with options : \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n        OpenCIVStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        m_instrumentCache[instrument.GetIdentifier()].instrument = instrument;\n\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()].maturityDate = tbMaturityDate;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_instrumentCache[instrumentID].underlyingInstrument = underlyingId;\n    }\n}\n\nvoid InstrumentManager::HandleCalculatedInstrumentValues(const StreamIdentifier& streamId,\n                                                         const CalculatedInstrumentValues::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamId);\n    TBDUMP(update);\n\n    if (streamId != m_calculatedValuesStream.GetIdentifier())\n<fim-suffix><fim-middle>    {\n        TBWARNING(__func__ << \": update for unknown CV stream \" << streamId << \" = \" << update);\n        return;\n    }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class InstrumentEnricherPlugin : public tbricks::Strategy<fim-suffix>\/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest()<fim-middle>{ public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Reset(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Fail(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update) { TBDEBUG(__func__ << \": \" << stream); TBDUMP(update); auto model_opt = GetModel(stream); if<fim-suffix>model->HandleDistributedValuesUpdate(update); } else { TBDEBUG(\"No Deribit model associated with stream: \" << stream); } } std::optional<DeribitModel<fim-middle>(model_opt) { auto * model = *model_opt;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n<fim-suffix><fim-middle>std::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/String.h> #include <strategy\/type\/Volume.h> namespace execution { struct Stats { tbricks::Volume bought; tbricks::Volume sold; tbricks::Double valueBought; tbricks::Double valueSold; }; enum class OrderExecutorType { ORDER_MANAGER, CHILD_ORDER, ORDER_MINION }; class IExecutionHandler<fim-suffix>virtual void AllDone(const Stats& stats) = 0; virtual void PanicStop(const tbricks::String& msg) = 0; };<fim-middle>{ public: ~IExecutionHandler() = default;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return<fim-suffix>} } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json)<fim-middle>\"www.deribit.com\"; default: return {};"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n    Binary_ostream() { }\n    void close()\n<fim-suffix><fim-middle>    {\n        m_data.Clear();\n    }\n    const tbricks::Binary & GetBinary()"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_plugInStatusDescription.Clear();\n        m_timerController.Start();\n    }\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::Stop()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsPaused())\n    {\n        TBDEBUG(\"Already stopped\");\n        return;\n    }\n\n    if (m_timerController.IsActive())\n    {\n        m_timerController.Stop();\n    }\n    m_instrumentManager.Stop();\n\n    Strategy::SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::ImportNow()\n{\n    TBDEBUG(__func__);\n    m_plugInStatusDescription.Clear();\n    m_instrumentManager.Start();\n}\n\nvoid InstrumentEnricherPlugin::HandleImportComplete(const String& status)\n{\n    TBDEBUG(__func__ << \" : \" << status);\n    m_plugInStatusDescription = status + \" at \" + DateTime::Now().ToString();\n<fim-suffix><fim-middle>    if (not m_timerController.IsActive())\n    {\n        Stop();\n    }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status); ~PositionsData(); void Stop(); public: using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>; const Data& GetData() const { return m_data; } protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ CalculatedPropertiesTable::Stream::IHandler void HandleCalculatedProperties(const tbricks::StreamIdentifier & stream_id, const tbricks::CalculatedPropertiesTable::Update & update) final;<fim-suffix><fim-middle>private:"}
{"content":"<fim-prefix>#include \"TbChildOrder.h\" using namespace tbricks; namespace execution { TbChildOrder::TbChildOrder(IExecutionHandler& handler, Strategy& app) : OrderExecutor(handler) , m_app(app) , m_stream(*this) { StrategyStream::Options opts; opts.SetFilter(StrategyByParentFilter(app.GetIdentifier())); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, opts, StrategyStream::ToStrategyEngine); TBDEBUG(__func__ << \" opened stream with options: \" << opts); } TbChildOrder::~TbChildOrder() { m_stream.Close(); DeleteOrders(); } void TbChildOrder::DeleteOrders() { TBDEBUG(__func__); for (const auto& [ivid,childId] : m_childMap) { if (m_childData[childId].GetState().IsDeleted()) { \/\/ already deleted continue; } Strategy::SendDeleteRequest(childId); TBDUMP(\"Sent deletion for \" << childId << \" [\" << ivid << \"]\"); } } void TbChildOrder::CreateOrder( const InstrumentVenueIdentification& ivid, const Volume& volume, const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio); StrategyOptions opts{plug_ins::Order()}; \/\/ very few app definitions in this namespace StrategyAttributes attrs; attrs.SetExtraData(m_app.GetExtraData()); opts.SetAttributes(attrs); StrategyParameters params; params.SetParameter(strategy_parameters::Portfolio(), portfolio); params.SetParameter(strategy_parameters::ActiveVolume(), volume.Abs()); params.SetParameter(strategy_parameters::Instrument(), ivid.GetInstrumentIdentifier()); params.SetParameter(strategy_parameters::Venue(), ivid.GetVenue()); params.SetParameter(strategy_parameters::MIC(), ivid.GetMIC()); if (volume < 0.0) { params.SetParameter(strategy_parameters::Side(), Side{Side::SELL}); } else { params.SetParameter(strategy_parameters::Side(), Side{Side::BUY}); } auto res = Strategy::SendCreateRequest(opts, params, *this); TBDEBUG(\"Sent creation request for child \" << res.GetStrategyIdentifier()); TBDUMP(opts); TBDUMP(params); m_childMap[ivid] = res.GetStrategyIdentifier(); m_requests[res.GetRequestIdentifier()] = res.GetStrategyIdentifier(); } void TbChildOrder::HandleStreamOpen(const StreamIdentifier& stream) { TBDEBUG(__func__ << \" : \" << stream); } void TbChildOrder::HandleStreamStale(const StreamIdentifier& stream) { TBWARNING(__func__<fim-suffix>} void TbChildOrder::HandleStreamFailed(const StreamIdentifier& stream) { TBERROR(__func__ << \" : \" << stream); m_handler.PanicStop(\"Strategy stream failed\"); } void TbChildOrder::HandleSnapshotEnd(const StreamIdentifier& stream) { TBDEBUG(__func__ << \" : \" << stream); } void TbChildOrder::HandleStrategyUpdate(const StreamIdentifier & stream, const StrategyUpdate & update) { TBDEBUG(__func__ << \" : \" << update); auto id<fim-middle><< \" : \" << stream);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment,<fim-suffix><fim-middle>text, 130=one fragment, binary, 136=close connection.     \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information."}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VizualizationApp methods void HandleStrategyViewCreate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleStrategyViewUpdate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleStrategyViewDelete( tbricks::visualization::models::AppViewModel& viewModel) final; void HandleGridViewCreate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleGridViewUpdate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleGridViewDelete(tbricks::visualization::models::GridViewModel& viewModel) final; \/\/ ReversalManager::IHandler methods void HandleError(const tbricks::String& error)<fim-suffix>private: ReversalManager m_manager; \/\/ app parameters tbricks::PortfolioIdentifierParameter<fim-middle>final; void HandlePositionsReversed() final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier><fim-suffix><fim-middle>ExtractVIID(const tbricks::Instrument & instrument);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); }<fim-suffix><fim-middle>const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); }"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType)<fim-suffix>return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>();<fim-middle>{ switch(volModelType) { case VolatilityModelWing:"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <><fim-suffix>{ int size = 0; istm.read(size); if (size <= 0) return istm;<fim-middle>Binary_istream & operator>>(Binary_istream & istm, std::string & val)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void<fim-suffix><fim-middle>HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n<fim-suffix><fim-middle>        return {};\n    }\n}"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\" #include \"PricingPlugin.h\" #include \"volatility\/CustomVolatilityModel.h\" #include \"shared\/volatility\/InterpolatedVolatilityModel.h\" #include <utility> using namespace tbricks; VolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin , const StreamSettingsPtr & stream_settings_ptr , const InstrumentGroupIdentifier & group , const DateTime & maturity_date) : m_plugin(plugin) , m_maturity_date(maturity_date) , m_group(group) , m_stream_settings_ptr(stream_settings_ptr) { PDUMPN(\"Create volatility curve handler\"); m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true); if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) { HandleVolatilityGroupParameters(); } } VolatilityCurveHandler::~VolatilityCurveHandler() { m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider); m_parameters_provider = nullptr; } bool VolatilityCurveHandler::IsSnapshotDone() const { if (!m_parameters_provider) return true; return m_parameters_provider->IsSnapshotDone(); } void VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber) { if (!subscriber) return; m_subscribers.push_back(subscriber); } void VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber) { auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber); if (found != m_subscribers.end()) { std::swap(*found, m_subscribers.back()); m_subscribers.pop_back(); } } bool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides) { if (!m_parameters_provider) return false; return m_parameters_provider->UpdateOverrides(overrides); } std::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source) { if (!m_volatility_model) return {}; if (source.Empty()) return m_volatility_model; auto & weak = m_volatility_models[source]; auto ret = weak.lock(); if (ret) return ret; ret.reset(m_volatility_model->Clone()); weak = ret; return ret; } std::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source) { if (!m_volatility_model) return {}; if (m_volatility_model->IsInterpolated()) return {}; if (source.Empty()) return m_volatility_model; auto & weak = m_volatility_models[source]; auto ret = weak.lock(); if (ret) return ret; ret.reset(m_volatility_model->Clone()); weak = ret; return ret; } bool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group , const InstrumentGroupAggregateParameters::Update & update) { return HandleVolatilityGroupParameters(&update); } void VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group) { PDEBUGN(\"Handle volatility group parameters snapshot done\"); for (auto subscriber : m_subscribers) { subscriber->HandleVolatilityCurveHandlerSnapshot(m_group); } } void VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType() { PDEBUGN(\"VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType\"); if (SwitchVolatilityModel()) { for (auto subscriber : m_subscribers) { subscriber->HandleVolatilityCurveHandlerUpdate(m_group); } } } bool VolatilityCurveHandler::HandleVolatilityGroupParameters(const InstrumentGroupAggregateParameters::Update * update) { PDEBUGN(\"Handle volatility group parameters\"); if (update) { PDUMPN(\"Update = \" << *update); } bool changed = false; changed |= SwitchVolatilityModel(); if (!changed && m_volatility_model) { if (update) { changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*update, *m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date); } else { changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date); } } if (changed) { m_volatility_models.clear(); } for (auto subscriber : m_subscribers) { subscriber->HandleVolatilityCurveHandlerUpdate(m_group); } return changed; } bool VolatilityCurveHandler::SwitchVolatilityModel() { PDEBUGN(\"Switch volatility model\"); if (!m_parameters_provider) return false; const Integer & type = m_parameters_provider->GetVolatilityModelType(); PDEBUGN(\"New volatility model type \" << type); const VolatilitySurfaceContainer * container<fim-suffix><fim-middle>= m_parameters_provider->GetVolatilitySurfaceContainer();"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n\ntemplate <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);\n}\n\ntemplate <>\nBinary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)\n<fim-suffix><fim-middle>{\n    if (val.size() <= 0)\n        return ostm;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream &<fim-suffix>{<fim-middle>istm, std::string & val)"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat<fim-suffix><fim-middle>: public JsonReply {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); }<fim-suffix>private: IHandler& m_handler; tbricks::Timer m_startTimerEvent; tbricks::DateTime m_startTime; tbricks::Duration<fim-middle>const tbricks::DateTime& GetTimerLastFired() const { return m_timerLastFired; }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice &<fim-suffix><fim-middle>bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor:<fim-suffix>TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction);<fim-middle>\" << reason);"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider<fim-suffix>void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const<fim-middle>void HandleSubscribe(tbricks::MarketDataItem & item) override;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to; return std::move(sstrm).str(); } public: BadPreferencesStorageCast(const PreferencesStorageKind from, const PreferencesStorageKind to) : Exception(PreferenceKindsToString(from, to)) {} }; template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage); template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage); #define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\ { \\ if (TB_UNLIKELY(!pPreferencesStorage)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY((pPreferencesStorage->GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\ throw BadPreferencesStorageCast(pPreferencesStorage->GetKind(), kind); \\ } \\ \\ return reinterpret_cast<specifier type*>(pPreferencesStorage); \\ } #define PREFERENCES_STORAGE_REF_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type & pref_storage_cast(specifier PreferencesStorage & preferencesStorage) \\ { \\ if (TB_UNLIKELY((preferencesStorage.GetKind() != kind)<fim-suffix><fim-middle>&& (kind != PreferencesStorageKind::Common))) { \\"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear(); m_wasStreamStale = false; TBDEBUG(__func__); if (m_positionStream.IsOpen()) { m_positionStream.Close(); } m_positionStream.Open( Stream::SNAPSHOT, portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, AnyPositionFilter()); } void PositionRetriever::Stop() { m_positionStream.Close(); m_positions.clear(); } void PositionRetriever::HandleStreamOpen(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { if (not m_wasStreamStale) { TBDEBUG(__func__ << \" Stream opened: \" << stream_id); } else { TBNOTICE(\"Stream reconnected\"); m_wasStreamStale = false; } } else { TBDEBUG(__func__ << \" Unknown opened stream: \" << stream_id); } } void PositionRetriever::HandleStreamStale(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBWARNING(__func__ << \" Stream became stale: \" << stream_id); m_wasStreamStale = true; } else { TBWARNING(__func__ << \" Unknown stale stream: \" << stream_id); } } void PositionRetriever::HandleStreamFailed(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { std::stringstream error; error << \"Stream failed: \" << stream_id; m_callback.HandleError(error.str()); } else { TBWARNING(__func__ << \" Unknown failed stream: \" << stream_id); } } void PositionRetriever::HandleSnapshotEnd(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBDEBUG(__func__ << \" Snapshot end received on stream: \" << stream_id); m_callback.HandlePositions(m_positions); } else { TBDEBUG(__func__ << \" Received snapshot end on unknown<fim-suffix>} } void PositionRetriever::HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) { TBDEBUG(__func__ << \" \" << stream_id); TBDUMP(position); if (m_positionStream.GetIdentifier() == stream_id) { m_positions.emplace(position.GetIdentifier(), position); } else { TBDEBUG(__func__ << \" Received position on unknown stream: \" << stream_id);<fim-middle>stream: \" << stream_id);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n<fim-suffix><fim-middle>private:\n    Error err;\n    bool isTest = true;\n    bool isError = false;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default;<fim-suffix><fim-middle>JsonCall(const std::string_view id, DeribitMethod method);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n<fim-suffix><fim-middle>    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty())<fim-suffix><fim-middle>{ FailWithReason(\"Missing client secret\");"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/order_minion\/OrderMinionController.h\" #include \"shared\/order_minion\/OrderMinionRequest.h\" namespace execution { class<fim-suffix><fim-middle>TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status<fim-suffix>} else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString()<fim-middle>= \"Timer started, expires \" + m_startTime.ToString();"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; }<fim-suffix>{ out = m_data;<fim-middle>template <> void Binary_istream::read(tbricks::Binary & out)"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin2 : public tbricks::Pricing { public: ExampleCalcAppPlugin2(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; bool HandlePartialPricingModifyRequest(const tbricks::CalculatedValuesRequestUpdate &update) override; private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override {}; void HandleRunRequest() override {}; void HandlePauseRequest() override {}; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override {}; void HandleValidateRequest(tbricks::ValidationContext &context) override {}; void Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request); void<fim-suffix>RequestAndIVIDs m_rows;<fim-middle>Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x);"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n<fim-suffix><fim-middle>{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <optional> struct DeribitInstrument { tbricks::String instrument_name; tbricks::String instrument_type; tbricks::String kind; tbricks::String settlement_currency; tbricks::String settlement_period; tbricks::String quote_currency; tbricks::String counter_currency; tbricks::String option_type; \/\/ \"call\" or \"put\" for options std::optional<tbricks::Double> strike; \/\/ Only for options<fim-suffix><fim-middle>tbricks::DateTime expiration_timestamp; tbricks::Double tick_size;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item,<fim-suffix>~DeribitModel()<fim-middle>tbricks::DistributedValues::Stream::IHandler & handler);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val);<fim-suffix>void SetRefreshToken(const std::string_view val);<fim-middle>void SetClientSecret(const std::string_view val);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void<fim-suffix><fim-middle>Stop();"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType) { return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType)); } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return<fim-suffix>} std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type)<fim-middle>defs; #undef VOLATILITY_MODEL_WRAP }"}
{"content":"<fim-prefix>#pragma once<fim-suffix><fim-middle>#include <strategy\/type\/String.h>"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95; const int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally; const double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE<fim-suffix><fim-middle>= 1.0; const double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1;"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n\n    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;\n\n    bool ParallelVerticalShift() const;\n<fim-suffix><fim-middle>    const InstrumentGroup & GetCurrentProductGroup() const { return m_instrumentGroup.GetInstrumentGroup(); }\n    const InstrumentGroup & GetReferenceInstrumentGroup() const { return m_refInstrumentGroup.GetInstrumentGroup(); }"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size<fim-suffix>return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream<fim-middle><= 0)"}
{"content":"<fim-prefix>#pragma once\n\n#include <string_view>\n#include <strategy\/type\/String.h>\n\nnamespace deribit {\n\nstruct RapidDocument;\n\nclass UpdateData\n{\npublic:\n    UpdateData();\n    virtual ~UpdateData();\n\n    std::string_view ToString();\n    void Parse(const tbricks::String& str);\n\nprotected:\n    RapidDocument* m_doc;\n};\n\nclass ticker_update : public UpdateData\n{\npublic:\n    ticker_update(const tbricks::String& str);\n\n    std::string_view GetInstrumentName();\n\n    int64_t GetTimestamp();\n    bool IsOpen();\n<fim-suffix><fim-middle>    double GetSettlementPrice();\n    double GetOpenInterest();\n    double GetMinPrice();\n    double GetMaxPrice();"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include <strategy\/type\/Binary.h>\n#include <cstring>"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n<fim-suffix><fim-middle>    {\n        long timeout_request = 0;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override;<fim-suffix>void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification<fim-middle>void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n<fim-suffix><fim-middle>{\n    return jrpcMethod;\n}"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n\nprivate:\n    std::string_view type;\n};\n\nclass subscriptions : public JsonCall\n{\npublic:\n    subscriptions(const std::string_view id, DeribitMethod method);\n\n    void AddChannel(const std::string & channel);\n};\n\nclass subscriptions_reply : public JsonReply\n{\npublic:\n    subscriptions_reply(JsonReply && base);\n\n    std::vector<std::string_view> GetChannels() const;\n};\n\nclass subscription_update : public JsonReply\n<fim-suffix><fim-middle>{\npublic:\n    subscription_update(JsonReply && base);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { \/\/ Here is where we would open the DistributedValues::Stream } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update<fim-suffix><fim-middle>& update)"}
{"content":"<fim-prefix>#include \"Values.h\"\n#include \"ValuesRequest.h\"\n\nvoid ImpliedValue::Clear()\n{\n    implied_volatility.Clear();\n}\n\nstd::ostream & ImpliedValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"] \" << implied_volatility;\n    return strm;\n}\n\nFairPriceValue & FairPriceValue::operator += (const FairPriceValue & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.fair_price.Empty()) {\n        fair_price += fair_price_value.fair_price;\n    } else if (fair_price_value.fair_price.HasError()) {\n        fair_price.SetError(fair_price_value.fair_price.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue & FairPriceValue::operator += (const Double & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.Empty()) {\n        fair_price += fair_price_value;\n    } else if (fair_price_value.HasError()) {\n        fair_price.SetError(fair_price_value.GetError());\n<fim-suffix><fim-middle>    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n<fim-suffix><fim-middle>{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) {<fim-suffix><fim-middle>state = s->value.GetString();"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm,<fim-suffix>GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope)<fim-middle>Double, OpeningCharm)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; void HandleInstrumentDownload(const rapidjson::Value & instruments) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument); \/\/ app parameters tbricks::StringParameter m_clientID; tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint; std::unique_ptr<DeribitClient> m_client; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::DistributedValuesRequest> m_requestMap; tbricks::SparseHash<tbricks::Identifier, tbricks::DistributedValuesRequest> m_pendingRequests; tbricks::Set<tbricks::Identifier> m_supported_values; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::VenueInstrumentIdentifier> m_viidMap; tbricks::SparseHash<tbricks::String, tbricks::InstrumentIdentifier> m_symbolMap;<fim-suffix><fim-middle>tbricks::VenueIdentifier m_venueId {\"329eb436-9c38-11eb-b940-67d0e3a03b89\"};"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (m_volatility_model->IsInterpolated()) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group\n    , const InstrumentGroupAggregateParameters::Update & update)\n{\n    return HandleVolatilityGroupParameters(&update);\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group)\n{\n    PDEBUGN(\"Handle volatility group parameters snapshot done\");\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerSnapshot(m_group);\n    }\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType()\n{\n    PDEBUGN(\"VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType\");\n    if (SwitchVolatilityModel()) {\n        for (auto subscriber : m_subscribers) {\n            subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n        }\n    }\n}\n<fim-suffix><fim-middle>bool VolatilityCurveHandler::HandleVolatilityGroupParameters(const InstrumentGroupAggregateParameters::Update * update)\n{\n    PDEBUGN(\"Handle volatility group parameters\");\n    if (update) {"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitModel.h\"\n#include <shared\/API.h>\n\nclass DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler\n{\npublic:\n    DeribitMdp();\n    ~DeribitMdp() noexcept override = default;\n\nprotected:\n    void HandleSubscribe(tbricks::MarketDataItem & item) override;\n    void HandleUnsubscribe(tbricks::MarketDataItem & item) override;\n    void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override;\n    void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override;\n    bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override;\n    void GetDiagnostics(tbricks::Diagnostics & diagnostics) override;\n\n    void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamStale(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;\n\n<fim-suffix><fim-middle>    void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if<fim-suffix>istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out)<fim-middle>(size <= 0) return istm;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument<fim-suffix>\/\/ app parameters tbricks::StringParameter m_clientID; tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint; std::unique_ptr<DeribitClient> m_client;<fim-middle>& instrument);"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi,<fim-suffix><fim-middle>SVI) VOLATILITY(wing, Wing)"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using<fim-suffix>DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" <<<fim-middle>namespace tbricks;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ <<<fim-suffix><fim-middle>\": id=\" << id << \", value=\" << value);"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;\n    }\n}\n\nvoid InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n    {\n        const int total = m_instrumentCache.size();\n<fim-suffix><fim-middle>        std::stringstream result;\n        result << \"Total instruments = \" << total << \", successful = \" << total - m_failed\n               << \", failed = \" << m_failed;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n<fim-suffix><fim-middle>class public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindPreferencesStorageByScopeDefinition(const ScopeDefinition & scope) const\n<fim-suffix><fim-middle>{\n    switch (scope.type)\n    {\n    case enumerations::VolatilityManagerPersistentPreferencesScopeUser:"}
{"content":"<fim-prefix>#include \"shared\/API.h\"\n#include \"InstrumentPricing.h\"\n#include \"util\/Log.h\"\n#include \"PricingPlugin.h\"\n#include \"InstrumentFilterSubscriber.h\"\n#include \"Underlying.h\"\n#include \"payments\/DividendInstrument.h\"\n#include \"payments\/PaymentInstrument.h\"\n#include \"UnderlyingComponentsManager.h\"\n#include \"price_providers\/BarrierInstrument.h\"\n#include \"models\/ModelCalculatorFactory.h\"\n#include \"models\/TurboOptionModelCalculator.h\"\n#include \"models\/TurboOptionWithDividendsModelCalculator.h\"\n#include \"models\/MiniFutureModelCalculator.h\"\n#include \"models\/CallableBullBearContractModelCalculator.h\"\n#include \"models\/CBBCWithDividendsModelCalculator.h\"\n#include \"models\/CBBCBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/CBBCWithDividendsBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/BondModelCalculator.h\"\n#include \"models\/EquityReturnModelCalculator.h\"\n#include \"price_providers\/PriceProviderEmpty.h\"\n#include \"price_providers\/PriceProviderSingle.h\"\n#include \"price_providers\/PriceProviderQuote.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/interest_rate\/YieldCurveWrapper.h\"\n#include \"UserPreferencesSubscriber.h\"\n#include \"time\/TimeOptions.h\"\n#include \"time\/TimeValues.h\"\n#include \"time\/VolatilityTimeWeights.h\"\n#include \"time\/CalendarUtils.h\"\n#include <cmath>\n#include <algorithm>\n#include <type_traits>\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include \"shared\/combination\/ICombinationModel.h\"\n#include \"shared\/Macros.h\"\n#include <shared\/instrument_types\/InstrumentTypes.h>\n#include <shared\/metaprogramming\/Defer.hpp>\n\n#include \"util\/Tokens.h\"\n\n#include \"models\/EquityModelCalculator.h\"\n#include \"models\/ExternalModelCalculator.h\"\n#include \"models\/ExternalTaylorModelCalculator.h\"\n#include \"models\/ExternalModelDistributionCalculator.h\"\n\n#include \"models\/PricingCombinationModel.h\"\n#include \"models\/util\/MiscCalculations.h\"\n#include \"models\/util\/DividendsUtil.h\"\n\n#include \"shared\/datetime_helpers\/DateTimeHelpers.h\"\n#include \"shared\/smart_pointers\/IntrusiveWeakPointer.hpp\"\n\n#include <shared\/time\/TimeParser.h>\n#include <shared\/StateRestorer.hpp>\n\n#include \"tbricks_definitions.h\"\n#include \"shared\/pricing\/tbricks_constants.h\"\n\nusing namespace tbricks;\n\nstd::ostream & operator<<(std::ostream & os, const RelativeValuationTime val_time)\n{\n    using RVT = RelativeValuationTime;\n    switch (val_time) {\n    case RVT::NOW:                 return os << \"Now\";\n    case RVT::TODAY_CLOSE:         return os << \"Today close\";\n    case RVT::NEXT_OPEN:           return os << \"Next open\";\n    case RVT::NEXT_DAY:            return os << \"Next day\";\n    default:                       return os << \"Unrecognized valuation time\";\n    }\n}\n\nInstrumentPricing::InstrumentPricing(PricingPlugin & plugin, const InstrumentIdentification & id,\n                                     const InstrumentVenueIdentification & ivid,\n                                     std::shared_ptr<SnapshotToken> snapshot_token,\n                                     std::shared_ptr<ModificationToken> modification_token,\n                                     const LegSettingsPtr & leg_settings) :\n    m_id(id),\n    m_plugin(plugin),\n    m_ivid(new InstrumentVenueIdentification(ivid)),\n    m_leg_settings(leg_settings),\n    m_instrument(new Instrument()),\n    m_override_prices(new IPriceProvider::OverridePriceContainer()),\n    m_q(GetCalculationSettings().GetYield()),\n    m_today_values(new TimeValues()),\n    m_plugin_modify_version(plugin.GetPluginModifyVersion()),\n    m_snapshot_token(snapshot_token),\n    m_modification_token(modification_token)\n{\n    PDEBUGN(\"Create instrument pricing: \" << *m_ivid << \" row id = \" << GetRowIdentifier());\n\n    m_calculated_values_pool.reset(new CalculatedInstrumentValuesPool(plugin, *this));\n    PDEBUGN(\"Instrument size is \" << sizeof(*this) << \", pool size is \" << sizeof(*m_calculated_values_pool));\n\n    if (m_ivid->GetInstrumentIdentifier().Empty()) {\n        ResetSnapshotTokens();\n        m_snapshot_done = true;\n        return;\n    }\n\n    if (m_calculated_values_pool->GetValuesRequest().TimeGreeksIsActive()) {\n        m_today_close_values.reset(new TimeValues());\n        m_next_trading_open_values.reset(new TimeValues());\n        m_next_trading_day_values.reset(new TimeValues());\n    }\n\n    InitializeDefaultParameters();\n    InitializeCalculatedValues();\n\n    UpdateOverrides(m_plugin.GetFullCalculatedValuesRequest().GetOverrides());\n\n    UpdateExpirationTime();\n\n    RetainTimer();\n\n    InstrumentSubscriptionIdentification instrument_subscription_id(m_ivid->GetInstrumentIdentifier(),\n                                                                    GetStreamSettingsPtr()->GetParametersDateTime());\n    m_instrument_stream = m_plugin.GetStreamManager().SubscribeForInstrument(instrument_subscription_id, this);\n\n    InstrumentAggregateParameters::Stream::Options ip_options;\n\n    pricing::StreamOptionsCache::IAPSetup iap_setup;\n    if (id.GetStreamSettingsPtr()->GetVolatilityDateTime() == id.GetStreamSettingsPtr()->GetParametersDateTime()) {\n        iap_setup.with_vol = true;\n        ip_options.SetParameterSource(true);\n    } else {\n        InstrumentAggregateParameters::Stream::Options vol_options;\n        vol_options.SetInstrument(m_ivid->GetInstrumentIdentifier());\n        vol_options.SetThrottle(plugin.GetInstrumentParametersThrottle());\n        vol_options.SetParameterDefinitions(m_plugin.GetInstrumentPricingVolatilityDefinitions());\n        vol_options.SetSnapshotDateTime(id.GetStreamSettingsPtr()->GetVolatilityDateTime());\n        vol_options.SetContextIdentifier(id.GetStreamSettingsPtr()->GetParameterContext());\n        vol_options.SetRankingIdentifier(id.GetStreamSettingsPtr()->GetParameterContextRanking());\n        vol_options.SetUserIdentifier(id.GetStreamSettingsPtr()->GetParameterUserIdentifier());\n        vol_options.SetPortfolioIdentifier(id.GetStreamSettingsPtr()->GetParameterPortfolioIdentifier());\n        vol_options.SetParameterSource(true);\n\n        m_volatility_stream.reset(new InstrumentAggregateParameters::Stream(*this));\n        m_volatility_stream->Open(m_plugin.GetSubscriptionType(), vol_options);\n        PDEBUGN(\"Opened volatility parameters stream: \" << *m_volatility_stream);\n        PDUMPN(\"Volatility parameters stream options: \" << vol_options);\n    }\n\n    if (id.GetStreamSettingsPtr()->GetRateDateTime() == id.GetStreamSettingsPtr()->GetParametersDateTime()) {\n        iap_setup.with_rate = true;\n<fim-suffix><fim-middle>    } else {\n        InstrumentAggregateParameters::Stream::Options r_options;\n        r_options.SetInstrument(m_ivid->GetInstrumentIdentifier());\n        r_options.SetThrottle(plugin.GetInstrumentParametersThrottle());"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n\n    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;\n\n    bool ParallelVerticalShift() const;\n\n    const InstrumentGroup & GetCurrentProductGroup() const { return m_instrumentGroup.GetInstrumentGroup(); }\n    const InstrumentGroup & GetReferenceInstrumentGroup() const { return m_refInstrumentGroup.GetInstrumentGroup(); }\n\n    const InstrumentIdentifier & GetFocusInstrumentIdentifier() const { return m_followedInstrumentId.GetInstrumentIdentifier(); }\n    const Integer & GetFocusInstrumentGroupType() const { return m_instrumentGroupType.GetInteger(); }\n<fim-suffix><fim-middle>    bool NoLayoutInterfaceMode() const { return !m_noLayoutInterfaceMode.Empty() && m_noLayoutInterfaceMode.GetBoolean(); }"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void<fim-suffix><fim-middle>DeleteOrders() override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n<fim-suffix><fim-middle>class MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\" class PositionsData; namespace execution { class OrderExecutor; } namespace misc { class AsyncProcessor; } class GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler { public: GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ Strategy methods void HandleDeleteRequest() override; void HandleRunRequest() override; void HandlePauseRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override; void HandleValidateRequest(tbricks::ValidationContext &context) override; void HandleScheduledEvent(tbricks::UserData&& data) override; \/\/ OrderHandler::IHandler void PanicStop(const tbricks::String& msg) override; void AllDone(const execution::Stats& stats) override; private: \/\/ app parameters tbricks::PortfolioIdentifierParameter m_portfolio; tbricks::StringParameter m_statusText; std::unique_ptr<PositionsData> m_positions; std::unique_ptr<execution::OrderExecutor> m_orders; tbricks::EventProcessor m_proc; std::unique_ptr<misc::AsyncProcessor><fim-suffix>execution::OrderExecutorType m_executorType;<fim-middle>m_async;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n<fim-suffix><fim-middle>{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n<fim-suffix><fim-middle>    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false;<fim-suffix><fim-middle>}"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler<fim-suffix>DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override;<fim-middle>{ public:"}
{"content":"<fim-prefix>#include \"..\/shared_config.h\"\n\n#include \"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/tbricks_definitions.h\"\n#include <tests\/shared\/test_utils\/TestUtils.h>\n\n\/**\nThis test is designed for the version of GoFlatPlugin using TbOrderManager (no TbOrderMinion).\nPlease set the hardcoded flag of the app m_useMinions = false\n*\/\n\nvoid Test(TestEngine& te)\n{\n    \/* Test variables *\/\n    VenueInstrumentIdentifier viidOne;\n    Instrument instrumentOne;\n    StrategyIdentifier appId;\n    PortfolioIdentifier portfolioId{go_flat::GetPortfolioId()};\n\n    TBSTATUS(\"Initialize instruments\");\n    {\n        VenueIdentifier venueId = go_flat::GetTestVenueId();\n        viidOne.SetMIC(\"XXXX\");\n        viidOne.SetVenueIdentifier(venueId);\n        viidOne.Add(\"symbol\", \"ONE\");\n        std::vector<VenueInstrumentIdentifier> viids = {viidOne};\n\n        Instrument::Options options;\n        options.SetShortName(\"ONE\");\n        options.SetVenueInstrumentIdentifiers(viids);\n        instrumentOne = te.GetIS().CreateInstrument(options);\n    }\n\n    TBSTATUS(\"Prepare calculated properties\");\n    {\n        CalculatedPropertiesTableUpdate cpUpdate;\n        auto rowId = Uuid::Create();\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Instrument(), instrumentOne.GetIdentifier());\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Venue(), go_flat::GetTestVenueId());\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::MIC(), MIC{\"XXXX\"});\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS(), Volume{100});\n<fim-suffix><fim-middle>        CalculatedPropertiesTable::Stream::Options options;\n        options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {});\n        cpUpdate.SetFilter(options.GetFilter());\n        cpUpdate.SetRowDataType(static_cast<CalculatedPropertiesTable::RowDataType>(5));"}
{"content":"<fim-prefix>#include \"PositionReverser.h\"\n#include \"tbricks_definitions.h\"\n#include <cmath>\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>void PositionReverser::ReversePosition( const Position& position,\n                                        const Price& atPrice)\n{\n    Trade reversedTrade;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n<fim-suffix><fim-middle>    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/VisualizationApp.h> #include <strategy\/visualization\/ViewModelUpdate.h> #include <strategy\/visualization\/ICellValue.h> #include <strategy\/visualization\/Grid.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::VisualizationApp , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VisualizationApp methods void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewDelete(tbricks::visualization::models::AppViewModel & viewModel) final { } void HandleGridViewCreate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } void HandleGridViewUpdate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return<fim-suffix><fim-middle>m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); }"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler {<fim-suffix>~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override; \/\/<fim-middle>public: TbOrderManager(IExecutionHandler& handler);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status); ~PositionsData(); void Stop(); public: using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>; const Data& GetData() const { return m_data; } protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream)<fim-suffix><fim-middle>final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility model types template <class ModelTypePtr> ModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel); template <class ModelTypePtr> ModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel); template <class ModelTypeRef> ModelTypeRef vol_model_cast(volatility::IVolatilityModel & model); template <class ModelTypeRef> ModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model); #define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\ { \\ if (TB_UNLIKELY(!pModel)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt<fim-suffix>throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model*>(pModel); \\ } #define VOL_MODEL_REF_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model & vol_model_cast(specifier volatility::IVolatilityModel & rModel) \\ { \\ if (TB_UNLIKELY(rModel.GetVolatilityModelType() != type)) { \\<fim-middle>to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) NAMESPACE_PATH_GREEK(param_1, Double, Param1, custom::pricing::calculated_values) NAMESPACE_PATH_GREEK(param_2, Double, Param2, custom::pricing::calculated_values) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility,<fim-suffix>IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate,<fim-middle>Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy,<fim-suffix>void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void<fim-middle>public tbricks::IDistributionApp void HandleRunRequest() override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindPreferencesStorageByScopeDefinition(const ScopeDefinition & scope) const\n{\n    switch (scope.type)\n    {\n    case enumerations::VolatilityManagerPersistentPreferencesScopeUser:\n        return (scope.id == m_provider.GetUserIdentifier().GetUuid()) ? m_pUserScopePreferencesStorage.get() : nullptr;\n    case enumerations::VolatilityManagerPersistentPreferencesScopeProduct:\n        return FindProductScopePreferencesStorage(scope.id);\n    case enumerations::VolatilityManagerPersistentPreferencesScopeMaturity:\n        return FindMaturityScopePreferencesStorage(scope.id);\n    default:\n        return nullptr;\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductGroupIdsWithExistingPersistentPreferences(SparseSet<InstrumentGroupIdentifier> & productGroupIds) const\n{\n    productGroupIds.clear();\n    productGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & pair: m_productScopePreferencesStorages) {\n        TB_UNUSED(productGroupIds.insert(pair.first));\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductAndMaturityGroupIdsWithExistingPersistentPreferences(SparseHash<InstrumentGroupIdentifier, SparseSet<InstrumentGroupIdentifier>> & productAndMaturityGroupIds) const\n{\n    productAndMaturityGroupIds.clear();\n    productAndMaturityGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & [productGroupId, _]: m_productScopePreferencesStorages) {\n        TB_UNUSED(productAndMaturityGroupIds[productGroupId]);\n    }\n\n    for(const auto & pair: m_maturityScopePreferencesStoragesByProductGroupId) {\n        const InstrumentGroupIdentifier & productGroupId = pair.first;\n        SparseSet<InstrumentGroupIdentifier> & maturityGroupIds = productAndMaturityGroupIds[productGroupId];\n        maturityGroupIds.insert(pair.second.first);\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetMaturityGroupIdsWithExistingPersistentPreferences(const InstrumentGroupIdentifier & productGroupId,\n                                                                                            SparseSet<InstrumentGroupIdentifier> & maturityGroupIds) const\n<fim-suffix><fim-middle>{\n    if (TB_UNLIKELY(productGroupId.Empty())) {\n        return;\n    }"}
{"content":"<fim-prefix>#include \"shared\/API.h\"\n#include \"InstrumentPricing.h\"\n#include \"util\/Log.h\"\n#include \"PricingPlugin.h\"\n#include \"InstrumentFilterSubscriber.h\"\n#include \"Underlying.h\"\n#include \"payments\/DividendInstrument.h\"\n#include \"payments\/PaymentInstrument.h\"\n#include \"UnderlyingComponentsManager.h\"\n#include \"price_providers\/BarrierInstrument.h\"\n#include \"models\/ModelCalculatorFactory.h\"\n#include \"models\/TurboOptionModelCalculator.h\"\n#include \"models\/TurboOptionWithDividendsModelCalculator.h\"\n#include \"models\/MiniFutureModelCalculator.h\"\n#include \"models\/CallableBullBearContractModelCalculator.h\"\n#include \"models\/CBBCWithDividendsModelCalculator.h\"\n#include \"models\/CBBCBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/CBBCWithDividendsBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/BondModelCalculator.h\"\n#include \"models\/EquityReturnModelCalculator.h\"\n#include \"price_providers\/PriceProviderEmpty.h\"\n#include \"price_providers\/PriceProviderSingle.h\"\n#include \"price_providers\/PriceProviderQuote.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/interest_rate\/YieldCurveWrapper.h\"\n#include \"UserPreferencesSubscriber.h\"\n#include \"time\/TimeOptions.h\"\n#include \"time\/TimeValues.h\"\n#include \"time\/VolatilityTimeWeights.h\"\n#include \"time\/CalendarUtils.h\"\n#include <cmath>\n#include <algorithm>\n#include <type_traits>\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include \"shared\/combination\/ICombinationModel.h\"\n#include \"shared\/Macros.h\"\n#include <shared\/instrument_types\/InstrumentTypes.h>\n#include <shared\/metaprogramming\/Defer.hpp>\n\n#include \"util\/Tokens.h\"\n\n#include \"models\/EquityModelCalculator.h\"\n#include \"models\/ExternalModelCalculator.h\"\n#include \"models\/ExternalTaylorModelCalculator.h\"\n#include \"models\/ExternalModelDistributionCalculator.h\"\n\n#include \"models\/PricingCombinationModel.h\"\n#include \"models\/util\/MiscCalculations.h\"\n#include \"models\/util\/DividendsUtil.h\"\n\n#include \"shared\/datetime_helpers\/DateTimeHelpers.h\"\n#include \"shared\/smart_pointers\/IntrusiveWeakPointer.hpp\"\n\n#include <shared\/time\/TimeParser.h>\n#include <shared\/StateRestorer.hpp>\n\n#include \"tbricks_definitions.h\"\n#include \"shared\/pricing\/tbricks_constants.h\"\n\nusing namespace tbricks;\n\nstd::ostream & operator<<(std::ostream & os, const RelativeValuationTime val_time)\n{\n    using RVT = RelativeValuationTime;\n    switch (val_time) {\n    case RVT::NOW:                 return os << \"Now\";\n    case RVT::TODAY_CLOSE:         return os << \"Today close\";\n    case RVT::NEXT_OPEN:           return os << \"Next open\";\n    case RVT::NEXT_DAY:            return os << \"Next day\";\n    default:                       return os << \"Unrecognized valuation time\";\n    }\n}\n<fim-suffix><fim-middle>InstrumentPricing::InstrumentPricing(PricingPlugin & plugin, const InstrumentIdentification & id,\n                                     const InstrumentVenueIdentification & ivid,\n                                     std::shared_ptr<SnapshotToken> snapshot_token,\n                                     std::shared_ptr<ModificationToken> modification_token,"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) {<fim-suffix>} int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false;<fim-middle>return i->value.GetString(); } return {};"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n    TBDUMP(update);\n}\n\nstd::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream)\n{\n    auto it_streams = m_streams.find(stream);\n    if (it_streams == m_streams.end())\n    {\n        return std::nullopt;\n    }\n\n    return GetModel(it_streams->second);\n}\n\nstd::optional<DeribitModel *> DeribitMdp::GetModel(const InstrumentIdentifier & instrument)\n<fim-suffix><fim-middle>{\n    auto it_models = m_models.find(instrument);\n    if (it_models == m_models.end())\n    {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final {} void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup; } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument; } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate; } private: bool CheckRunningRequirement(); \/\/ app parameters tbricks::InstrumentGroupParameter m_instrumentGroup; tbricks::DateTimeParameter m_maturityDate; tbricks::StringParameter m_plugInStatusDescription; tbricks::InstrumentIdentifierParameter m_underlyingInstrument;<fim-suffix><fim-middle>InstrumentManager m_instrumentManager; };"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \", item = \" << item);\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n<fim-suffix><fim-middle>    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n<fim-suffix><fim-middle>{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {"}
{"content":"<fim-prefix>#pragma once<fim-suffix>#include <map> class PositionRetriever : public tbricks::PositionStream::IHandler { public: class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId); void Stop(); \/\/ Common Stream methods void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final; void HandleStreamStale(const tbricks::StreamIdentifier<fim-middle>#include \"shared\/API.h\""}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new<fim-suffix>{ delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s);<fim-middle>RapidDocument(); } UpdateData::~UpdateData()"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\" #include \"PositionsData.h\" #include \"tbricks_definitions.h\" #include \"execution\/TbOrderManager.h\" #include \"execution\/TbOrderMinion.h\" #include \"execution\/TbChildOrder.h\" #include <AsyncTask.h> #include <memory> using namespace tbricks; namespace sp = go_flat::strategy_parameters; GoFlatPlugin::GoFlatPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_portfolio(sp::Portfolio()) , m_statusText(sp::PlugInStatusDescription()) , m_executorType(execution::OrderExecutorType::ORDER_MANAGER) { TBSTATUS(\"Constructor: created=\" << std::boolalpha <<<fim-suffix>TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); switch (m_executorType) { case execution::OrderExecutorType::ORDER_MANAGER: m_orders = std::make_unique<execution::TbOrderManager>(*this); break; case execution::OrderExecutorType::CHILD_ORDER: m_orders = std::make_unique<execution::TbChildOrder>(*this, *this); break; case execution::OrderExecutorType::ORDER_MINION: m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters); break; } m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier()); } void GoFlatPlugin::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); \/\/m_async->DoAsync(); \/\/ UNCOMMENT if you want to fire minion orders after the async task if (not m_positions or m_positions->GetData().empty()) { SetTransactionFail(\"No positions\", StrategyState::PAUSED); return; } if (m_orders) { if (not m_positions->GetData().empty()) { for (const auto& [ivid, pos] : m_positions->GetData()) { if (m_executorType == execution::OrderExecutorType::ORDER_MINION) { execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get()); minion->MonitorInstrument(ivid); \/\/continue; \/\/ UNCOMMENT if you want to fire minion orders after the async task } TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos); if (not pos.Empty() and pos != 0.0) { \/\/ we want to flatten the position so invert the volume m_orders->CreateOrder(ivid, -pos, m_portfolio.GetPortfolioIdentifier()); } } \/\/ we don't want more position updates from now m_positions->Stop(); SetState(StrategyState::RUNNING); return; } } SetState(StrategyState::PAUSED); } void GoFlatPlugin::HandlePauseRequest() { TBDEBUG(__func__);<fim-middle>reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered());"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n<fim-suffix><fim-middle>class MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include <strategy\/type\/Binary.h>\n#include <cstring>"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public: subscriptions(const std::string_view id, DeribitMethod method); void AddChannel(const std::string & channel); }; class subscriptions_reply : public JsonReply { public: subscriptions_reply(JsonReply && base); std::vector<std::string_view> GetChannels() const; }; class subscription_update : public JsonReply { public: subscription_update(JsonReply && base); std::string_view GetChannel() const; std::string_view GetData(); private:<fim-suffix><fim-middle>rapidjson::StringBuffer dataBuffer;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price,<fim-suffix><fim-middle>0)"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \" + m_frequency.ToString(); } m_handler.HandleTimerControllerUpdate(status, \/*error =*\/ false); } void TimerController::Stop() { TBDEBUG(__func__); m_startTimerEvent.Stop();<fim-suffix><fim-middle>}"}
{"content":"<fim-prefix>#pragma once #include <third_party\/include\/rapidjson\/document.h> #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; virtual void HandleInstrumentDownload(const rapidjson::Value & instruments)<fim-suffix>}; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers,<fim-middle>= 0;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"shared\/API.h\"\n#include \"execution\/IExecutionHandler.h\"\n\nclass PositionsData;\n\nnamespace execution {\nclass OrderExecutor;\n}\n\nnamespace misc {\nclass AsyncProcessor;\n}\nclass GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler\n{\npublic:\n    GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\nprotected:\n    void HandleDeleteRequest() override;\n    void HandleRunRequest() override;\n    void HandlePauseRequest() override;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override;\n    void HandleValidateRequest(tbricks::ValidationContext &context) override;\n\n    void HandleScheduledEvent(tbricks::UserData&& data) override;\n\n    void PanicStop(const tbricks::String& msg) override;\n    void AllDone(const execution::Stats& stats) override;\n<fim-suffix><fim-middle>private:\n    tbricks::PortfolioIdentifierParameter m_portfolio;\n    tbricks::StringParameter m_statusText;"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return<fim-suffix>} } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string> Method; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods()<fim-middle>\"USDT\"; default: return {};"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state =<fim-suffix>{ return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0)<fim-middle>s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0)"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n\nUpdateData::~UpdateData()\n<fim-suffix><fim-middle>{\n    delete (m_doc);\n}"}
{"content":"<fim-prefix>#pragma once #include \"IExecutionHandler.h\" #include \"shared\/API.h\" namespace execution { class OrderExecutor { public: virtual ~OrderExecutor() = default; OrderExecutor(IExecutionHandler& handler) : m_handler(handler) { m_stats.bought = 0.0; m_stats.sold = 0.0; m_stats.valueBought = 0.0; m_stats.valueSold = 0.0; } virtual void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) = 0; virtual void DeleteOrders() = 0; protected: IExecutionHandler& m_handler; Stats m_stats; };<fim-suffix><fim-middle>} \/\/ namespace execution"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler, public InstrumentManager::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest<fim-suffix>\/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; void HandleInstrumentDownload(const rapidjson::Value & instruments) override; \/\/ InstrumentManager::IHandler<fim-middle>& request) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler interface void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId, const tbricks::CalculatedInstrumentValues::Update & update) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final; private: void OpenInstrumentStream(); void OpenIAPStream(); void OpenCIVStream(); void EnrichInstruments(); void ModifyGroup(); void CheckResolutionStatus(); void CheckModificationStatus(); void PopulateGrid();<fim-suffix>tbricks::Instrument instrument; tbricks::DateTime maturityDate; tbricks::InstrumentIdentifier underlyingInstrument; tbricks::Price underlyingPrice; tbricks::RowEntityIdentifier gridRowIdentifier; }; using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, InstrumentDetails>; IHandler& m_handler; tbricks::InstrumentStream m_instrumentStream; tbricks::InstrumentAggregateParameters::Stream m_iapStream; tbricks::CalculatedInstrumentValues::Stream m_calculatedValuesStream; InstrumentCache m_instrumentCache; int<fim-middle>struct InstrumentDetails {"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n    \n    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);\n    \n    if (read > 0 && read < m_buffer.GetSize())\n    {\n        Binary fragment(&static_cast<char *>(m_buffer.GetData())[read], \n                       m_buffer.GetSize() - read);\n        m_buffer = fragment;\n    }\n    else if (read == m_buffer.GetSize())\n    {\n        m_buffer.Clear();\n    }\n}\n\nvoid TbWebsocketClient::HandleStreamOpen(TCPStream & stream)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    UpgradeWs();\n}"}
{"content":"<fim-prefix>#include \"TbOrderManager.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbOrderManager::TbOrderManager(IExecutionHandler& handler)\n: OrderExecutor(handler)\n{\n    TBDEBUG(__func__);\n}\n\nTbOrderManager::~TbOrderManager()\n{\n    TBDEBUG(__func__);\n    if (!m_orderData.empty())\n    {\n        DeleteOrders();\n    }\n}\n\nvoid TbOrderManager::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume, \/\/ negative for sell\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n\n    if (BestPrice bbo; m_md.GetBBO(ivid, bbo))\n    {\n        if (volume < 0.0 and bbo.HasBidPrice())\n<fim-suffix><fim-middle>        {\n            CreateSingleOrder(ivid, volume.Abs(), bbo.GetBidPrice(), Side::SELL, portfolio);\n        }"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel) VOLATILITY_MODEL_WRAP(None,ConstantVolatility)"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template<fim-suffix>{ m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return<fim-middle><> void Binary_ostream::write(const tbricks::Binary & in)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n<fim-suffix><fim-middle>        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream & data); void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length); private:<fim-suffix><fim-middle>IWebsocketHandler & m_handler;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionRetriever : public tbricks::PositionStream::IHandler { public: class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId); void Stop(); \/\/<fim-suffix>void HandleStreamStale(const tbricks::StreamIdentifier &stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier &stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier &stream) final; \/** * PositionStream::IHandler *\/ void HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) final; void HandlePositionInvalidate( const tbricks::StreamIdentifier &<fim-middle>Common Stream methods     void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n<fim-suffix><fim-middle>        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#include \"TimerController.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nTimerController::TimerController(IHandler& handler)\n    : m_handler(handler)\n    , m_startTimerEvent(*this)\n{\n}\n\nvoid TimerController::HandleTimerEvent(Timer& timer)\n{\n    TBDEBUG(__func__ );\n    m_timerLastFired = DateTime::Now();\n<fim-suffix><fim-middle>    if (timer == m_startTimerEvent)\n    {\n        m_handler.HandleTimerEventHit();\n    }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void<fim-suffix>virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size =<fim-middle>HandleError(const tbricks::String & error) = 0;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual<fim-suffix>virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController()<fim-middle>~IHandler() = default;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n<fim-suffix><fim-middle>public:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier &<fim-suffix>private: std::map<tbricks::StreamIdentifier, tbricks::InstrumentIdentifier> m_streams; std::map<tbricks::InstrumentIdentifier, DeribitModel> m_models;<fim-middle>stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n        Channel channel; \/\/ should be always sorted\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\nprivate:\n    void OnLoginReply(SingleTransaction & t);\n    void OnSetHeartbeatReply(SingleTransaction & t);\n    void OnHeartbeat(deribit::JsonReply && incoming);\n    void OnTestReply(SingleTransaction & t);\n\n    void OnSubscribeReply(SingleTransaction & t);\n    void OnSubscriptionUpdate(deribit::JsonReply && incoming);\n\nprivate:\n    SingleTransaction & NewTransaction(const tbricks::Identifier & uuid = tbricks::Uuid::Create());\n\nprotected:\n    void PerformTransaction(SingleTransaction & t);\n<fim-suffix><fim-middle>private:\n    IHandler & m_handler;\n    std::unique_ptr<TbWebsocketClient> m_ws;\n    TbWebsocketClient::Config m_conf;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n\ntemplate <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);\n}\n\ntemplate <>\nBinary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)\n{\n    if (val.size() <= 0)\n        return ostm;\n\n    ostm.write(val.c_str(), val.size());\n\n    return ostm;\n}\n\nBinary_ostream & operator<<(Binary_ostream & ostm, const char * val)\n{\n    int size = std::strlen(val);\n    if (size <= 0)\n        return ostm;\n\n    ostm.write(val, size);\n\n    return ostm;\n}\n<fim-suffix><fim-middle>Binary_ostream & operator<<(Binary_ostream & ostm, const char val)\n{\n    ostm.write(&val, sizeof(char));"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public:<fim-suffix><fim-middle>DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return true; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update) { TBDEBUG(__func__ << \": \" << stream); TBDUMP(update); } std::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream) { auto it_streams = m_streams.find(stream); if (it_streams == m_streams.end()) { return std::nullopt;<fim-suffix><fim-middle>} return GetModel(it_streams->second);"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/order_minion\/OrderMinionController.h\" #include \"shared\/order_minion\/OrderMinionRequest.h\" namespace execution { class TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler { public: TbOrderMinion(IExecutionHandler& handler, tbricks::Strategy& app, const tbricks::InitializationReason& reason, const tbricks::StrategyParameters& parameters); ~TbOrderMinion(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; void MonitorInstrument(const<fim-suffix>private: void UpdateStats(const OrderMinionUpdate& update, const OrderMinionRequest& request); private: OrderMinionController m_controller; tbricks::Hash<tbricks::InstrumentVenueIdentification,OrderMinionRequest> m_requests; }; } \/\/ namespace execution<fim-middle>tbricks::InstrumentVenueIdentification& ivid); protected: \/\/ OrderMinionRequest::IHandler     void HandleOrderMinionUpdate( const OrderMinionUpdate& update ) override;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat :<fim-suffix>{ public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public: subscriptions(const std::string_view id, DeribitMethod method); void AddChannel(const std::string & channel); }; class subscriptions_reply : public JsonReply { public: subscriptions_reply(JsonReply && base); std::vector<std::string_view> GetChannels() const; }; class<fim-middle>public JsonReply"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json<fim-suffix><fim-middle>{ public: virtual ~JsonCall() = default;"}
{"content":"<fim-prefix>#pragma once #include <third_party\/include\/rapidjson\/document.h> #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public:<fim-suffix>\/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected()<fim-middle>virtual ~IHandler() = default;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE =<fim-suffix>const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE =<fim-middle>1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction()) , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency()) , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_startTime(instrument_enricher::strategy_parameters::StartTime()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) , m_timerController(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { ImportNow(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); const StrategyParameters& parameters = modifier.GetParameters(); GetParameters().Merge(parameters); MergeAttributes(modifier.GetAttributes()); if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction())) { Integer action; parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action); HandleAction(action); } if (parameters.GetParameter(m_startTime) or parameters.GetParameter(m_importFrequency)) { m_timerController.Update(parameters); } m_instrument_enricherAppAction.Clear(); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.GetItem(m_instrument_enricherAppAction).SetDirection(direction); auto &action_vi = context.GetItem(m_instrument_enricherAppAction); std::vector<Integer> allowed_actions; if (GetState().IsRunning()) { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer); } else { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer); allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow); } action_vi.SetValidValues(allowed_actions); action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT); if (not GetState().IsRunning()) { auto& freqValidationItem = context.GetItem(m_importFrequency); Duration frequency; freqValidationItem.GetValue(frequency); if (not frequency.Empty() and frequency < Duration::Seconds(1)) { freqValidationItem.SetValue(Duration::Seconds(1)); m_plugInStatusDescription<fim-suffix><fim-middle>= \"Import frequency cannot be less than 1 second\";"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS<fim-suffix><fim-middle>#include <strategy\/Exception.h>"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n    Binary_ostream() { }\n    void close()\n    {\n        m_data.Clear();\n    }\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n    template <typename T>\n    void write(const T & t)\n    {\n        tbricks::Binary vec;\n        vec.Set(reinterpret_cast<const void *>(&t), sizeof(T));\n        write(vec);\n    }\n    void write(const std::string & s)\n    {\n        write(s.c_str(), s.size());\n    }\n    void write(const char * p, size_t size)\n    {\n        m_data.Append(p, size);\n    }\n\nprivate:\n    tbricks::Binary m_data;\n};\n<fim-suffix><fim-middle>template <typename T>\nBinary_istream & operator>>(Binary_istream & istm, T & val)\n{\n    istm.read(val);"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency);<fim-suffix><fim-middle>status = \"Timer started, repeats \" + m_frequency.ToString();"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL };<fim-suffix>{ switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string> Method; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods() {<fim-middle>static std::string Resolve(DeribitKind e)"}
{"content":"<fim-prefix>#include \"PositionReverser.h\" #include \"tbricks_definitions.h\" #include <cmath> using namespace tbricks; void PositionReverser::ReversePosition( const Position& position, const Price& atPrice) { Trade reversedTrade; Volume netPosition = position.GetNetPosition(); if (netPosition > 0) { reversedTrade.SetSide(Side::SELL); } else { reversedTrade.SetSide(Side::BUY); } reversedTrade.SetPrice(atPrice); reversedTrade.SetType(TradeType::POSITION_ADJUSTMENT); reversedTrade.SetCurrency(position.GetCurrency()); reversedTrade.SetClient(position.GetClient()); reversedTrade.SetVolume(std::fabs(position.GetNetPosition())); reversedTrade.SetCounterpart(position.GetCounterpart()); Trade::RequestResult reqCreate = Trade::SendCreateRequest(reversedTrade, *this); m_reversedPositions[reqCreate.GetRequestIdentifier()] = position.GetIdentifier(); TBDEBUG(\"Requested to reverse position: \" << position.GetIdentifier() <<<fim-suffix><< reqCreate.GetTradeIdentifier()); } void PositionReverser::HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) { TBDEBUG(__func__ << \" \" << id << \" with status \" << status << \" \" << status_text); auto iterCreate = m_reversedPositions.find(id); bool isCreateRequest = (iterCreate != m_reversedPositions.end()); if (not isCreateRequest) { TBDEBUG(\"Received unknow<fim-middle>\" with trade: \""}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <optional> struct DeribitInstrument { tbricks::String instrument_name;<fim-suffix>tbricks::String settlement_currency; tbricks::String settlement_period; tbricks::String quote_currency; tbricks::String counter_currency; tbricks::String option_type; \/\/ \"call\" or \"put\" for options std::optional<tbricks::Double> strike; \/\/ Only for options tbricks::DateTime expiration_timestamp; tbricks::Double tick_size; tbricks::Double contract_size; tbricks::Boolean is_active; \/\/ Constructor that safely extracts data from rapidjson Value static std::optional<DeribitInstrument> FromJson(const rapidjson::Value& value) { DeribitInstrument data; \/\/ Required fields - if any<fim-middle>tbricks::String instrument_type; tbricks::String kind;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::OpenCIVStream()\n{\n    CalculatedInstrumentValues::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrumentVenueIdentification(InstrumentVenueIdentification(instId));\n    }\n    options.AddValue(calculated_values::UnderlyingPrice());\n\n    auto throttle = MaximumUpdateTimeThrottle(Duration::Seconds(5));\n    options.SetThrottle(throttle);\n    m_calculatedValuesStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened calculated instrument values stream : \" << m_calculatedValuesStream.GetIdentifier() << \" with options : \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n        OpenCIVStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        m_instrumentCache[instrument.GetIdentifier()].instrument = instrument;\n\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()].maturityDate = tbMaturityDate;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n<fim-suffix><fim-middle>    {\n        m_instrumentCache[instrumentID].underlyingInstrument = underlyingId;\n    }\n}"}
{"content":"<fim-prefix>#include \"TbOrderManager.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbOrderManager::TbOrderManager(IExecutionHandler& handler)\n: OrderExecutor(handler)\n{\n    TBDEBUG(__func__);\n}\n\nTbOrderManager::~TbOrderManager()\n{\n    TBDEBUG(__func__);\n    if (!m_orderData.empty())\n    {\n        DeleteOrders();\n    }\n}\n\nvoid TbOrderManager::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume, \/\/ negative for sell\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n\n    if (BestPrice bbo; m_md.GetBBO(ivid, bbo))\n    {\n        if (volume < 0.0 and bbo.HasBidPrice())\n        {\n            CreateSingleOrder(ivid, volume.Abs(), bbo.GetBidPrice(), Side::SELL, portfolio);\n        }\n        else if (volume > 0.0 and bbo.HasAskPrice())\n        {\n            CreateSingleOrder(ivid, volume.Abs(), bbo.GetAskPrice(), Side::BUY, portfolio);\n        }\n        else\n        {\n            TBWARNING(\"Missing price for \" << ivid);\n        }\n    }\n    else\n    {\n        m_md.Subscribe(ivid, this, TRACK_BBO);\n        m_orderQueue[ivid] = {ivid, volume, portfolio};\n        TBDEBUG(\"Waiting bbo for \" << ivid);\n    }\n}\n\nvoid TbOrderManager::DeleteOrders()\n{\n    TBDEBUG(__func__);\n    if (m_orderData.empty())\n    {\n        return;\n    }\n\n    for (Hash<OrderIdentifier, Order>::const_iterator it = m_orderData.begin(); it != m_orderData.end(); ++it)\n    {\n        DeleteSingleOrder(it->first);\n    }\n}\n\nvoid TbOrderManager::CreateSingleOrder(const InstrumentVenueIdentification& ivid, const Volume& volume, const Price& price, const Side& side, const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__);\n    TBDUMP(\"IVID=\" << ivid << \", vol=\" << volume << \", price=\" << price << \", side=\" << side << \", portfolio=\" << portfolio);\n    Order::Options orderOptions;\n    orderOptions.SetPortfolioIdentifier(portfolio);\n    orderOptions.SetValidity(Validity::VALID_IMMEDIATE);\n    orderOptions.SetInstrumentVenueIdentification(ivid);\n    orderOptions.SetActiveVolume(volume);\n    orderOptions.SetSide(side);\n    if (not price.Empty())\n    {\n        orderOptions.SetPrice(RoundPriceToTicks(price, side, ivid));\n    }\n    OrderCreateRequestResult req = OrderManager::SendCreateRequest(orderOptions, *this);\n    TBDUMP(\"Send order: \" << orderOptions);\n    m_requests[req.GetRequestIdentifier()] = req.GetOrderIdentifier();\n    m_activeOrders[ivid] = req.GetOrderIdentifier();\n}\n\nPrice TbOrderManager::RoundPriceToTicks(const Price& price, const Side& side, const InstrumentVenueIdentification& ivid)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \": price=\" << price << \", side=\" << side << \", ivid=\" << ivid);\n    InstrumentTradingInformation tick_rules(ivid);\n    if (tick_rules.Empty())"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if<fim-suffix>return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return<fim-middle>(size <= 0)"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod<fim-suffix>PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return<fim-middle>{ NONE,"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \"<fim-suffix>} void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \",<fim-middle><< GetVenueIdentifier());"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing) VOLATILITY(custom, Custom)<fim-suffix><fim-middle>VOLATILITY(my_custom, MyCustom)"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const<fim-suffix>}; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public: subscriptions(const std::string_view id, DeribitMethod method); void AddChannel(const std::string & channel); }; class subscriptions_reply : public JsonReply { public: subscriptions_reply(JsonReply && base); std::vector<std::string_view> GetChannels() const; }; class subscription_update : public JsonReply { public: subscription_update(JsonReply && base); std::string_view GetChannel() const; std::string_view GetData(); private: rapidjson::StringBuffer dataBuffer; }; class public_get_instruments : public JsonCall { public: public_get_instruments(const std::string_view id); void<fim-middle>std::string_view id);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem<fim-suffix><fim-middle>& item) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void<fim-suffix>\/\/<fim-middle>HandleValidateRequest(tbricks::ValidationContext &context) final;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n<fim-suffix><fim-middle>TbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    if (not m_client)\n    {\n        m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_PROD);\n    }\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n<fim-suffix><fim-middle>    {\n        HandleDistributedValuesSubscription(request);\n    }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename T> void write(const T & t) { tbricks::Binary vec; vec.Set(reinterpret_cast<const void *>(&t), sizeof(T)); write(vec); } void write(const std::string & s) { write(s.c_str(), s.size()); } void write(const<fim-suffix><fim-middle>char * p, size_t size)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path,<fim-suffix>~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int<fim-middle>const TbWebsocketClient::Config & conf);"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n<fim-suffix><fim-middle>    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const<fim-suffix>void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;<fim-middle>tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear(); m_wasStreamStale = false; TBDEBUG(__func__); if (m_positionStream.IsOpen()) { m_positionStream.Close(); } m_positionStream.Open( Stream::SNAPSHOT, portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, AnyPositionFilter()); } void PositionRetriever::Stop() { m_positionStream.Close(); m_positions.clear(); } void PositionRetriever::HandleStreamOpen(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { if (not m_wasStreamStale) { TBDEBUG(__func__ << \" Stream opened: \" << stream_id); } else { TBNOTICE(\"Stream reconnected\"); m_wasStreamStale = false; } } else { TBDEBUG(__func__ << \" Unknown opened stream: \" << stream_id); } } void PositionRetriever::HandleStreamStale(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBWARNING(__func__ << \" Stream became stale: \" << stream_id); m_wasStreamStale = true; } else { TBWARNING(__func__ << \" Unknown stale stream: \" << stream_id); } } void PositionRetriever::HandleStreamFailed(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { std::stringstream error; error << \"Stream failed: \" << stream_id; m_callback.HandleError(error.str()); } else { TBWARNING(__func__ << \" Unknown failed stream: \" << stream_id); } } void<fim-suffix>if (m_positionStream.GetIdentifier() == stream_id) { TBDEBUG(__func__ << \" Snapshot end received on stream: \" << stream_id); m_callback.HandlePositions(m_positions); } else { TBDEBUG(__func__ << \" Received snapshot end on unknown stream: \" << stream_id); } } void PositionRetriever::HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) { TBDEBUG(__func__ << \" \" << stream_id); TBDUMP(position); if (m_positionStream.GetIdentifier() == stream_id) { m_positions.emplace(position.GetIdentifier(), position); } else { TBDEBUG(__func__ << \" Received position on unknown stream: \" << stream_id); } } void<fim-middle>PositionRetriever::HandleSnapshotEnd(const StreamIdentifier& stream_id) {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/VisualizationApp.h> #include <strategy\/visualization\/ViewModelUpdate.h> #include <strategy\/visualization\/ICellValue.h> #include <strategy\/visualization\/Grid.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::VisualizationApp , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VisualizationApp methods void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewDelete(tbricks::visualization::models::AppViewModel & viewModel) final { } void HandleGridViewCreate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } void HandleGridViewUpdate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } \/\/ TimerController::IHandler void HandleTimerEventHit() final; void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final; private: bool CheckRunningRequirement(); void HandleAction(const tbricks::Integer & action); void Start(); void Stop(); void ImportNow(); \/\/ app parameters tbricks::IntegerParameter m_instrument_enricherAppAction; tbricks::DurationParameter m_importFrequency; tbricks::InstrumentGroupParameter m_instrumentGroup; tbricks::DateTimeParameter m_maturityDate; tbricks::StringParameter m_plugInStatusDescription; tbricks::DateTimeParameter m_startTime;<fim-suffix><fim-middle>tbricks::InstrumentIdentifierParameter m_underlyingInstrument;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n    Binary_ostream() { }\n    void close()\n    {\n        m_data.Clear();\n    }\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n    template <typename T>\n    void write(const T & t)\n    {\n        tbricks::Binary vec;\n        vec.Set(reinterpret_cast<const void *>(&t), sizeof(T));\n        write(vec);\n    }\n    void write(const std::string & s)\n    {\n        write(s.c_str(), s.size());\n    }\n    void write(const char * p, size_t size)\n    {\n        m_data.Append(p, size);\n    }\n\nprivate:\n    tbricks::Binary m_data;\n};\n<fim-suffix><fim-middle>template <typename T>\nBinary_istream & operator>>(Binary_istream & istm, T & val)\n{\n    istm.read(val);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { \/\/<fim-suffix>void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update);<fim-middle>Here is where we would open the DistributedValues::Stream }"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction()) , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency()) , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_startTime(instrument_enricher::strategy_parameters::StartTime()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_importOnce(false) , m_instrumentManager(*this) , m_timerController(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { ImportNow(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier) { TBSTATUS(__func__ << \" : \" << modifier); const StrategyParameters& parameters = modifier.GetParameters(); GetParameters().Merge(parameters); MergeAttributes(modifier.GetAttributes()); if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction())) { Integer action; parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action); HandleAction(action); } if (parameters.GetParameter(m_startTime) or parameters.GetParameter(m_importFrequency)) { m_timerController.Update(parameters); } m_instrument_enricherAppAction.Clear(); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.GetItem(m_instrument_enricherAppAction).SetDirection(direction); auto &action_vi = context.GetItem(m_instrument_enricherAppAction); std::vector<Integer> allowed_actions; if (GetState().IsRunning()) { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer); } else { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer); allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow); } action_vi.SetValidValues(allowed_actions); action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT); if (not GetState().IsRunning()) { auto& freqValidationItem = context.GetItem(m_importFrequency); Duration frequency; freqValidationItem.GetValue(frequency); if (not frequency.Empty() and frequency < Duration::Seconds(1)) { freqValidationItem.SetValue(Duration::Seconds(1)); m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\"; } freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT); } context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement()<fim-suffix>{ m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } return true; } void InstrumentEnricherPlugin::HandleAction(const Integer & action) { TBDEBUG(__func__ << \" : \" << action); if(TB_UNLIKELY(action.Empty())) { TBDEBUG(\"Action is empty, skipping\"); } switch (action.GetInt()) { case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer: Start(); break; case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer: Stop(); break; case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow: m_importOnce = true; ImportNow(); break; default: TBDEBUG(\"Unknown action\"); break; } } void InstrumentEnricherPlugin::Start() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_timerController.Start(); } SetState(StrategyState::RUNNING); } void InstrumentEnricherPlugin::Stop() { TBDEBUG(__func__); if (m_timerController.IsActive()) { m_timerController.Stop(); } m_instrumentManager.Stop(); m_importOnce = false; if (GetState().IsPaused()) { TBDEBUG(\"Already stopped\"); return; }<fim-middle>{ TBDEBUG(__func__); if (m_instrumentGroup.Empty())"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n<fim-suffix><fim-middle>void InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n<fim-suffix><fim-middle>    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n<fim-suffix><fim-middle>    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json {<fim-suffix>struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply<fim-middle>public:"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewUpdate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    auto it = update.begin();\n    while (it != update.end())\n    {\n        TBDUMP(it.GetCell().GetCalculatedProperty() << \" \" << it.GetCell().GetCellValue());\n\n        auto & calcProp = it.GetCell().GetCalculatedProperty().GetDefinition();\n        auto & cellValue = it.GetCell().GetCellValue();\n\n        if (calcProp == instrument_enricher::calculated_properties::strategy::ImportFrequency())\n        {\n            m_importFrequency = cellValue.GetDuration();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::InstrumentGroup())\n        {\n            m_instrumentGroup = cellValue.GetInstrumentGroupIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::UnderlyingInstrument())\n        {\n            m_underlyingInstrument = cellValue.GetInstrumentIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::StartTime())\n        {\n            m_startTime = cellValue.GetDateTime();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::MaturityDate())\n        {\n            m_maturityDate = cellValue.GetDateTime();\n        }\n\n        ++it;\n    }\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       m_importOnce = true;\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_instrumentsGrid.RemoveAllRows();\n        m_plugInStatusDescription.Clear();\n        m_timerController.Start();\n    }\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::Stop()\n{\n    TBDEBUG(__func__);\n\n    if (m_timerController.IsActive())\n    {\n        m_timerController.Stop();\n    }\n    m_instrumentManager.Stop();\n    m_importOnce = false;\n\n    if (GetState().IsPaused())\n    {\n        TBDEBUG(\"Already stopped\");\n        return;\n    }\n<fim-suffix><fim-middle>    Strategy::SetState(StrategyState::PAUSED);\n}"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n<fim-suffix><fim-middle>    if (not m_tcp.IsOpen())\n        return;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return<fim-suffix><fim-middle>default; \\"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_importOnce(false)\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       m_importOnce = true;\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_plugInStatusDescription.Clear();\n        m_timerController.Start();\n    }\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::Stop()\n{\n    TBDEBUG(__func__);\n\n    if (m_timerController.IsActive())\n    {\n        m_timerController.Stop();\n    }\n    m_instrumentManager.Stop();\n    m_importOnce = false;\n<fim-suffix><fim-middle>    if (GetState().IsPaused())\n    {\n        TBDEBUG(\"Already stopped\");\n        return;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->Reset();\n    }\n    else\n    {\n        TBDEBUG(\"Unknown stream\");\n    }\n}\n\nvoid DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->Fail();\n    }\n    else\n    {\n        TBDEBUG(\"Unknown stream\");\n    }\n}\n\nvoid DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n    TBDUMP(update);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->HandleDistributedValuesUpdate(update);\n    }\n    else\n    {\n        TBDEBUG(\"No Deribit model associated with stream: \" << stream);\n    }\n}\n\nstd::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream)\n{\n    auto it_streams = m_streams.find(stream);\n    if (it_streams == m_streams.end())\n    {\n        return std::nullopt;\n    }\n<fim-suffix><fim-middle>    return GetModel(it_streams->second);\n}"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);<fim-suffix><fim-middle>~DeribitContributor() noexcept override = default;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n<fim-suffix><fim-middle>std::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);"}
{"content":"<fim-prefix>#pragma once #include <third_party\/include\/rapidjson\/document.h> #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false;<fim-suffix>int hb = 0;<fim-middle>bool logged_in = false;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>bool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \" +<fim-suffix>void TimerController::Stop() { TBDEBUG(__func__);<fim-middle>m_frequency.ToString(); } m_handler.HandleTimerControllerUpdate(status, \/*error =*\/ false); }"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); };<fim-suffix><fim-middle>class public_set_heartbeat : public JsonCall"}
{"content":"<fim-prefix>#include \"TbOrderManager.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbOrderManager::TbOrderManager(IExecutionHandler& handler)\n: OrderExecutor(handler)\n{\n    TBDEBUG(__func__);\n}\n\nTbOrderManager::~TbOrderManager()\n{\n    TBDEBUG(__func__);\n    if (!m_orderData.empty())\n    {\n        DeleteOrders();\n    }\n}\n\nvoid TbOrderManager::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume, \/\/ negative for sell\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n\n    if (BestPrice bbo; m_md.GetBBO(ivid, bbo))\n    {\n        if (volume < 0.0 and bbo.HasBidPrice())\n        {\n            CreateSingleOrder(ivid, volume.Abs(), bbo.GetBidPrice(), Side::SELL, portfolio);\n        }\n        else if (volume > 0.0 and bbo.HasAskPrice())\n        {\n            CreateSingleOrder(ivid, volume.Abs(), bbo.GetAskPrice(), Side::BUY, portfolio);\n        }\n        else\n        {\n            TBWARNING(\"Missing price for \" << ivid);\n        }\n    }\n    else\n    {\n        m_md.Subscribe(ivid, this, TRACK_BBO);\n        m_orderQueue[ivid] = {ivid, volume, portfolio};\n        TBDEBUG(\"Waiting bbo for \" << ivid);\n    }\n}\n\nvoid TbOrderManager::DeleteOrders()\n{\n    TBDEBUG(__func__);\n    if (m_orderData.empty())\n    {\n        return;\n    }\n\n    for (Hash<OrderIdentifier, Order>::const_iterator it = m_orderData.begin(); it != m_orderData.end(); ++it)\n    {\n        DeleteSingleOrder(it->first);\n    }\n}\n\nvoid TbOrderManager::CreateSingleOrder(const InstrumentVenueIdentification& ivid, const Volume& volume, const Price& price, const Side& side, const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__);\n    TBDUMP(\"IVID=\" << ivid << \", vol=\" << volume << \", price=\" << price << \", side=\" << side << \", portfolio=\" << portfolio);\n    Order::Options orderOptions;\n    orderOptions.SetPortfolioIdentifier(portfolio);\n    orderOptions.SetValidity(Validity::VALID_IMMEDIATE);\n    orderOptions.SetInstrumentVenueIdentification(ivid);\n    orderOptions.SetActiveVolume(volume);\n    orderOptions.SetSide(side);\n    if (not price.Empty())\n    {\n        orderOptions.SetPrice(RoundPriceToTicks(price, side, ivid));\n    }\n    OrderCreateRequestResult req = OrderManager::SendCreateRequest(orderOptions, *this);\n    TBDUMP(\"Send order: \" << orderOptions);\n    m_requests[req.GetRequestIdentifier()] = req.GetOrderIdentifier();\n    m_activeOrders[ivid] = req.GetOrderIdentifier();\n}\n\nPrice TbOrderManager::RoundPriceToTicks(const Price& price, const Side& side, const InstrumentVenueIdentification& ivid)\n{\n    TBDEBUG(__func__ << \": price=\" << price << \", side=\" << side << \", ivid=\" << ivid);\n    InstrumentTradingInformation tick_rules(ivid);\n    if (tick_rules.Empty())\n    {\n        TBERROR(\"Unable to resolve Instrument trading information for instrument \"\n                << ivid.GetInstrumentIdentifier());\n        EmergencyStop();\n        return {};\n    }\n    return tick_rules.RoundPrice(side, price);\n}\n<fim-suffix><fim-middle>void TbOrderManager::HandleRequestReply(const Identifier& id, Status status, const String& status_text)\n{\n    TBDEBUG(\"Request status: \" << status << \". Reply from system: \" << status_text);\n    TBSTATUS(\"Request for order \" << m_requests[id]);"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; namespace dv = deribit_contributor::distributed_values; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); m_supported_values.insert(dv::DeribitTicker().GetIdentifier()); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::FailWithReason(const String & reason) { SetTransactionFail(reason, StrategyState::PAUSED); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); DistributedValuesReply reply(request.GetIdentifier(), false); \/\/ Check that all objects are supported by the app InstrumentIdentifier instrumentId; for (const auto & object : request.GetObjects()) { auto & objParams = object.GetParameters(); if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency())) { \/\/ if instrument is not defined in the request TBDEBUG(\"Object missing required parameters:\\n\" << object << \"Rejecting request.\"); IDistributionApp::SendDistributedValuesReply(reply); return; } \/\/ Check instrument listed on venue Instrument i(instrumentId); auto [compatible, viid] = ExtractVIID(i); if (not compatible) { TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\"); IDistributionApp::SendDistributedValuesReply(reply); return; } } for (const auto & value : request.GetValues()) { if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end()) { TBDEBUG(\"Unsupported value:\\n\" << value << \"Rejecting request.\"); IDistributionApp::SendDistributedValuesReply(reply); return; } } if (GetState() == StrategyState::PAUSED) { TBDEBUG(\"Request cannot be answered immediately. App is paused.\"); return; } \/\/ Send successful reply reply.SetSupported(true); IDistributionApp::SendDistributedValuesReply(reply); } void DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); InstrumentIdentifier instrumentId; const auto & request_id = request.GetIdentifier(); \/\/ For all objects in the request ... for (const auto & object : request.GetObjects()) { if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId)) { auto [compatible, viid] = ExtractVIID({instrumentId}); if (m_client and compatible) { SparseHash<String, String> keys; viid.GetKeys(keys); auto & id = keys[\"symbol\"]; for (const auto &<fim-suffix>TBSTATUS(\"Subscribing to ticker: \" << id); } m_requestMap[instrumentId] = request; m_symbolMap[id] = instrumentId; } else { TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId); } } } IDistributionApp::SnapshotDone(request_id); } void DeribitContributor::HandleDeribitConnected() { TBDEBUG(__func__); SetState(StrategyState::RUNNING); m_client->SetHeartbeat(30); } void DeribitContributor::HandleDeribitDisconnected() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json) { auto & id = m_symbolMap[ticker]; if (id.Empty()) { TBWARNING(\"Received unknown instrument ticker: \" << ticker); return; } auto request = m_requestMap.find(id); if (request != m_requestMap.end()) { for (const auto & object : request->second.GetObjects()) { InstrumentIdentifier instrument; object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrument); if (instrument == id) { for (const auto & value : request->second.GetValues()) { if (value.GetDefinition()<fim-middle>v : request.GetValues()) {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp :<fim-suffix>DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem &<fim-middle>public tbricks::MarketDataProvider { public:"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\ntypedef std::pair<DeribitMethod, std::string> Method;\n\n<fim-suffix><fim-middle>static std::vector<Method> GetAvailableMethods()\n{\n    return {"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitModel.h\"\n#include <shared\/API.h>\n\nclass DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler\n{\npublic:\n    DeribitMdp();\n    ~DeribitMdp() noexcept override = default;\n\nprotected:\n    void HandleSubscribe(tbricks::MarketDataItem & item) override;\n    void HandleUnsubscribe(tbricks::MarketDataItem & item) override;\n    void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override;\n    void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override;\n    bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override;\n    void GetDiagnostics(tbricks::Diagnostics & diagnostics) override;\n\n    void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamStale(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;\n<fim-suffix><fim-middle>    void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override;"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    if (not m_client)\n    {\n        m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_PROD);\n    }\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n<fim-suffix><fim-middle>    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n<fim-suffix><fim-middle>{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n<fim-suffix><fim-middle>#define BUFFER_MIN_SIZE 4"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n<fim-suffix><fim-middle>    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h>\n#include <shared\/volatility\/ClampedCubicSpline.h>\n#include <shared\/volatility\/StochasticVolatilityInspired.h>\n#include <shared\/volatility\/WingVolatilityModel.h>\n#include <shared\/volatility\/MyCustomVolatilityModel.h>\n\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypeRef>\nModelTypeRef vol_model_cast(volatility::IVolatilityModel & model);\n\ntemplate <class ModelTypeRef>\nModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model);\n\n#define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\\n    template <> \\\n    inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\\n    { \\\n<fim-suffix><fim-middle>        if (TB_UNLIKELY(!pModel)) { \\\n            return nullptr; \\\n        } \\\n        \\"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/VisualizationApp.h> #include <strategy\/visualization\/ViewModelUpdate.h> #include <strategy\/visualization\/ICellValue.h> #include <strategy\/visualization\/Grid.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::VisualizationApp , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VisualizationApp methods void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewDelete(tbricks::visualization::models::AppViewModel & viewModel) final { } void HandleGridViewCreate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } void HandleGridViewUpdate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } \/\/ TimerController::IHandler void HandleTimerEventHit() final; void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final; private: bool CheckRunningRequirement(); void HandleAction(const tbricks::Integer & action); void Start(); void Stop(); void ImportNow(); \/\/ app<fim-suffix><fim-middle>parameters tbricks::IntegerParameter m_instrument_enricherAppAction;"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const<fim-suffix><fim-middle>tbricks::String& status_text) override;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\"<fim-suffix>SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to; return std::move(sstrm).str(); } public: BadPreferencesStorageCast(const PreferencesStorageKind from, const PreferencesStorageKind to) : Exception(PreferenceKindsToString(from, to)) {}<fim-middle>#include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h>"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h>\n#include <cstddef>\nusing std::size_t;\n<fim-suffix><fim-middle>namespace volatility_model_constants {"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\" #include \"ConstantVolatility.h\" #include \"StochasticVolatilityInspired.h\"<fim-suffix>#endif \/\/ __SHARED__VOLATILITY__VOLATILITY_MODELS__H<fim-middle>#include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\""}
{"content":"<fim-prefix>#include \"TbChildOrder.h\" using namespace tbricks; namespace execution { TbChildOrder::TbChildOrder(IExecutionHandler& handler, Strategy& app) : OrderExecutor(handler) , m_app(app) , m_stream(*this) { StrategyStream::Options opts; opts.SetFilter(StrategyByParentFilter(app.GetIdentifier())); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, opts, StrategyStream::ToStrategyEngine); TBDEBUG(__func__ << \" opened stream with options: \" << opts); } TbChildOrder::~TbChildOrder() { m_stream.Close(); DeleteOrders(); } void TbChildOrder::DeleteOrders() { TBDEBUG(__func__); for (const auto& [ivid,childId] : m_childMap) { if (m_childData[childId].GetState().IsDeleted()) { \/\/ already deleted continue; } Strategy::SendDeleteRequest(childId); TBDUMP(\"Sent deletion for \" << childId << \" [\" << ivid << \"]\"); } } void TbChildOrder::CreateOrder( const InstrumentVenueIdentification&<fim-suffix>const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio); StrategyOptions opts{plug_ins::Order()}; \/\/ very few app definitions in this namespace StrategyAttributes attrs; attrs.SetExtraData(m_app.GetExtraData()); opts.SetAttributes(attrs); StrategyParameters params; params.SetParameter(strategy_parameters::Portfolio(), portfolio); params.SetParameter(strategy_parameters::ActiveVolume(), volume.Abs()); params.SetParameter(strategy_parameters::Instrument(),<fim-middle>ivid, const Volume& volume,"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s<fim-suffix><fim-middle>= msg.FindMember(\"state\");"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing)<fim-suffix><fim-middle>VOLATILITY(custom, Custom)"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbChildOrder : public OrderExecutor, public tbricks::StrategyStream::IHandler, public tbricks::IRequestReplyHandler { public: TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app); ~TbChildOrder(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ StrategyStream::IHandler void HandleStrategyUpdate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyUpdate<fim-suffix><fim-middle>& update) final; void HandleStrategyInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyIdentifier & id) final;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double<fim-suffix>{ \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key);<fim-middle>method() \\"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public:<fim-suffix><fim-middle>virtual ~JsonReply() = default;"}
{"content":"<fim-prefix>#include \"Values.h\"\n#include \"ValuesRequest.h\"\n\nvoid ImpliedValue::Clear()\n{\n    implied_volatility.Clear();\n}\n\nstd::ostream & ImpliedValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"] \" << implied_volatility;\n    return strm;\n}\n\nFairPriceValue & FairPriceValue::operator += (const FairPriceValue & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.fair_price.Empty()) {\n        fair_price += fair_price_value.fair_price;\n    } else if (fair_price_value.fair_price.HasError()) {\n        fair_price.SetError(fair_price_value.fair_price.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n<fim-suffix><fim-middle>FairPriceValue & FairPriceValue::operator += (const Double & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.Empty()) {\n        fair_price += fair_price_value;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient<fim-suffix><fim-middle>: public tbricks::TCPStream::IHandler {"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n<fim-suffix><fim-middle>    {\n        FailWithReason(\"Missing endpoint\");\n    }"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely picked up by another calc<fim-suffix>} Send(); } \/\/ Note that here we use DEFINE_PRICING_ENTRY instead<fim-middle>app \/\/ the engine was just checking if we responded to it         }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream &<fim-suffix><fim-middle>stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/VisualizationApp.h> #include <strategy\/visualization\/ViewModelUpdate.h> #include <strategy\/visualization\/ICellValue.h> #include <strategy\/visualization\/Grid.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::VisualizationApp , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VisualizationApp methods void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewDelete(tbricks::visualization::models::AppViewModel & viewModel) final { } void HandleGridViewCreate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } void HandleGridViewUpdate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const<fim-suffix>const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } \/\/ TimerController::IHandler void HandleTimerEventHit() final; void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final; private: bool CheckRunningRequirement(); void HandleAction(const tbricks::Integer & action); void Start(); void Stop(); void ImportNow(); \/\/ app parameters tbricks::IntegerParameter m_instrument_enricherAppAction; tbricks::DurationParameter m_importFrequency;<fim-middle>tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); }"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp>\n#include <shared\/SuppressSfApiClangWarnings.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/Price.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/Boolean.h>\n#include <strategy\/calculated_property\/CalculatedPropertyFilter.h>\n#include <strategy\/TreeNodeParameters.h>\n#include <strategy\/parameter\/StrategyParameters.h>\n#include <strategy\/parameter\/StrategyInstanceParameters.h>\nCLANG_RESTORE_WARNINGS\n#include <set>\n\nusing namespace tbricks;\n\nenum class PreferencesStorageKind\n{\n    Common = 0,\n    Wing,\n    CCS,\n    SVI,\n    MyCustom = 100000\n};\n\nstd::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind);\n\n\/**\n * Struct representing the various settings common to all VMs; it is subclassed by structs\n * containing additional parameters relevant for particular VMs\n *\/\nclass PreferencesStorage: public Printable\n{\npublic:\n    PreferencesStorage();\n\nprotected:\n    PreferencesStorage(const PreferencesStorage & storage) = default;\n    PreferencesStorage & operator=(const PreferencesStorage & storage) = default;\n\npublic:\n    virtual ~PreferencesStorage();\n<fim-suffix><fim-middle>    virtual PreferencesStorageKind GetKind() const = 0;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n<fim-suffix><fim-middle>    {\n        ParseHttpReply(data);\n        return;\n    }"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to; return std::move(sstrm).str(); } public: BadPreferencesStorageCast(const PreferencesStorageKind from, const PreferencesStorageKind to) : Exception(PreferenceKindsToString(from, to)) {} }; template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage); template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage); #define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\ { \\ if (TB_UNLIKELY(!pPreferencesStorage)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY((pPreferencesStorage->GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\ throw BadPreferencesStorageCast(pPreferencesStorage->GetKind(), kind); \\ } \\ \\ return reinterpret_cast<specifier type*>(pPreferencesStorage); \\ } #define PREFERENCES_STORAGE_REF_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type & pref_storage_cast(specifier PreferencesStorage & preferencesStorage) \\<fim-suffix>throw BadPreferencesStorageCast(preferencesStorage.GetKind(), kind); \\ } \\ \\ return reinterpret_cast<specifier type&>(preferencesStorage); \\ } #define PREFERENCES_STORAGE_CAST_IMPL(specifier, type, kind) \\ PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\ PREFERENCES_STORAGE_REF_CAST_IMPL(specifier,<fim-middle>{ \\ if (TB_UNLIKELY((preferencesStorage.GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in =<fim-suffix>int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t); void OnHeartbeat(deribit::JsonReply && incoming); void OnTestReply(SingleTransaction & t); void OnSubscribeReply(SingleTransaction & t); void OnSubscriptionUpdate(deribit::JsonReply && incoming); private:<fim-middle>false;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); }<fim-suffix>{ return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetIndexPrice,<fim-middle>if (not state.empty() and state.compare(\"open\") == 0)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n<fim-suffix><fim-middle>private:\n    std::string_view type;\n};"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler, visualization::Grid& instrumentsGrid)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n    , m_tasksDone(false)\n    , m_instrumentsGrid(instrumentsGrid)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n    m_tasksDone = false;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::OpenCIVStream()\n{\n    CalculatedInstrumentValues::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrumentVenueIdentification(InstrumentVenueIdentification(instId));\n    }\n    options.AddValue(calculated_values::UnderlyingPrice());\n\n    auto throttle = MaximumUpdateTimeThrottle(Duration::Seconds(5));\n    options.SetThrottle(throttle);\n    m_calculatedValuesStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened calculated instrument values stream : \" << m_calculatedValuesStream.GetIdentifier() << \" with options : \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n<fim-suffix><fim-middle>{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; };<fim-suffix><fim-middle>class subscriptions : public JsonCall"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; namespace dv = deribit_contributor::distributed_values; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); m_supported_values.insert(dv::DeribitTicker().GetIdentifier()); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so<fim-suffix>} void DeribitContributor::FailWithReason(const String & reason) { SetTransactionFail(reason, StrategyState::PAUSED); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); DistributedValuesReply reply(request.GetIdentifier(), false); \/\/<fim-middle>we just inform the frontend that validation is completed     context.SendReply();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <deribit\/DeribitInstrument.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0; virtual void HandleInstrumentManagerReady() = 0; virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0; virtual void HandleInstrumentError(const tbricks::String & error) = 0; }; explicit InstrumentManager(IHandler & handler); ~InstrumentManager() override; \/\/ Add instruments from Deribit void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Core functionality void Start(); void SyncInstruments(); void Clear(); bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); } protected: \/\/ Common stream callbacks void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void<fim-suffix>void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ Instrument::Stream callbacks void HandleInstrument(const tbricks::StreamIdentifier & stream, const tbricks::Instrument & instrument) override; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier<fim-middle>HandleStreamStale(const tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n<fim-suffix><fim-middle>const Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n<fim-suffix><fim-middle>{\n    FUTURE,\n    OPTION,\n    ALL"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionReverser : public tbricks::IRequestReplyHandler { public: PositionReverser() = default; ~PositionReverser() = default; void ReversePosition( const tbricks::Position& position, const tbricks::Price& atPrice); \/\/ IRequestReplyHandler method void HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) final; private: std::map<tbricks::Identifier, tbricks::Identifier><fim-suffix><fim-middle>m_reversedPositions; };"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n\npublic_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n{\n}\n\nheartbeat::heartbeat(JsonReply && base)\n    : JsonReply(std::move(base))\n    , type {Pointer(\"\/params\/type\").Get(msg)->GetString()}\n{\n}\n\nstd::string_view heartbeat::GetType() const\n{\n    return type;\n}\n\nbool heartbeat::IsTestRequest() const\n{\n    return type == \"test_request\" ? true : false;\n}\n\nsubscriptions::subscriptions(const std::string_view id, DeribitMethod method)\n    : JsonCall(id, method)\n{\n    auto & params = msg[\"params\"];\n    Value v(rapidjson::kArrayType);\n    params.AddMember(\"channels\", v, msg.GetAllocator());\n}\n\nvoid subscriptions::AddChannel(const std::string & channel)\n<fim-suffix><fim-middle>{\n    auto ptr = Pointer(\"\/params\/channels\");\n    if (ptr.IsValid())\n    {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override =<fim-suffix>\/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override;<fim-middle>default;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n<fim-suffix><fim-middle>bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size<fim-suffix>return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char val) { ostm.write(&val, sizeof(char));<fim-middle><= 0)"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to; return std::move(sstrm).str(); } public: BadPreferencesStorageCast(const PreferencesStorageKind from, const PreferencesStorageKind to) : Exception(PreferenceKindsToString(from, to)) {} }; template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage); template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage); #define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type * pref_storage_cast(specifier PreferencesStorage *<fim-suffix><fim-middle>pPreferencesStorage) \\ { \\"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override;<fim-suffix><fim-middle>private: \/\/ App parameters };"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\" using namespace tbricks; InstrumentManager::InstrumentManager(IHandler& handler) : m_handler(handler) , m_instrumentStream(*this) , m_iapStream(*this) { TBDEBUG(__func__ << \" ctor\"); } InstrumentManager::~InstrumentManager() { TBDEBUG(__func__ << \" dtor\"); Stop(); } void InstrumentManager::Stop() { TBDEBUG(__func__); m_instrumentCache.clear(); m_underlyingCache.clear(); m_instrumentStream.Close(); } void InstrumentManager::Start() { TBDEBUG(__func__); Stop(); OpenInstrumentStream(); } void InstrumentManager::OpenInstrumentStream() { TBDEBUG(__func__); InstrumentStream::Options options; options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup())); m_instrumentStream.Open(Stream::SNAPSHOT, options); TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter()); } void InstrumentManager::OpenIAPStream() { TBDEBUG(__func__); tbricks::InstrumentAggregateParameters::Stream::Options options; for (const auto& [instId, _] : m_instrumentCache) { options.AddInstrument(instId); } options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()}); m_iapStream.Close(); m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options); TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options); } void InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); } void InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID) { TBWARNING(\"Instrument cache stream staled = \" << streamID); } void InstrumentManager::HandleStreamFailed(const StreamIdentifier& streamID) { m_handler.HandleInstrumentManagerFailed(\"Instrument stream failed\"); } void InstrumentManager::HandleSnapshotEnd(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); if (streamID == m_instrumentStream.GetIdentifier()) { TBDEBUG(\"Instruments snapshot done, enriching...\"); OpenIAPStream(); } else if (streamID == m_iapStream.GetIdentifier()) { \/\/ All data is collected, now perform the next steps EnrichInstruments(); } } void InstrumentManager::HandleInstrument(const StreamIdentifier& streamID, const Instrument& instrument) { TBDEBUG(__func__ << \" : stream = \" << streamID << \", instrument ID = \" << instrument.GetIdentifier()); TBDUMP(instrument); if (streamID == m_instrumentStream.GetIdentifier()) { m_instrumentCache[instrument.GetIdentifier()] = instrument; } else { TBWARNING(\"Instrument<fim-suffix><fim-middle>update received from unknown stream = \" << streamID);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem &<fim-suffix>const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item =<fim-middle>item) { TBDEBUG(__func__ << \", item = \" << item);"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing,<fim-suffix>} } Send(); } \/\/ Note that<fim-middle>this will be most likely picked up by another calc app                         \/\/ the engine was just checking if we responded to it"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n<fim-suffix><fim-middle>        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size()<fim-suffix><fim-middle><= 0)"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \": \" << stream);\n}"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto& msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } \\ EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest,<fim-suffix>EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetIndexPrice, index_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetCurrentFunding, current_funding, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetBid, best_bid_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetAsk,<fim-middle>0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price, 0)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n<fim-suffix><fim-middle>    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public<fim-suffix>{ public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double<fim-middle>UpdateData"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice();<fim-suffix>double GetBid(); double GetAsk(); double GetBidVolume(); double GetAskVolume(); }; } \/\/ namespace<fim-middle>double GetIndexPrice(); double GetCurrentFunding();"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler, visualization::Grid& instrumentsGrid)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n    , m_tasksDone(false)\n    , m_instrumentsGrid(instrumentsGrid)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size());<fim-suffix>} Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm;<fim-middle>return ostm;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n<fim-suffix><fim-middle>public_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } \/\/ TimerController::IHandler void HandleTimerEventHit() final; void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final; private: bool CheckRunningRequirement(); void HandleAction(const tbricks::Integer<fim-suffix>void Stop(); void ImportNow(); \/\/ app parameters tbricks::IntegerParameter m_instrument_enricherAppAction; tbricks::DurationParameter m_importFrequency; tbricks::InstrumentGroupParameter m_instrumentGroup; tbricks::DateTimeParameter m_maturityDate;<fim-middle>& action); void Start();"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public:<fim-suffix>void AddChannel(const std::string & channel); }; class subscriptions_reply : public JsonReply { public: subscriptions_reply(JsonReply && base); std::vector<std::string_view><fim-middle>subscriptions(const std::string_view id, DeribitMethod method);"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n<fim-suffix><fim-middle>void InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest();<fim-suffix>double GetMaxPrice();<fim-middle>double GetMinPrice();"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str,<fim-suffix>void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream & data); void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length); private: IWebsocketHandler & m_handler; tbricks::TCPStream m_tcp; std::random_device m_rd; std::shared_ptr<std::string> nonce_base64; Config m_config; std::string host;<fim-middle>unsigned char fin_rsv_opcode = 129);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n\ntemplate <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);\n}\n\ntemplate <>\nBinary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)\n{\n    if (val.size() <= 0)\n        return ostm;\n\n    ostm.write(val.c_str(), val.size());\n\n    return ostm;\n}\n<fim-suffix><fim-middle>Binary_ostream & operator<<(Binary_ostream & ostm, const char * val)\n{\n    int size = std::strlen(val);\n    if (size <= 0)"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n<fim-suffix><fim-middle>    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n\n    m_client->DownloadInstruments(Uuid::Create(), DeribitCurrency::BTC);\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)\n    {\n        HandleTickerUpdate(ticker, \"{}\");\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n    {\n        TBWARNING(\"Received unknown instrument ticker: \" << ticker);\n        return;\n    }\n    auto request = m_requestMap.find(id);\n    if (request != m_requestMap.end())\n    {\n        for (const auto & object : request->second.GetObjects())\n        {\n            InstrumentIdentifier instrument;\n            object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrument);\n            if (instrument == id)\n            {\n                for (const auto & value : request->second.GetValues())\n                {\n                    if (value.GetDefinition() == dv::DeribitTicker())\n<fim-suffix><fim-middle>                    {\n                        String data(json.data(), json.size());\n                        IDistributionApp::Update({object.GetIdentifier(), value.GetIdentifier()}, data);\n                        IDistributionApp::Send();"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n<fim-suffix><fim-middle>std::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\" class PositionsData; namespace execution { class OrderExecutor; } namespace misc { class AsyncProcessor; } class GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler { public: GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ Strategy methods void HandleDeleteRequest() override; void HandleRunRequest() override; void HandlePauseRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override; void HandleValidateRequest(tbricks::ValidationContext &context) override; void HandleScheduledEvent(tbricks::UserData&& data) override;<fim-suffix>void AllDone(const execution::Stats& stats)<fim-middle>"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include<fim-suffix>{ switch(volModelType) { case VolatilityModelWing:<fim-middle>\"MyCustomPreferencesStorage.h\" #include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType)"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String<fim-suffix><fim-middle>& reason) final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem &<fim-suffix>~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void<fim-middle>item, tbricks::DistributedValues::Stream::IHandler & handler);"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); \/\/ Perform an operation SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity<fim-suffix>TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString());<fim-middle>date is empty\";"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\"\n#include \"tbricks_definitions.h\"\n#include <cstdlib>\n#include <set>\n\nusing namespace tbricks;\n\nExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request)\n: Pricing(request)\n{\n    srand (time(NULL)); \/\/ Initialize random seed.\n\n    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n    SnapshotDone();\n}\n\nvoid ExampleCalcAppPlugin2::HandlePricingModifyRequest(const PricingModifyRequest& request)\n{\n    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n}\n\nvoid ExampleCalcAppPlugin2::Calculate(const RequestAndIVIDs & values, const CalculatedValuesRequestFull & request)\n{\n    m_rows = values;\n\n    for (const auto & civ_it : request.GetColumns())\n    {\n        if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2())\n        {\n            Double x;\n            StrategyParameters parameters;\n            civ_it.GetColumnInfo().GetParameters(parameters);\n            parameters.GetParameter(strategy_parameters::X(), x);\n            for (const auto & ivids_it : m_rows)\n            {\n                Calculate(ivids_it.first, civ_it.GetColumnId(), x);\n            }\n        }\n        else\n        {\n            TBERROR(\"System asked for calculation which the plugin does not support!\");\n        }\n    }\n    Send();\n}\n\nvoid ExampleCalcAppPlugin2::Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x)\n{\n    CalculatedValueIdentifier calc_id(rowId, columnId);\n    Double result;\n    if( x.Empty() )\n        result.SetError(\"Missing X parameter\");\n    else\n        result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5;\n    Update(calc_id, result);\n}\n\nbool ExampleCalcAppPlugin2::HandlePartialPricingModifyRequest(const CalculatedValuesRequestUpdate &update)\n{\n    if (update.GetRowsBegin() != update.GetRowsEnd())\n<fim-suffix><fim-middle>    {\n        return false;\n    }"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data;<fim-suffix>void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size =<fim-middle>} template <>"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n<fim-suffix><fim-middle>        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\" #include \"ConstantVolatility.h\" #include \"StochasticVolatilityInspired.h\" #include<fim-suffix><fim-middle>\"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #endif \/\/ __SHARED__VOLATILITY__VOLATILITY_MODELS__H"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status); ~PositionsData(); void Stop(); public: using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>; const Data& GetData() const { return m_data; } protected: \/\/ Stream::IHandler<fim-suffix>void HandleStreamStale(const<fim-middle>void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n\n    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;\n\n    bool ParallelVerticalShift() const;\n\n    const InstrumentGroup & GetCurrentProductGroup() const { return m_instrumentGroup.GetInstrumentGroup(); }\n    const InstrumentGroup & GetReferenceInstrumentGroup() const { return m_refInstrumentGroup.GetInstrumentGroup(); }\n\n    const InstrumentIdentifier & GetFocusInstrumentIdentifier() const { return m_followedInstrumentId.GetInstrumentIdentifier(); }\n    const Integer & GetFocusInstrumentGroupType() const { return m_instrumentGroupType.GetInteger(); }\n\n    bool NoLayoutInterfaceMode() const { return !m_noLayoutInterfaceMode.Empty() && m_noLayoutInterfaceMode.GetBoolean(); }\n\n    bool GlobalAutoApplyManualFit() const { return !m_globalAutoApplyManualFit.Empty() && m_globalAutoApplyManualFit.GetBoolean(); }\n\n    bool GlobalAutoSuggest() const { return !m_globalAutoSuggest.Empty() && m_globalAutoSuggest.GetBoolean(); }\n\n    int CurveShiftUnits() const;\n\n    bool UseExoticOptions() const { return m_currentProductCommonValuesHandler.UseExoticOptions(); }\n    const CalculatedPropertyFilter & GetInstrumentFilter() const { return m_currentProductCommonValuesHandler.GetInstrumentFilter(); }\n\n    bool IsLiveFeedDisabled() const { return !m_disableLiveFeed.Empty() && m_disableLiveFeed.GetBoolean(); }\n\n    const Integer & GetForegroundCalculationThrottlingMilliseconds() { return m_calculationStreamThrottlingMilliseconds.GetInteger(); }\n\n    bool PreserveZooming() const { return !m_preserveZooming.Empty() && m_preserveZooming.GetBoolean(); }\n\n    bool SafetyCheckEnabled() const { return !m_volatilityCurveSafetyCheckEnabled.Empty() && m_volatilityCurveSafetyCheckEnabled.GetBoolean(); }\n\n    bool ShouldConfirmClearModelAction() const { return !m_confirmClearModelAction.Empty() && m_confirmClearModelAction.GetBoolean(); }\n\n    const InstrumentGroupIdentifier & GetCurrentReferenceProductGroupId() const { return m_refInstrumentGroup.GetInstrumentGroup().GetIdentifier(); }\n\n    const DateTime & GetValuationDate() const { return m_valuationDate.GetDateTime(); }\n<fim-suffix><fim-middle>    const DateTime & GetMarketDataDateTime() const { return m_marketDataDateTime.GetDateTime(); }"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n<fim-suffix><fim-middle>using namespace rapidjson;"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired) VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel) VOLATILITY_MODEL_WRAP(None,ConstantVolatility)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(MyCustom,MyCustomVolatilityModel)"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const<fim-suffix>: m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); \/\/ Perform an operation SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ <<<fim-middle>StrategyParameters & parameters)"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_importOnce(false)\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n<fim-suffix><fim-middle>void InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n\nclass DeribitModel\n{\n\npublic:\n    DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler);\n    ~DeribitModel() noexcept = default;\n\n    void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update);\n<fim-suffix><fim-middle>    const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); }"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n<fim-suffix><fim-middle>    bool IsError() const;\n    const Error & GetError() const;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h><fim-suffix>using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream<fim-middle>CLANG_RESTORE_WARNINGS #include <sstream>"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nusing InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>;\nusing UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>;\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n\n    InstrumentManager(IHandler& handler);\n    ~InstrumentManager();\n    void Start();\n    void Stop();\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;\n<fim-suffix><fim-middle>    void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {};"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd())<fim-suffix><fim-middle>{ return t->value.GetInt64();"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\<fim-suffix><fim-middle>{ \\ auto& msg = m_doc->msg; \\"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h><fim-suffix>{ public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected:<fim-middle>class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitModel.h\"\n#include <shared\/API.h>\n\nclass DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler\n<fim-suffix><fim-middle>{\npublic:\n    DeribitMdp();\n    ~DeribitMdp() noexcept override = default;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) {<fim-suffix><fim-middle>if (val.size() <= 0)"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"PositionRetriever.h\" #include \"PositionReverser.h\" class ReversalManager : public PositionRetriever::IHandler, public tbricks::ITimerEventHandler { public: class IHandler; ReversalManager(IHandler& callback); ~ReversalManager() = default;<fim-suffix>const tbricks::Integer& priceSource, const tbricks::Time& startTime); void Stop(); \/\/ Timer handler. void<fim-middle>void Start( const tbricks::PortfolioIdentifier& portfolioId,"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t); void OnHeartbeat(deribit::JsonReply && incoming); void OnTestReply(SingleTransaction & t); void OnSubscribeReply(SingleTransaction & t); void OnSubscriptionUpdate(deribit::JsonReply && incoming); private: SingleTransaction & NewTransaction(const tbricks::Identifier & uuid = tbricks::Uuid::Create()); protected: void PerformTransaction(SingleTransaction & t); private: IHandler & m_handler;<fim-suffix>Session m_session; tbricks::Timer m_timer; std::vector<deribit::Method><fim-middle>std::unique_ptr<TbWebsocketClient> m_ws; TbWebsocketClient::Config m_conf;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n<fim-suffix><fim-middle>const JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\"\n#include \"tbricks_definitions.h\"\n#include <cstdlib>\n\nusing namespace tbricks;\n\nExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) :\n        Pricing(request)\n{\n    srand (time(NULL)); \/\/ Initialize random seed.\n\n    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n    SnapshotDone();\n}\n\nvoid ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request)\n{\n    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n}\n\nvoid ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request)\n{\n    for (const auto & civ_it : request.GetColumns())\n    {\n        if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue())\n        {\n            Double x;\n            StrategyParameters parameters;\n            civ_it.GetColumnInfo().GetParameters(parameters);\n            parameters.GetParameter(strategy_parameters::X(), x);\n            for (const auto & ivids_it : values)\n            {\n                CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId());\n                Double result;\n                if( x.Empty() )\n                    result.SetError(\"Missing X parameter\");\n                else\n                    result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5;\n                Update(calc_id, result);\n            }\n        }\n        else\n        {\n        }\n    }\n    Send();\n}\n\n<fim-suffix><fim-middle>DEFINE_PRICING_ENTRY(ExampleCalcAppPlugin)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n<fim-suffix><fim-middle>    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"..\/VolatilityManagerSettings.h\"\n#include \"..\/ImpliedVolatilitySourcesManagerCore.h\"\n#include \"..\/..\/preferences_editor\/tbricks_definitions.h\" \/\/ FIXME: Remove when cp definitions are generated for shared\/system meta (TB-103467)\n#include <shared\/Macros.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/String.h>\n#include <strategy\/Instrument.h>\n#include <strategy\/Definitions.h>\n#include <strategy\/Logger.h>\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n#include <iostream>\n#include <cmath>\n\nconst CalculatedPropertyFilter PreferencesStorage::dummyFilter = CalculatedPropertyFilter::Condition(\n    vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::NE, Integer());\n\nPreferencesStorage::PreferencesStorage() :\n    autoFit(false),\n    autoApplyAutoFit(false),\n    globalAvoidExtraFits(true),\n    globalUnderlyingTradingStatusTracking(true),\n    optionTradingStatusTracking(volatility_manager_settings::DEFAULT_AUTO_FIT_OPTION_TRADING_STATUS_TRACKING),\n    loggingMode(enumerations::VolatilityManagerLoggingModeVerbose),\n    maxAllowedFitRejects(),\n    maturityExcludedFromGlobalActions(false),\n    sendQuotingRecommendations(false),\n    quotingRecommendations(),\n    parallelShift(true),\n    curveShiftUnits(enumerations::VolatilityManagerCurveShiftUnitsVolatility),\n    ATMVolatilityShiftMode(ATM_VolatilityShiftModeShiftSingleATM_Point),\n    includeExoticOptions(volatility_manager_settings::DEFAULT_USE_EXOTIC_OPTIONS_OPTION),\n    autoFetchATMVolatilityPath(false),\n    globalAutoFetchATMVolatilityPath(volatility_manager_settings::DEFAULT_ATM_VOL_PATH_AUTO_FETCH_OPTION),\n    instrumentGroupType(VolatilityManagerInstrumentGroupTypeDerivative),\n    suggestContext(parameter_contexts::VM_Suggest()),\n    trackingAreaType(enumerations::VolatilityManagerTrackingAreaTypeBasedOnAllStrikes),\n    volatilityCurveSafetyCheckEnabled(false),\n    safetyParameterChange(volatility_manager_settings::DEFAULT_SAFETY_PARAMETERS_CHANGES),\n    safetyModelChange(volatility_manager_settings::DEFAULT_SAFETY_MODEL_CHANGES),\n    checkForStaticArbitrage(false),\n    calendarSpreadArbitrageTolerance(volatility_manager_settings::DEFAULT_CALENDAR_SPREAD_ARBITRAGE_TOLERANCE),\n    butterflyArbitrageTolerance(volatility_manager_settings::DEFAULT_BUTTERFLY_ARBITRAGE_TOLERANCE),\n    enableCurveQualityMetrics(false),\n    fitWeighting(FitWeightingInvertedSpread),\n    autocorrectFitWeights(true),\n    fitOnlyATMVol(false),\n    addVirtualBids(volatility_manager_settings::DEFAULT_ADD_VIRTUAL_BIDS),\n    virtualBidRatio(volatility_manager_settings::DEFAULT_VIRTUAL_BID_MULTIPLIER),\n    robustFittingOnWings(false),\n    robustFittingOnWingsStrength(volatility_manager_settings::DEFAULT_ROBUST_FITTING_ON_WINGS_STRENGTH),\n    autoResetSwimRefPriceToATM(false),\n    crossingProcessing(tbricks::enumerations::VolatilityManagerCrossingProcessingSkip),\n    anomalyDetection(false),\n    anomalyDetectionSensitivity(volatility_manager_settings::DEFAULT_ANOMALY_DETECTION_SENSITIVITY),\n    enableAmerican(true),\n    enableATM(true),\n    enableDeepITM(true),\n    enableDeepOTM(true),\n    enableEuropean(true),\n    enableITM(true),\n    enableCashDelivery(true),\n    enableCrossings(true),\n    enableLowBids(true),\n    enablePhysicalDelivery(true),\n    enableSmallDelta(true),\n    enableWideSpreads(true),\n    enableNoSpreads(true),\n    enableOTM(true),\n    enableLowVolumes(true),\n    minimumBidPrice(),\n    minimumVolume(),\n    manuallyToggledPoints(),\n    impliedVolatilitySources(),\n    tradingPhaseProcessing(enumerations::VolatilityManagerTradingPhaseProcessingAllTradingPhases),\n    showExcludedPoints(volatility_manager_settings::DEFAULT_SHOW_EXCLUDED_VOL_POINTS),\n    autocorrectVolatilityChartZooming(true),\n    deltaValueForVerticalLines(volatility_manager_settings::DEFAULT_DELTA_VALUE_FOR_VERTICAL_LINES),\n    showVerticalLinesAtGivenDelta(volatility_manager_settings::DEFAULT_SHOW_VERTICAL_LINES_AT_DELTA),\n    volatilityCurveChartAutoRangePadding(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_PADDING),\n    portfolio(),\n    preserveZooming(volatility_manager_settings::DEFAULT_PRESERVE_ZOOMING_OPTION),\n    distanceBetweenCurvePoints(volatility_manager_settings::CHART_DEFAULT_CURVE_DISTANCE_BETWEEN_DRAWN_POINTS),\n    autoRangeMode(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_MODE),\n    showReferenceVols(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_VOLS),\n    showReferenceCurve(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_CURVE),\n    showBidAskRange(volatility_manager_settings::DEFAULT_SHOW_BID_ASK_RANGE),\n    putCallColors(enumerations::VolatilityManagerPut_DIV_CallColorsDefault),\n    colorScheme(enumerations::VolatilityManagerChartColorSchemePale)\n{\n    Table impliedVolSources;\n    ImpliedVolatilitySourcesManagerCore::SetupTable(impliedVolSources, \/* useTreeNodes = *\/ true);\n    impliedVolatilitySources.SetDefault(impliedVolSources);\n\n    m_scopeLevelAnchoredPreferences = {\n        tree_node_parameters::VolatilityManagerAutomaticFit(),\n        tree_node_parameters::VolatilityManagerAutoApplyAutoFit(),\n        tree_node_parameters::VolatilityManagerAutoResetSwimReferencePrice(),\n        tree_node_parameters::VolatilityManagerMaturityExcluded(),\n        tree_node_parameters::VolatilityManagerManuallyToggledVolatilityPoints()\n    };\n\n    CalculatedPropertyFilter defaultInstrumentFilter = CalculatedPropertyFilter::Condition(\n        vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::EQ, Enumeration(Instrument::CFI_Variant::Undefined));\n\n    instrumentFilter.SetDefault(defaultInstrumentFilter);\n}\n\nPreferencesStorage::~PreferencesStorage()\n{}\n\nvoid PreferencesStorage::Clear()\n{\n    autoFit.ClearValue();\n    autoApplyAutoFit.ClearValue();\n    globalAvoidExtraFits.ClearValue();\n    globalUnderlyingTradingStatusTracking.ClearValue();\n    optionTradingStatusTracking.ClearValue();\n    loggingMode.ClearValue();\n    maxAllowedFitRejects.ClearValue();\n    maturityExcludedFromGlobalActions.ClearValue();\n    sendQuotingRecommendations.ClearValue();\n    quotingRecommendations.ClearValue();\n\n    parallelShift.ClearValue();\n    curveShiftUnits.ClearValue();\n    ATMVolatilityShiftMode.ClearValue();\n    includeExoticOptions.ClearValue();\n    autoFetchATMVolatilityPath.ClearValue();\n    globalAutoFetchATMVolatilityPath.ClearValue();\n    instrumentGroupType.ClearValue();\n    suggestContext.ClearValue();\n    trackingAreaType.ClearValue();\n    volatilityCurveSafetyCheckEnabled.ClearValue();\n    safetyParameterChange.ClearValue();\n    safetyModelChange.ClearValue();\n    checkForStaticArbitrage.ClearValue();\n    calendarSpreadArbitrageTolerance.ClearValue();\n    butterflyArbitrageTolerance.ClearValue();\n    enableCurveQualityMetrics.ClearValue();\n\n    fitWeighting.ClearValue();\n    autocorrectFitWeights.ClearValue();\n    fitOnlyATMVol.ClearValue();\n    addVirtualBids.ClearValue();\n    virtualBidRatio.ClearValue();\n    robustFittingOnWings.ClearValue();\n    robustFittingOnWingsStrength.ClearValue();\n    autoResetSwimRefPriceToATM.ClearValue();\n    crossingProcessing.ClearValue();\n    anomalyDetection.ClearValue();\n    anomalyDetectionSensitivity.ClearValue();\n<fim-suffix><fim-middle>    enableAmerican.ClearValue();\n    enableATM.ClearValue();\n    enableDeepITM.ClearValue();"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \"<fim-suffix>MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); } void DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); } void DeribitContributor::FailWithReason(const String & reason) { SetTransactionFail(reason, StrategyState::PAUSED); } void DeribitContributor::HandleDeribitConnected() { TBDEBUG(__func__); SetState(StrategyState::RUNNING); m_client->SetHeartbeat(30); } void<fim-middle><< modifier); \/\/ Accept all modified parameters and attributes     GetParameters().Merge(modifier.GetParameters());"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);<fim-suffix>tbricks::Identifier m_tickerId; };<fim-middle>tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem;"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n<fim-suffix><fim-middle>    void HandleTimerEvent(tbricks::Timer & timer) final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public:<fim-suffix><fim-middle>DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n<fim-suffix><fim-middle>    {\n        long timeout_request = 0;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument);<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); } void DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); } void DeribitContributor::FailWithReason(const String & reason) { SetTransactionFail(reason, StrategyState::PAUSED); } void DeribitContributor::HandleDeribitConnected() { TBDEBUG(__func__); SetState(StrategyState::RUNNING);<fim-suffix>{ TBDEBUG(__func__);<fim-middle>m_client->SetHeartbeat(30); } void DeribitContributor::HandleDeribitDisconnected()"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String&<fim-suffix><fim-middle>reason) = 0; };"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \" + m_frequency.ToString(); } m_handler.HandleTimerControllerUpdate(status, \/*error<fim-suffix>void TimerController::Stop() { TBDEBUG(__func__); m_startTimerEvent.Stop();<fim-middle>=*\/ false); }"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/EventProcessor.h>\n#include <future>\n\nnamespace misc {\n\nclass AsyncProcessor\n<fim-suffix><fim-middle>{\nprivate:\n    const tbricks::EventProcessor& m_proc;\n    tbricks::StrategyIdentifier m_id;"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\"\n#include \"shared\/order_minion\/OrderMinionCancelRequest.h\"\n#include \"shared\/order_minion\/tbricks_definitions.h\"\n#include \"shared\/sdk_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters)\n: OrderExecutor(handler)\n, m_controller( reason, app)\n{\n    TBDEBUG(__func__);\n\n}\n\nTbOrderMinion::~TbOrderMinion()\n{\n    TBDEBUG(__func__);\n    DeleteOrders();\n}\n\nvoid TbOrderMinion::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume, \/\/ negative for sell\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n\n    OrderMinionRequest req(this);\n    req.SetExecution(enumerations::OrderMinionExecutionHitRepeatedly);\n    req.SetIVID(ivid);\n    req.SetMarketDataIVID(ivid);\n    req.SetPortfolio(portfolio);\n    req.SetSide((volume > 0.0 ? Side::BUY : Side::SELL));\n    req.SetVolume(volume.Abs());\n    req.SetPriceMode(enumerations::OrderMinionPrice::OrderMinionPriceBestPossible);\n\n    auto result = m_controller.Request(req);\n    if (result == OrderMinionController::FAILURE)\n    {\n        m_handler.PanicStop(result.GetError());\n        return;\n    }\n    m_requests[ivid] = req;\n}\n\nvoid TbOrderMinion::DeleteOrders()\n{\n    TBDEBUG(__func__);\n    m_controller.Stop();\n}\n<fim-suffix><fim-middle>void TbOrderMinion::MonitorInstrument(const InstrumentVenueIdentification &ivid)\n{\n    m_controller.Prepare(ivid);\n}"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool<fim-suffix>}; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters);<fim-middle>error) = 0;"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start<fim-suffix>status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \"<fim-middle>with just the start time         m_startTimerEvent.Start(m_startTime);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n<fim-suffix><fim-middle>    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n<fim-suffix><fim-middle>{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port<fim-suffix><fim-middle>= 80; };"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData {<fim-suffix>virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double<fim-middle>public: UpdateData();"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { \/\/ Here is<fim-suffix><fim-middle>where we would open the DistributedValues::Stream }"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\" #include \"shared\/order_minion\/OrderMinionCancelRequest.h\" #include \"shared\/order_minion\/tbricks_definitions.h\" #include \"shared\/sdk_definitions.h\" using namespace tbricks; namespace execution { TbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters) : OrderExecutor(handler) , m_controller( reason, app) { TBDEBUG(__func__); } TbOrderMinion::~TbOrderMinion() { TBDEBUG(__func__); DeleteOrders(); } void TbOrderMinion::CreateOrder( const InstrumentVenueIdentification& ivid, const Volume& volume, \/\/ negative for sell const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio); OrderMinionRequest req(this); req.SetExecution(enumerations::OrderMinionExecutionHitRepeatedly); req.SetIVID(ivid); req.SetMarketDataIVID(ivid); req.SetPortfolio(portfolio); req.SetSide((volume > 0.0 ? Side::BUY : Side::SELL)); req.SetVolume(volume.Abs()); req.SetPriceMode(enumerations::OrderMinionPrice::OrderMinionPriceBestPossible); auto result = m_controller.Request(req); if (result<fim-suffix>return; }<fim-middle>== OrderMinionController::FAILURE) { m_handler.PanicStop(result.GetError());"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n<fim-suffix><fim-middle>{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume {0}; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail() { InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::SendSnapshotDoneIfNeeded() { TBDEBUG(__func__); if (TB_UNLIKELY(!m_snapshotDone)) { m_mdItem.SendSnapshotDone(); m_snapshotDone = true; }<fim-suffix><fim-middle>}"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n<fim-suffix><fim-middle>        m_index += sizeof(T);\n    }"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary &<fim-suffix><fim-middle>out) { out = m_data;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"..\/VolatilityManagerSettings.h\"\n#include \"..\/ImpliedVolatilitySourcesManagerCore.h\"\n#include \"..\/..\/preferences_editor\/tbricks_definitions.h\" \/\/ FIXME: Remove when cp definitions are generated for shared\/system meta (TB-103467)\n#include <shared\/Macros.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/String.h>\n#include <strategy\/Instrument.h>\n#include <strategy\/Definitions.h>\n#include <strategy\/Logger.h>\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n#include <iostream>\n#include <cmath>\n\nconst CalculatedPropertyFilter PreferencesStorage::dummyFilter = CalculatedPropertyFilter::Condition(\n    vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::NE, Integer());\n\nPreferencesStorage::PreferencesStorage() :\n    autoFit(false),\n    autoApplyAutoFit(false),\n    globalAvoidExtraFits(true),\n    globalUnderlyingTradingStatusTracking(true),\n    optionTradingStatusTracking(volatility_manager_settings::DEFAULT_AUTO_FIT_OPTION_TRADING_STATUS_TRACKING),\n    loggingMode(enumerations::VolatilityManagerLoggingModeVerbose),\n    maxAllowedFitRejects(),\n    maturityExcludedFromGlobalActions(false),\n    sendQuotingRecommendations(false),\n    quotingRecommendations(),\n    parallelShift(true),\n    curveShiftUnits(enumerations::VolatilityManagerCurveShiftUnitsVolatility),\n    ATMVolatilityShiftMode(ATM_VolatilityShiftModeShiftSingleATM_Point),\n    includeExoticOptions(volatility_manager_settings::DEFAULT_USE_EXOTIC_OPTIONS_OPTION),\n    autoFetchATMVolatilityPath(false),\n    globalAutoFetchATMVolatilityPath(volatility_manager_settings::DEFAULT_ATM_VOL_PATH_AUTO_FETCH_OPTION),\n    instrumentGroupType(VolatilityManagerInstrumentGroupTypeDerivative),\n    suggestContext(parameter_contexts::VM_Suggest()),\n    trackingAreaType(enumerations::VolatilityManagerTrackingAreaTypeBasedOnAllStrikes),\n    volatilityCurveSafetyCheckEnabled(false),\n    safetyParameterChange(volatility_manager_settings::DEFAULT_SAFETY_PARAMETERS_CHANGES),\n    safetyModelChange(volatility_manager_settings::DEFAULT_SAFETY_MODEL_CHANGES),\n    checkForStaticArbitrage(false),\n    calendarSpreadArbitrageTolerance(volatility_manager_settings::DEFAULT_CALENDAR_SPREAD_ARBITRAGE_TOLERANCE),\n    butterflyArbitrageTolerance(volatility_manager_settings::DEFAULT_BUTTERFLY_ARBITRAGE_TOLERANCE),\n    enableCurveQualityMetrics(false),\n    fitWeighting(FitWeightingInvertedSpread),\n    autocorrectFitWeights(true),\n    fitOnlyATMVol(false),\n    addVirtualBids(volatility_manager_settings::DEFAULT_ADD_VIRTUAL_BIDS),\n    virtualBidRatio(volatility_manager_settings::DEFAULT_VIRTUAL_BID_MULTIPLIER),\n    robustFittingOnWings(false),\n    robustFittingOnWingsStrength(volatility_manager_settings::DEFAULT_ROBUST_FITTING_ON_WINGS_STRENGTH),\n    autoResetSwimRefPriceToATM(false),\n    crossingProcessing(tbricks::enumerations::VolatilityManagerCrossingProcessingSkip),\n    anomalyDetection(false),\n    anomalyDetectionSensitivity(volatility_manager_settings::DEFAULT_ANOMALY_DETECTION_SENSITIVITY),\n    enableAmerican(true),\n    enableATM(true),\n    enableDeepITM(true),\n    enableDeepOTM(true),\n    enableEuropean(true),\n    enableITM(true),\n    enableCashDelivery(true),\n    enableCrossings(true),\n    enableLowBids(true),\n    enablePhysicalDelivery(true),\n    enableSmallDelta(true),\n    enableWideSpreads(true),\n    enableNoSpreads(true),\n    enableOTM(true),\n    enableLowVolumes(true),\n    minimumBidPrice(),\n    minimumVolume(),\n    manuallyToggledPoints(),\n    impliedVolatilitySources(),\n    tradingPhaseProcessing(enumerations::VolatilityManagerTradingPhaseProcessingAllTradingPhases),\n    showExcludedPoints(volatility_manager_settings::DEFAULT_SHOW_EXCLUDED_VOL_POINTS),\n    autocorrectVolatilityChartZooming(true),\n    deltaValueForVerticalLines(volatility_manager_settings::DEFAULT_DELTA_VALUE_FOR_VERTICAL_LINES),\n    showVerticalLinesAtGivenDelta(volatility_manager_settings::DEFAULT_SHOW_VERTICAL_LINES_AT_DELTA),\n    volatilityCurveChartAutoRangePadding(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_PADDING),\n    portfolio(),\n    preserveZooming(volatility_manager_settings::DEFAULT_PRESERVE_ZOOMING_OPTION),\n    distanceBetweenCurvePoints(volatility_manager_settings::CHART_DEFAULT_CURVE_DISTANCE_BETWEEN_DRAWN_POINTS),\n    autoRangeMode(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_MODE),\n    showReferenceVols(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_VOLS),\n    showReferenceCurve(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_CURVE),\n    showBidAskRange(volatility_manager_settings::DEFAULT_SHOW_BID_ASK_RANGE),\n    putCallColors(enumerations::VolatilityManagerPut_DIV_CallColorsDefault),\n    colorScheme(enumerations::VolatilityManagerChartColorSchemePale)\n{\n    Table impliedVolSources;\n<fim-suffix><fim-middle>    ImpliedVolatilitySourcesManagerCore::SetupTable(impliedVolSources, \/* useTreeNodes = *\/ true);\n    impliedVolatilitySources.SetDefault(impliedVolSources);"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear(); m_wasStreamStale = false; TBDEBUG(__func__); if (m_positionStream.IsOpen()) { m_positionStream.Close(); } m_positionStream.Open( Stream::SNAPSHOT, portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, AnyPositionFilter()); } void PositionRetriever::Stop() { m_positionStream.Close(); m_positions.clear(); } void PositionRetriever::HandleStreamOpen(const StreamIdentifier& stream_id) { if<fim-suffix><fim-middle>(m_positionStream.GetIdentifier() == stream_id) {"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}"}
{"content":"<fim-prefix>#pragma once #include \"IExecutionHandler.h\" #include \"shared\/API.h\" namespace execution { class OrderExecutor { public: virtual ~OrderExecutor() = default; OrderExecutor(IExecutionHandler& handler) : m_handler(handler) { m_stats.bought = 0.0; m_stats.sold = 0.0; m_stats.valueBought = 0.0; m_stats.valueSold = 0.0; } virtual void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const<fim-suffix>virtual void DeleteOrders() = 0; protected:<fim-middle>tbricks::PortfolioIdentifier& portfolio) = 0;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() {<fim-suffix><fim-middle>return m_startTimerEvent.IsActive(); }"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\nprotected:\n    void HandleRunRequest() override;\n    void HandlePauseRequest() override;\n    void HandleDeleteRequest() override;\n    void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override;\n    void HandleValidateRequest(tbricks::ValidationContext & context) override;\n    void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override;\n    void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override;\n\n    void HandleDeribitConnected() override;\n    void HandleDeribitDisconnected() override;\n    void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override;\n\nprivate:\n    void FailWithReason(const tbricks::String & reason);\n    std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument);\n<fim-suffix><fim-middle>    tbricks::StringParameter m_clientID;\n    tbricks::StringParameter m_clientSecret;\n    tbricks::StringParameter m_endpoint;"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT, PUBLIC_GetInstruments, }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; case DeribitMethod::PUBLIC_GetInstruments: return \"public\/get_instruments\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) {<fim-suffix><fim-middle>case DeribitSubscription::SUB_Ticker: return \"ticker\";"}
{"content":"<fim-prefix>#pragma once #include \"IExecutionHandler.h\" #include \"shared\/API.h\" namespace execution { class OrderExecutor {<fim-suffix>OrderExecutor(IExecutionHandler& handler) : m_handler(handler) { m_stats.bought = 0.0; m_stats.sold = 0.0; m_stats.valueBought = 0.0; m_stats.valueSold = 0.0; } virtual void CreateOrder( const tbricks::InstrumentVenueIdentification&<fim-middle>public: virtual ~OrderExecutor() = default;"}
{"content":"<fim-prefix>#include \"..\/..\/my_custom_pricing\/tbricks_definitions.h\"\n<fim-suffix><fim-middle>constexpr VolatilityModel VolatilityModelMyCustom = VolatilityModel(custom::pricing::extended_enums::VolatilityModelMyCustom);"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n<fim-suffix><fim-middle>using namespace tbricks;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg<fim-suffix>auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\");<fim-middle>= m_doc->msg;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct<fim-suffix>{ Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t); void OnHeartbeat(deribit::JsonReply && incoming);<fim-middle>Subscription : public tbricks::Printable"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new<fim-suffix>{ delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String &<fim-middle>RapidDocument(); } UpdateData::~UpdateData()"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n<fim-suffix><fim-middle>{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n    ~DeribitContributor() noexcept override = default;"}
{"content":"<fim-prefix>#include \"shared\/API.h\"\n#include \"InstrumentPricing.h\"\n#include \"util\/Log.h\"\n#include \"PricingPlugin.h\"\n#include \"InstrumentFilterSubscriber.h\"\n#include \"Underlying.h\"\n#include \"payments\/DividendInstrument.h\"\n#include \"payments\/PaymentInstrument.h\"\n#include \"UnderlyingComponentsManager.h\"\n#include \"price_providers\/BarrierInstrument.h\"\n#include \"models\/ModelCalculatorFactory.h\"\n#include \"models\/TurboOptionModelCalculator.h\"\n#include \"models\/TurboOptionWithDividendsModelCalculator.h\"\n#include \"models\/MiniFutureModelCalculator.h\"\n#include \"models\/CallableBullBearContractModelCalculator.h\"\n#include \"models\/CBBCWithDividendsModelCalculator.h\"\n#include \"models\/CBBCBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/CBBCWithDividendsBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/BondModelCalculator.h\"\n#include \"models\/EquityReturnModelCalculator.h\"\n#include \"price_providers\/PriceProviderEmpty.h\"\n#include \"price_providers\/PriceProviderSingle.h\"\n#include \"price_providers\/PriceProviderQuote.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/interest_rate\/YieldCurveWrapper.h\"\n#include \"UserPreferencesSubscriber.h\"\n#include \"time\/TimeOptions.h\"\n#include \"time\/TimeValues.h\"\n#include \"time\/VolatilityTimeWeights.h\"\n#include \"time\/CalendarUtils.h\"\n#include <cmath>\n#include <algorithm>\n#include <type_traits>\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include \"shared\/combination\/ICombinationModel.h\"\n#include \"shared\/Macros.h\"\n#include <shared\/instrument_types\/InstrumentTypes.h>\n#include <shared\/metaprogramming\/Defer.hpp>\n\n#include \"util\/Tokens.h\"\n\n#include \"models\/EquityModelCalculator.h\"\n#include \"models\/ExternalModelCalculator.h\"\n#include \"models\/ExternalTaylorModelCalculator.h\"\n#include \"models\/ExternalModelDistributionCalculator.h\"\n\n#include \"models\/PricingCombinationModel.h\"\n#include \"models\/util\/MiscCalculations.h\"\n#include \"models\/util\/DividendsUtil.h\"\n\n#include \"shared\/datetime_helpers\/DateTimeHelpers.h\"\n#include \"shared\/smart_pointers\/IntrusiveWeakPointer.hpp\"\n\n#include <shared\/time\/TimeParser.h>\n#include <shared\/StateRestorer.hpp>\n\n#include \"tbricks_definitions.h\"\n#include \"shared\/pricing\/tbricks_constants.h\"\n\nusing namespace tbricks;\n\nstd::ostream & operator<<(std::ostream & os, const RelativeValuationTime val_time)\n{\n    using RVT = RelativeValuationTime;\n    switch (val_time) {\n    case RVT::NOW:                 return os << \"Now\";\n    case RVT::TODAY_CLOSE:         return os << \"Today close\";\n    case RVT::NEXT_OPEN:           return os << \"Next open\";\n    case RVT::NEXT_DAY:            return os << \"Next day\";\n    default:                       return os << \"Unrecognized valuation time\";\n    }\n}\n\nInstrumentPricing::InstrumentPricing(PricingPlugin & plugin, const InstrumentIdentification & id,\n                                     const InstrumentVenueIdentification & ivid,\n                                     std::shared_ptr<SnapshotToken> snapshot_token,\n                                     std::shared_ptr<ModificationToken> modification_token,\n                                     const LegSettingsPtr & leg_settings) :\n    m_id(id),\n    m_plugin(plugin),\n    m_ivid(new InstrumentVenueIdentification(ivid)),\n    m_leg_settings(leg_settings),\n    m_instrument(new Instrument()),\n    m_override_prices(new IPriceProvider::OverridePriceContainer()),\n    m_q(GetCalculationSettings().GetYield()),\n    m_today_values(new TimeValues()),\n    m_plugin_modify_version(plugin.GetPluginModifyVersion()),\n    m_snapshot_token(snapshot_token),\n    m_modification_token(modification_token)\n{\n    PDEBUGN(\"Create instrument pricing: \" << *m_ivid << \" row id = \" << GetRowIdentifier());\n\n    m_calculated_values_pool.reset(new CalculatedInstrumentValuesPool(plugin, *this));\n    PDEBUGN(\"Instrument size is \" << sizeof(*this) << \", pool size is \" << sizeof(*m_calculated_values_pool));\n\n    if (m_ivid->GetInstrumentIdentifier().Empty()) {\n        ResetSnapshotTokens();\n        m_snapshot_done = true;\n        return;\n    }\n<fim-suffix><fim-middle>    if (m_calculated_values_pool->GetValuesRequest().TimeGreeksIsActive()) {\n        m_today_close_values.reset(new TimeValues());\n        m_next_trading_open_values.reset(new TimeValues());\n        m_next_trading_day_values.reset(new TimeValues());"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream &<fim-suffix>void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const<fim-middle>stream, const tbricks::Binary & data) final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; private: \/\/ App<fim-suffix><fim-middle>parameters };"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is<fim-suffix>TBWARNING(m_plugInStatusDescription.GetString()); return false; } Strategy::SetState(StrategyState::RUNNING); return true; } void InstrumentEnricherPlugin::HandleImportComplete(const String& status) { TBDEBUG(__func__ << \" : \" << status); m_plugInStatusDescription = status; HandlePauseRequest(); } void InstrumentEnricherPlugin::HandleInstrumentManagerFailed(const String& reason) { TBWARNING(__func__ <<<fim-middle>empty\";"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n<fim-suffix><fim-middle>protected:\n    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n<fim-suffix><fim-middle>        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n<fim-suffix><fim-middle>        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility model types template <class ModelTypePtr> ModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel); template <class ModelTypePtr> ModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel); template <class ModelTypeRef> ModelTypeRef vol_model_cast(volatility::IVolatilityModel & model); template <class ModelTypeRef> ModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model); #define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\ { \\ if (TB_UNLIKELY(!pModel)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model*>(pModel); \\ } #define VOL_MODEL_REF_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model & vol_model_cast(specifier volatility::IVolatilityModel & rModel) \\ { \\ if (TB_UNLIKELY(rModel.GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type<fim-suffix>throw volatility::VolatilityModelTypeMismatchException(rModel.GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model&>(rModel); \\ } #define VOL_MODEL_CAST_IMPL(specifier, model, type) \\ VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ VOL_MODEL_REF_CAST_IMPL(specifier, model, type) VOL_MODEL_CAST_IMPL(const, ClampedCubicSpline, VolatilityModelCCS) VOL_MODEL_CAST_IMPL(, ClampedCubicSpline, VolatilityModelCCS) VOL_MODEL_CAST_IMPL(const, StochasticVolatilityInspired, VolatilityModelSVI) VOL_MODEL_CAST_IMPL(, StochasticVolatilityInspired, VolatilityModelSVI) VOL_MODEL_CAST_IMPL(const, WingVolatilityModel, VolatilityModelWing) VOL_MODEL_CAST_IMPL(, WingVolatilityModel, VolatilityModelWing) #undef VOL_MODEL_CAST_IMPL<fim-middle>\" << rModel.GetVolatilityModelType() << \" to type \" << type); \\"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str)<fim-suffix>{ Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString();<fim-middle>: UpdateData()"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return false; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { {<fim-suffix>} } diagnostics.GetDebugStream() <<<fim-middle>diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely picked up by another calc app \/\/ the engine was just checking if we responded to it }<fim-suffix>Send(); } \/\/ Note<fim-middle>}"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n<fim-suffix><fim-middle>{\npublic:\n    struct Config\n    {"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n\nUpdateData::~UpdateData()\n{\n    delete (m_doc);\n}\n\nstd::string_view UpdateData::ToString()\n{\n    m_doc->buffer.Clear();\n    Writer<StringBuffer> writer(m_doc->buffer);\n    m_doc->msg.Accept(writer);\n    return {m_doc->buffer.GetString()};\n}\n\nvoid UpdateData::Parse(const tbricks::String & str)\n{\n    m_doc->msg.Clear();\n    StringStream s(str.GetCString());\n    m_doc->msg.ParseStream(s);\n}\n\nticker_update::ticker_update(const tbricks::String & str)\n    : UpdateData()\n{\n    Parse(str);\n}\n\nstd::string_view ticker_update::GetInstrumentName()\n{\n    auto & msg = m_doc->msg;\n    auto i = msg.FindMember(\"instrument_name\");\n    if (i != msg.MemberEnd())\n<fim-suffix><fim-middle>    {\n        return i->value.GetString();\n    }\n    return {};"}
{"content":"<fim-prefix>#include \"ReversalManager.h\" #include \"tbricks_definitions.h\" #include <map> using namespace<fim-suffix><fim-middle>tbricks; ReversalManager::ReversalManager(IHandler& callback) : m_callback(callback)"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>(); case<fim-suffix>return<fim-middle>VolatilityModelSVI:"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n<fim-suffix><fim-middle>    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler<fim-suffix><fim-middle>void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override;"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n<fim-suffix><fim-middle>PersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n<fim-suffix><fim-middle>    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view<fim-suffix>protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double<fim-middle>ToString(); void Parse(const tbricks::String& str);"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double GetBid(); double GetAsk(); double GetBidVolume(); double GetAskVolume(); };<fim-suffix><fim-middle>} \/\/ deribit"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\<fim-suffix><fim-middle>auto & msg = m_doc->msg; \\"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String<fim-suffix><fim-middle>& str);"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT, PUBLIC_GetInstruments, }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; case DeribitMethod::PUBLIC_GetInstruments: return \"public\/get_instruments\"; default: return<fim-suffix>} } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return<fim-middle>{};"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n\nprotected:\n<fim-suffix><fim-middle>    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;\n    void HandleStreamClose(tbricks::TCPStream & stream) final;"}
{"content":"<fim-prefix>#pragma once\n#include <shared\/API.h>\n#include \"tbricks_definitions.h\"\n\nclass TimerController : public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual void HandleTimerEventHit() = 0;\n        virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0;\n    };\n\n    explicit TimerController(IHandler& handler);\n\n    ~TimerController() noexcept override = default;\n<fim-suffix><fim-middle>    void HandleTimerEvent(tbricks::Timer& timer) override;\n    void Update(const tbricks::StrategyParameters& strategyParameters);"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n<fim-suffix><fim-middle>        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class<fim-suffix>UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData<fim-middle>UpdateData { public:"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status;<fim-suffix>{ ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not<fim-middle>Statistics stats; for (auto i = update.begin(); i != update.end(); ++i)"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\" #include \"tbricks_definitions.h\" #include <cstdlib> #include <set> using namespace tbricks; ExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin2::HandlePricingModifyRequest(const PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin2::Calculate(const RequestAndIVIDs & values, const CalculatedValuesRequestFull & request) { m_rows = values; for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, civ_it.GetColumnId(), x); } } else { TBERROR(\"System asked for calculation which the plugin does not support!\"); } } Send(); } void ExampleCalcAppPlugin2::Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x) { CalculatedValueIdentifier calc_id(rowId, columnId); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } bool ExampleCalcAppPlugin2::HandlePartialPricingModifyRequest(const CalculatedValuesRequestUpdate &update) { if (update.GetRowsBegin() != update.GetRowsEnd()) { return false; } for(auto it = update.GetColumnsBegin(), end =<fim-suffix>{ if (it.GetColumnInfo().GetState() == CalculatedValuesRequestUpdate::State::UPDATE) { if( it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; it.GetColumnInfo().GetStrategyParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, it.GetColumnId(), x);<fim-middle>update.GetColumnsEnd(); it != end; ++it)"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n<fim-suffix><fim-middle>    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n        Channel channel; \/\/ should be always sorted\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n<fim-suffix><fim-middle>private:\n    void OnLoginReply(SingleTransaction & t);\n    void OnSetHeartbeatReply(SingleTransaction & t);\n    void OnHeartbeat(deribit::JsonReply && incoming);"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n<fim-suffix><fim-middle>        Channel channel; \/\/ should be always sorted"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler & handler)\n    : m_instrumentStream(*this)\n    , m_handler(handler)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Clear()\n{\n    m_tbricksInstruments.clear();\n    m_deribitInstruments.clear();\n    m_pendingCreates.clear();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n    \n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByVenueFilter(m_handler.GetVenueIdentifier()) && InstrumentStream::Filters::DeletedFilter(\/*deleted=*\/false));\n    m_instrumentStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n    \n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() \n            << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    String key = GetInstrumentKey(deribitInstrument);\n    m_deribitInstruments[key] = deribitInstrument;\n}\n\nString InstrumentManager::GetInstrumentKey(const Instrument & instrument)\n{\n    return instrument.GetShortName();\n}\n\nString InstrumentManager::GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    return deribitInstrument->instrument_name;\n}\n\nvoid InstrumentManager::Start()\n{\n    Clear();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::SyncInstruments()\n{\n    TBDEBUG(__func__ << \": Comparing \" << m_tbricksInstruments.size() \n            << \" Tbricks instruments with \" << m_deribitInstruments.size() \n            << \" Deribit instruments\");\n            \n    for (const auto & [key, deribitInst] : m_deribitInstruments)\n    {\n        auto tbricks_it = m_tbricksInstruments.find(key);\n        if (tbricks_it == m_tbricksInstruments.end())\n        {\n            if (not deribitInst->is_active)\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not active\");\n                continue;\n            }\n            if (deribitInst->instrument_type == \"linear\")\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is linear\");\n                continue;\n            }\n            if ((deribitInst->settlement_period != \"month\") and not deribitInst->settlement_period.Empty())\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not a monthly option\");\n                continue;\n            }\n            \n            CreateInstrument(deribitInst);\n        }\n        else\n        {\n            const auto & instrument = tbricks_it->second;\n            ModifyInstrument(instrument, deribitInst);\n        }\n    }\n}\n\nvoid InstrumentManager::CreateInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    TBDEBUG(__func__ << \": Creating instrument \" << deribitInstrument->instrument_name);\n\n    Instrument::Options options;\n    \n    options.SetShortName(deribitInstrument->instrument_name);\n    options.SetLongName(deribitInstrument->instrument_name);\n    \n    CFI cfi;\n    if (deribitInstrument->option_type == \"call\")\n    {\n        cfi = CFI(\"OC\", CFI::V2015);\n    }\n    else if (deribitInstrument->option_type == \"put\")\n    {\n        cfi = CFI(\"OP\", CFI::V2015);\n    }\n    options.SetCFI(cfi);\n\n    std::vector<VenueInstrumentIdentifier> viids;\n    VenueInstrumentIdentifier viid;\n    viid.SetVenueIdentifier(m_handler.GetVenueIdentifier());\n    viid.SetMIC(MIC(\"XCYS\")); \/\/ dummy MIC\n    viid.Add(\"symbol\", deribitInstrument->instrument_name);\n    viids.push_back(viid);\n    options.SetVenueInstrumentIdentifiers(viids);\n\n    std::vector<InstrumentGroup> instrumentGroups;\n    \n    InstrumentAttributes attributes;\n    \n    if (not deribitInstrument->expiration_timestamp.Empty())\n    {\n        attributes.SetMaturityDate(deribitInstrument->expiration_timestamp.GetCalendarDate());\n    }\n    \n    if (deribitInstrument->strike)\n    {\n        attributes.SetAttribute(instrument_attributes::StrikePrice(), Price(*deribitInstrument->strike));\n    }\n    \n    if (deribitInstrument->contract_size != 0.0)\n    {\n        attributes.SetAttribute(instrument_attributes::InstrumentMultiplier(), deribitInstrument->contract_size);\n    }\n\n    if (!deribitInstrument->counter_currency.Empty())\n    {\n        auto base_ccy = Currency(deribitInstrument->counter_currency);\n        attributes.SetAttribute(instrument_attributes::BaseCurrency(), base_ccy);\n        instrumentGroups.emplace_back(base_ccy.GetInstrumentGroupIdentifier());\n    }\n    \n    options.SetInstrumentGroups(instrumentGroups);\n\n    options.SetAttributes(attributes);\n\n    auto result = Instrument::SendCreateRequest(options, *this);\n    m_pendingCreates[result.GetRequestIdentifier()] = deribitInstrument->instrument_name;\n    TBDEBUG(__func__ << \": \" << options);\n}\n\nvoid InstrumentManager::ModifyInstrument(const Instrument & instrument, const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    TBFULLDUMP(__func__ << \": Potentially modifying instrument \" << deribitInstrument->instrument_name);\n\n    InstrumentModifier mod(instrument.GetIdentifier());\n    \n    CFI cfi;\n    if (deribitInstrument->option_type == \"call\")\n    {\n        cfi = CFI(\"OC\", CFI::V2015);\n    }\n    else if (deribitInstrument->option_type == \"put\")\n    {\n        cfi = CFI(\"OP\", CFI::V2015);\n    }\n    if (cfi != instrument.GetCFI())\n    {\n        mod.SetCFI(cfi);\n    }\n\n    VenueInstrumentIdentifier viid;\n    viid.SetVenueIdentifier(m_handler.GetVenueIdentifier());\n    viid.SetMIC(MIC(\"XCYS\")); \/\/ dummy MIC\n    viid.Add(\"symbol\", deribitInstrument->instrument_name);\n\n    std::vector<VenueInstrumentIdentifier> viids;\n    instrument.GetVenueInstrumentIdentifiers(viids);\n    auto it = std::find_if(viids.begin(), viids.end(), [viid](const VenueInstrumentIdentifier& v) { return v == viid; });\n    if (it == viids.end())\n<fim-suffix><fim-middle>    {\n        viids.clear();\n        viids.push_back(viid);\n        mod.AddVenueInstrumentIdentifiers(viids);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final;<fim-suffix>void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } \/\/ TimerController::IHandler void HandleTimerEventHit() final; void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final; private: bool CheckRunningRequirement(); void HandleAction(const tbricks::Integer<fim-middle>"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n<fim-suffix><fim-middle>        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\" class PositionsData; namespace execution { class OrderExecutor; } namespace misc { class AsyncProcessor; } class GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler { public: GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);<fim-suffix>void<fim-middle>protected: \/\/ Strategy methods     void HandleDeleteRequest() override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier &<fim-suffix>protected: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem<fim-middle>GetStreamId() const { return m_stream.GetIdentifier(); }"}
{"content":"<fim-prefix>#include \"PositionReversalsPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nPositionReversalsPlugin::PositionReversalsPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_manager(*this)\n    , m_portfolio(position_reversals::strategy_parameters::Portfolio())\n    , m_startTime(position_reversals::strategy_parameters::PositionReversalStartTime())\n    , m_priceSource(position_reversals::strategy_parameters::PositionReversalPriceSource())\n    , m_status(position_reversals::strategy_parameters::StatusInformationText())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    if (GetTransactionOperation().IsRun())\n    {\n        DoRun();\n    }\n\n}\n\nbool PositionReversalsPlugin::CanRun(tbricks::String& error)\n{\n    TBDEBUG(__func__);\n\n    if (m_portfolio.GetPortfolioIdentifier().Empty())\n    {\n        error = \"No portfolio selected\";\n        return false;\n    }\n\n    if (m_startTime.GetTime().Empty())\n    {\n        error = \"No start time selected\";\n        return false;\n    }\n\n    if (m_priceSource.GetInteger().Empty())\n    {\n        error = \"No price source selected\";\n        return false;\n    }\n\n    return true;\n}\n\nvoid PositionReversalsPlugin::DoRun()\n{\n    TBDEBUG(__func__);\n\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n    String error;\n    if (CanRun(error))\n    {\n        m_manager.Start(m_portfolio.GetPortfolioIdentifier(),\n                        m_priceSource.GetInteger(),\n                        m_startTime.GetTime());\n\n        SetState(StrategyState::RUNNING);\n    }\n    else\n    {\n        m_status = error;\n        SetTransactionFail(error);\n    }\n}\n\nvoid PositionReversalsPlugin::DoPause()\n{\n    m_manager.Stop();\n    SetState(StrategyState::PAUSED);\n}\n\nvoid PositionReversalsPlugin::HandleRunRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n    }\n    else\n    {\n        DoRun();\n    }\n}\n\nvoid PositionReversalsPlugin::HandlePauseRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsPaused())\n    {\n        TBDEBUG(\"Already paused\");\n    }\n    else\n    {\n        DoPause();\n    }\n}\n\nvoid PositionReversalsPlugin::HandleDeleteRequest(void)\n{\n    TBDEBUG(__func__);\n    DoPause();\n    SetState(StrategyState::DELETED);\n}\n\nvoid PositionReversalsPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" modifier: \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid PositionReversalsPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" constext:\"  << context);\n\n    context.SendReply();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewCreate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewUpdate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n<fim-suffix><fim-middle>    m_status = \"\";\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n<fim-suffix><fim-middle>    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\n<fim-suffix><fim-middle>namespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \" +<fim-suffix>m_handler.HandleTimerControllerUpdate(status, \/*error =*\/ false); } void TimerController::Stop() { TBDEBUG(__func__); m_startTimerEvent.Stop(); }<fim-middle>m_frequency.ToString(); }"}
{"content":"<fim-prefix>#pragma once #include <third_party\/include\/rapidjson\/document.h> #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t);<fim-suffix>void OnHeartbeat(deribit::JsonReply && incoming); void OnTestReply(SingleTransaction & t); void OnSubscribeReply(SingleTransaction & t); void OnSubscriptionUpdate(deribit::JsonReply && incoming); void OnInstrumentDownload(SingleTransaction & t); private: SingleTransaction & NewTransaction(const tbricks::Identifier & uuid = tbricks::Uuid::Create()); protected: void PerformTransaction(SingleTransaction & t); private: IHandler & m_handler; std::unique_ptr<TbWebsocketClient> m_ws; TbWebsocketClient::Config m_conf; Session m_session; tbricks::Timer m_timer; std::vector<deribit::Method> m_availableMethods = deribit::GetAvailableMethods(); std::unordered_map<tbricks::Identifier, SingleTransaction, TbricksHash><fim-middle>void OnSetHeartbeatReply(SingleTransaction & t);"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty())<fim-suffix><fim-middle>{ \/\/ start with just the frequency         m_startTimerEvent.Start(m_frequency);"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\ntypedef std::pair<DeribitMethod, std::string> Method;\n<fim-suffix><fim-middle>static std::vector<Method> GetAvailableMethods()\n{\n    return {"}
{"content":"<fim-prefix>#pragma once\n\n#include \"OrderExecutor.h\"\n#include \"shared\/MDTracker.h\"\n\nnamespace execution {\n\nclass TbOrderManager : public OrderExecutor,\n                       public tbricks::OrderManager,\n                       public tbricks::IRequestReplyHandler,\n                       public MDTracker::IHandler\n{\npublic:\n    TbOrderManager(IExecutionHandler& handler);\n    ~TbOrderManager();\n\n    void DeleteOrders() override;\n    void CreateOrder(\n        const tbricks::InstrumentVenueIdentification& ivid,\n        const tbricks::Volume& volume, \/\/ negative for sell\n        const tbricks::PortfolioIdentifier& portfolio) override;\n\nprotected:\n    void HandleOrderUpdate(const tbricks::Order::Update& update) override;\n    void HandleRecoveryCompleted() override;\n\n    void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override;\n\n    void HandleBBOUpdate( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::BestPrice& before, const tbricks::BestPrice& change ) override;\n    void HandleSnapshotEnd(const tbricks::InstrumentVenueIdentification& ivid) override;\n\nprivate:\n    void EmergencyStop();\n    void DeleteSingleOrder(const tbricks::OrderIdentifier& id);\n    void CreateSingleOrder(\n        const tbricks::InstrumentVenueIdentification& ivid,\n        const tbricks::Volume& volume,\n        const tbricks::Price& price,\n        const tbricks::Side& side,\n        const tbricks::PortfolioIdentifier& portfolio);\n    tbricks::Price RoundPriceToTicks(const tbricks::Price& price, const tbricks::Side& side, const tbricks::InstrumentVenueIdentification& ivid);\n    void UpdateStats(const tbricks::Order::Update& update, const tbricks::Order& current);\n\nprivate:\n    tbricks::Hash<tbricks::OrderIdentifier, tbricks::Order> m_orderData;\n    tbricks::Hash<tbricks::Identifier, tbricks::OrderIdentifier> m_requests;\n    tbricks::Hash<tbricks::InstrumentVenueIdentification, tbricks::OrderIdentifier> m_activeOrders;\n\nprivate:\n    struct OrderRequest\n    {\n        tbricks::InstrumentVenueIdentification ivid;\n        tbricks::Volume volume; \/\/ negative for sell\n        tbricks::PortfolioIdentifier portfolio;\n    };\n<fim-suffix><fim-middle>    MDTracker m_md;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return<fim-suffix>return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if<fim-middle>istm; istm.read(val, size);"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\"\n<fim-suffix><fim-middle>#include \"ConstantVolatility.h\"\n#include \"StochasticVolatilityInspired.h\"\n#include \"ClampedCubicSpline.h\"\n#include \"WingVolatilityModel.h\""}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice();<fim-suffix>double<fim-middle>double GetMarkPrice();"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);<fim-suffix><fim-middle>~TbWebsocketClient(); void Connect();"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double<fim-suffix><fim-middle>GetCurrentFunding(); double GetBid();"}
{"content":"<fim-prefix>#include \"PositionReversalsPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nPositionReversalsPlugin::PositionReversalsPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_manager(*this)\n    , m_portfolio(position_reversals::strategy_parameters::Portfolio())\n    , m_startTime(position_reversals::strategy_parameters::PositionReversalStartTime())\n    , m_priceSource(position_reversals::strategy_parameters::PositionReversalPriceSource())\n    , m_status(position_reversals::strategy_parameters::StatusInformationText())\n<fim-suffix><fim-middle>{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n<fim-suffix><fim-middle>template <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n<fim-suffix><fim-middle>{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); }<fim-suffix>BestPrice bbo; Price emptyPrice; Volume emptyVolume {0};<fim-middle>void DeribitModel::Reset() { InstrumentStatus status;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n<fim-suffix><fim-middle>        Channel channel; \/\/ should be always sorted"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update &<fim-suffix>protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice<fim-middle>update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); }"}
{"content":"<fim-prefix>#include \"shared\/API.h\"\n#include \"InstrumentPricing.h\"\n#include \"util\/Log.h\"\n#include \"PricingPlugin.h\"\n#include \"InstrumentFilterSubscriber.h\"\n#include \"Underlying.h\"\n#include \"payments\/DividendInstrument.h\"\n#include \"payments\/PaymentInstrument.h\"\n#include \"UnderlyingComponentsManager.h\"\n#include \"price_providers\/BarrierInstrument.h\"\n#include \"models\/ModelCalculatorFactory.h\"\n#include \"models\/TurboOptionModelCalculator.h\"\n#include \"models\/TurboOptionWithDividendsModelCalculator.h\"\n#include \"models\/MiniFutureModelCalculator.h\"\n#include \"models\/CallableBullBearContractModelCalculator.h\"\n#include \"models\/CBBCWithDividendsModelCalculator.h\"\n#include \"models\/CBBCBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/CBBCWithDividendsBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/BondModelCalculator.h\"\n#include \"models\/EquityReturnModelCalculator.h\"\n#include \"price_providers\/PriceProviderEmpty.h\"\n#include \"price_providers\/PriceProviderSingle.h\"\n#include \"price_providers\/PriceProviderQuote.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/interest_rate\/YieldCurveWrapper.h\"\n#include \"UserPreferencesSubscriber.h\"\n#include \"time\/TimeOptions.h\"\n#include \"time\/TimeValues.h\"\n#include \"time\/VolatilityTimeWeights.h\"\n#include \"time\/CalendarUtils.h\"\n#include <cmath>\n#include <algorithm>\n#include <type_traits>\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include \"shared\/combination\/ICombinationModel.h\"\n#include \"shared\/Macros.h\"\n#include <shared\/instrument_types\/InstrumentTypes.h>\n#include <shared\/metaprogramming\/Defer.hpp>\n\n#include \"util\/Tokens.h\"\n\n#include \"models\/EquityModelCalculator.h\"\n#include \"models\/ExternalModelCalculator.h\"\n#include \"models\/ExternalTaylorModelCalculator.h\"\n#include \"models\/ExternalModelDistributionCalculator.h\"\n\n#include \"models\/PricingCombinationModel.h\"\n#include \"models\/util\/MiscCalculations.h\"\n#include \"models\/util\/DividendsUtil.h\"\n\n#include \"shared\/datetime_helpers\/DateTimeHelpers.h\"\n#include \"shared\/smart_pointers\/IntrusiveWeakPointer.hpp\"\n\n#include <shared\/time\/TimeParser.h>\n#include <shared\/StateRestorer.hpp>\n\n#include \"tbricks_definitions.h\"\n#include \"shared\/pricing\/tbricks_constants.h\"\n\nusing namespace tbricks;\n\nstd::ostream & operator<<(std::ostream & os, const RelativeValuationTime val_time)\n<fim-suffix><fim-middle>{\n    using RVT = RelativeValuationTime;\n    switch (val_time) {\n    case RVT::NOW:                 return os << \"Now\";"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier &<fim-suffix>void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier<fim-middle>stream) override;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient();<fim-suffix><fim-middle>void Connect(const tbricks::String & userId, const tbricks::String & secret);"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"..\/VolatilityManagerSettings.h\"\n#include \"..\/ImpliedVolatilitySourcesManagerCore.h\"\n#include \"..\/..\/preferences_editor\/tbricks_definitions.h\" \/\/ FIXME: Remove when cp definitions are generated for shared\/system meta (TB-103467)\n#include <shared\/Macros.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/String.h>\n#include <strategy\/Instrument.h>\n#include <strategy\/Definitions.h>\n#include <strategy\/Logger.h>\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n#include <iostream>\n#include <cmath>\n\nconst CalculatedPropertyFilter PreferencesStorage::dummyFilter = CalculatedPropertyFilter::Condition(\n    vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::NE, Integer());\n\nPreferencesStorage::PreferencesStorage() :\n    autoFit(false),\n    autoApplyAutoFit(false),\n    globalAvoidExtraFits(true),\n    globalUnderlyingTradingStatusTracking(true),\n    optionTradingStatusTracking(volatility_manager_settings::DEFAULT_AUTO_FIT_OPTION_TRADING_STATUS_TRACKING),\n    loggingMode(enumerations::VolatilityManagerLoggingModeVerbose),\n    maxAllowedFitRejects(),\n    maturityExcludedFromGlobalActions(false),\n    sendQuotingRecommendations(false),\n    quotingRecommendations(),\n    parallelShift(true),\n    curveShiftUnits(enumerations::VolatilityManagerCurveShiftUnitsVolatility),\n    ATMVolatilityShiftMode(ATM_VolatilityShiftModeShiftSingleATM_Point),\n    includeExoticOptions(volatility_manager_settings::DEFAULT_USE_EXOTIC_OPTIONS_OPTION),\n    autoFetchATMVolatilityPath(false),\n    globalAutoFetchATMVolatilityPath(volatility_manager_settings::DEFAULT_ATM_VOL_PATH_AUTO_FETCH_OPTION),\n    instrumentGroupType(VolatilityManagerInstrumentGroupTypeDerivative),\n    suggestContext(parameter_contexts::VM_Suggest()),\n    trackingAreaType(enumerations::VolatilityManagerTrackingAreaTypeBasedOnAllStrikes),\n    volatilityCurveSafetyCheckEnabled(false),\n    safetyParameterChange(volatility_manager_settings::DEFAULT_SAFETY_PARAMETERS_CHANGES),\n    safetyModelChange(volatility_manager_settings::DEFAULT_SAFETY_MODEL_CHANGES),\n    checkForStaticArbitrage(false),\n    calendarSpreadArbitrageTolerance(volatility_manager_settings::DEFAULT_CALENDAR_SPREAD_ARBITRAGE_TOLERANCE),\n    butterflyArbitrageTolerance(volatility_manager_settings::DEFAULT_BUTTERFLY_ARBITRAGE_TOLERANCE),\n    enableCurveQualityMetrics(false),\n<fim-suffix><fim-middle>    fitWeighting(FitWeightingInvertedSpread),\n    autocorrectFitWeights(true),\n    fitOnlyATMVol(false),"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n<fim-suffix><fim-middle>    {\n    }"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely picked up by another calc app \/\/ the engine was just checking if we responded to it } } Send(); } \/\/<fim-suffix><fim-middle>Note that here we use DEFINE_PRICING_ENTRY instead of the normal DEFINE_STRATEGY_ENTRY DEFINE_PRICING_ENTRY(ExampleCalcAppPlugin)"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier)<fim-suffix><fim-middle>final;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction &<fim-suffix><fim-middle>t); void OnSetHeartbeatReply(SingleTransaction & t);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename T> void write(const T & t) { tbricks::Binary vec; vec.Set(reinterpret_cast<const void *>(&t), sizeof(T)); write(vec); } void write(const std::string & s) { write(s.c_str(), s.size()); } void write(const char * p, size_t size) { m_data.Append(p, size); } private: tbricks::Binary m_data; }; template <typename T> Binary_istream & operator>>(Binary_istream & istm, T & val) { istm.read(val); return istm;<fim-suffix><fim-middle>} template <typename T>"}
{"content":"<fim-prefix>#pragma once #include <strategy\/test\/TestEngine.h> using namespace tbricks; using namespace tbricks::test; #ifndef TIMEOUT #define TIMEOUT tbricks::Duration::Seconds(5) #endif void Test(TestEngine &te); tbricks::String get_current_root(); tbricks::String<fim-suffix>TestEngine te(\"..\/system.xml\", \"..\/engine.xml\"); te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\"); te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString()); te.RunTest(Test, TIMEOUT); return 0; } namespace go_flat { tbricks::VenueIdentifier GetTestVenueId() { return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"}; } tbricks::PortfolioIdentifier GetPortfolioId() { return {\"2eb2249c-bc89-11ee-a950-d946a31b499d\"}; } } \/\/ namespace go_flat #include <filesystem> namespace fs = std::filesystem; tbricks::String get_current_root() { fs::path current(fs::current_path()); fs::path apps; if (std::getenv(\"TB_APPS\") ==<fim-middle>get_apps_relative(); int main(int \/*argc*\/, char * \/*argv*\/[]) {"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nDeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type)\n    : m_handler(handler)\n    , m_timer(*this, \"deribit_refresh\")\n{\n    TBDEBUG(__func__ << \" : \" << endpoint);\n\n    std::string url(endpoint.GetCString());\n    auto found = url.find(\":\/\/\");\n    if (found != std::string::npos)\n    {\n        url = url.substr(found + 3);\n    }\n    m_session.host_port_path = url;\n\n    std::vector<String> slices;\n    m_session.host_port_path.Split(':', slices);\n    TBDUMP(slices);\n    switch (type)\n    {\n    case DeribitHost::NONE:\n        m_conf.header.insert({\"Host\", slices[0].GetCString()});\n        break;\n    default:\n        m_conf.header.insert({\"Host\", Resolve(type)});\n        break;\n    }\n}\n\nDeribitClient::~DeribitClient()\n{\n    TBDEBUG(__func__);\n    Disconnect();\n}\n\nvoid DeribitClient::Connect(const String & userId, const String & secret)\n{\n    TBDEBUG(__func__ << \" : userId=\" << userId << \" secret=\" << secret);\n    m_session.userId = userId;\n    m_session.secret = secret;\n\n    m_ws = std::make_unique<TbWebsocketClient>(*this, m_session.host_port_path, m_conf);\n    m_ws->Connect();\n}\n\nvoid DeribitClient::Disconnect()\n{\n    TBDEBUG(__func__);\n    if (m_ws)\n    {\n        m_session.logged_in = false;\n        m_ws->Shutdown();\n    }\n}\n\nvoid DeribitClient::SetHeartbeat(int seconds)\n{\n    TBDEBUG(__func__ << \" : \" << seconds << \"s\");\n    m_session.hb = seconds;\n    if (m_ws)\n    {\n        auto & t = NewTransaction();\n        t.method = DeribitMethod::PUBLIC_SetHeartbeat;\n        t.call = std::make_unique<deribit::public_set_heartbeat>(t.id.ToString().GetCString());\n        auto msg = dynamic_cast<deribit::public_set_heartbeat *>(t.call.get());\n        msg->SetInterval(seconds);\n        PerformTransaction(t);\n    }\n    else\n    {\n    }\n}\n\nvoid DeribitClient::HandleWebsocketConnected()\n{\n    TBDEBUG(__func__);\n    m_session.connected = true;\n    Login();\n}\n\nvoid DeribitClient::HandleWebsocketDisconnected(const String & reason)\n{\n    if (m_session.connected)\n    {\n        TBWARNING(\"Websocket disconnected: \" << reason);\n    }\n    else\n    {\n        TBDEBUG(__func__ << \" : \" << reason);\n    }\n    m_session.Reset();\n    m_handler.HandleDeribitDisconnected();\n}\n\nvoid DeribitClient::HandleError(const String & error)\n{\n    TBWARNING(error);\n    Disconnect();\n}\n\nvoid DeribitClient::HandleMessage(std::string_view message)\n{\n    TBDEBUG(__func__ << \" : \" << message);\n    deribit::JsonReply msg(message, m_availableMethods);\n\n    try\n    {\n        auto t = m_transactions.find(Identifier(msg.GetId().data()));\n        if (t == m_transactions.end())\n<fim-suffix><fim-middle>        {\n            TryRemoteCall(msg);\n            return;\n        }"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n<fim-suffix><fim-middle>    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);\n\n     if (id.second != m_tickerId)\n    {\n        TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);\n        return;\n    }\n\n    if (value.Empty() or (value == \"{}\") or value.HasError())\n    {\n        Price emptyPrice;\n        Volume emptyVolume {0};\n        iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale);\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\");\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        bbo.SetAskPrice(emptyPrice);\n        bbo.SetBidPrice(emptyPrice);\n        bbo.SetAskVolume(emptyVolume);\n        bbo.SetBidVolume(emptyVolume);\n        return;\n    }\n\n    iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk);\n    iStatus.SetVenueInstrumentMarketDataStatus(\"OK\");\n\n    deribit::ticker_update update(value);\n\n    if (update.IsOpen())\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed);\n    }\n    else\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed);\n    }\n\n    bbo.SetAskPrice(update.GetAsk());\n    bbo.SetBidPrice(update.GetBid());\n    bbo.SetAskVolume(update.GetAskVolume());\n    bbo.SetBidVolume(update.GetBidVolume());\n    auto millis = update.GetTimestamp();\n    DateTime timestamp = DateTime::Now();\n    if (millis > 0)\n    {\n        timestamp = DateTime::Create(millis \/ 1000);\n    }\n    bbo.SetExchangeModifiedDatetime(timestamp);\n    \n    stats.SetLastPrice(update.GetLastPrice());\n    stats.SetOpenInterest(update.GetOpenInterest());\n    stats.SetDailySettlementPrice(update.GetSettlementPrice());\n    stats.SetHighPrice(update.GetMaxPrice());\n    stats.SetLowPrice(update.GetMinPrice());\n}\n\nvoid DeribitModel::Reset()\n{\n    InstrumentStatus status;\n    BestPrice bbo;\n    Price emptyPrice;\n    Volume emptyVolume;\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale);\n    status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\");\n    status.SetVenueInstrumentTradingStatus(String());\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    bbo.SetAskPrice(emptyPrice);\n    bbo.SetBidPrice(emptyPrice);\n    bbo.SetAskVolume(emptyVolume);\n    bbo.SetBidVolume(emptyVolume);\n\n    m_mdItem.PartialUpdate(status);\n    m_mdItem.PartialUpdate(bbo);\n    m_mdItem.Flush();\n    SendSnapshotDoneIfNeeded();\n}\n\nvoid DeribitModel::Fail()\n{\n    InstrumentStatus status;\n    BestPrice bbo;\n<fim-suffix><fim-middle>    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n<fim-suffix><fim-middle>    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item)<fim-suffix>bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics<fim-middle>override;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n\ntemplate <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);\n}\n\ntemplate <>\nBinary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)\n<fim-suffix><fim-middle>{\n    if (val.size() <= 0)\n        return ostm;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler & handler)\n    : m_instrumentStream(*this)\n    , m_handler(handler)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Clear()\n{\n    m_tbricksInstruments.clear();\n    m_deribitInstruments.clear();\n    m_pendingCreates.clear();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n    \n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByVenueFilter(m_handler.GetVenueIdentifier()) && InstrumentStream::Filters::DeletedFilter(\/*deleted=*\/false));\n    m_instrumentStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n    \n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() \n            << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    String key = GetInstrumentKey(deribitInstrument);\n    m_deribitInstruments[key] = deribitInstrument;\n}\n\nString InstrumentManager::GetInstrumentKey(const Instrument & instrument)\n{\n    return instrument.GetShortName();\n}\n\nString InstrumentManager::GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    return deribitInstrument->instrument_name;\n}\n\nvoid InstrumentManager::Start()\n{\n    Clear();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::SyncInstruments()\n{\n    TBDEBUG(__func__ << \": Comparing \" << m_tbricksInstruments.size() \n            << \" Tbricks instruments with \" << m_deribitInstruments.size() \n            << \" Deribit instruments\");\n            \n    for (const auto & [key, deribitInst] : m_deribitInstruments)\n    {\n        auto tbricks_it = m_tbricksInstruments.find(key);\n        if (tbricks_it == m_tbricksInstruments.end())\n        {\n            if (not deribitInst->is_active)\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not active\");\n                continue;\n            }\n            if (deribitInst->instrument_type == \"linear\")\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is linear\");\n                continue;\n            }\n            if ((deribitInst->settlement_period != \"month\") and not deribitInst->settlement_period.Empty())\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not a monthly option\");\n                continue;\n            }\n            \n            CreateInstrument(deribitInst);\n        }\n        else\n        {\n            const auto & instrument = tbricks_it->second;\n            ModifyInstrument(instrument, deribitInst);\n        }\n    }\n}\n\nvoid InstrumentManager::CreateInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    TBDEBUG(__func__ << \": Creating instrument \" << deribitInstrument->instrument_name);\n\n    Instrument::Options options;\n    \n    options.SetShortName(deribitInstrument->instrument_name);\n    options.SetLongName(deribitInstrument->instrument_name);\n    \n    CFI cfi;\n    if (deribitInstrument->option_type == \"call\")\n    {\n        cfi = CFI(\"OC\", CFI::V2015);\n    }\n    else if (deribitInstrument->option_type == \"put\")\n    {\n        cfi = CFI(\"OP\", CFI::V2015);\n    }\n    options.SetCFI(cfi);\n\n    std::vector<VenueInstrumentIdentifier> viids;\n    VenueInstrumentIdentifier viid;\n    viid.SetVenueIdentifier(m_handler.GetVenueIdentifier());\n    viid.SetMIC(MIC(\"XCYS\")); \/\/ dummy MIC\n    viid.Add(\"symbol\", deribitInstrument->instrument_name);\n    viids.push_back(viid);\n    options.SetVenueInstrumentIdentifiers(viids);\n\n<fim-suffix><fim-middle>    std::vector<InstrumentGroup> instrumentGroups;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public<fim-suffix>{ public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest()<fim-middle>tbricks::IDistributionApp, public DeribitClient::IHandler"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\"\n#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include \"execution\/TbOrderManager.h\"\n#include \"execution\/TbOrderMinion.h\"\n#include \"execution\/TbChildOrder.h\"\n\n#include <AsyncTask.h>\n#include <memory>\n\nusing namespace tbricks;\n\nnamespace sp = go_flat::strategy_parameters;\n\nGoFlatPlugin::GoFlatPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_portfolio(sp::Portfolio())\n    , m_statusText(sp::PlugInStatusDescription())\n    , m_executorType(execution::OrderExecutorType::ORDER_MANAGER)\n{\n    TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered());\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    switch (m_executorType)\n    {\n        case execution::OrderExecutorType::ORDER_MANAGER:\n            m_orders = std::make_unique<execution::TbOrderManager>(*this);\n            break;\n        case execution::OrderExecutorType::CHILD_ORDER:\n            m_orders = std::make_unique<execution::TbChildOrder>(*this, *this);\n            break;\n        case execution::OrderExecutorType::ORDER_MINION:\n            m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters);\n            break;\n    }\n\n    m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier());\n}\n\nvoid GoFlatPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n\n    if (not m_positions or m_positions->GetData().empty())\n    {\n        SetTransactionFail(\"No positions\", StrategyState::PAUSED);\n        return;\n    }\n    if (m_orders)\n    {\n        if (not m_positions->GetData().empty())\n        {\n            for (const auto& [ivid, pos] : m_positions->GetData())\n            {\n                if (m_executorType == execution::OrderExecutorType::ORDER_MINION)\n<fim-suffix><fim-middle>                {\n                    execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get());\n                    minion->MonitorInstrument(ivid);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; explicit InstrumentManager(IHandler& handler); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update &<fim-suffix><fim-middle>update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler interface     void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId,"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbChildOrder : public OrderExecutor, public tbricks::StrategyStream::IHandler, public tbricks::IRequestReplyHandler { public: TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app); ~TbChildOrder(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ StrategyStream::IHandler void HandleStrategyUpdate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyUpdate & update) final; void HandleStrategyInvalidate(const tbricks::StreamIdentifier &<fim-suffix>\/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier&<fim-middle>stream, const tbricks::StrategyIdentifier & id) final;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem<fim-suffix><fim-middle>& item)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual<fim-suffix><fim-middle>void HandleImportComplete(const tbricks::String& status) = 0;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewUpdate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    auto it = update.begin();\n    while (it != update.end())\n    {\n        TBDUMP(it.GetCell().GetCalculatedProperty() << \" \" << it.GetCell().GetCellValue());\n\n        auto & calcProp = it.GetCell().GetCalculatedProperty().GetDefinition();\n        auto & cellValue = it.GetCell().GetCellValue();\n\n        if (calcProp == instrument_enricher::calculated_properties::strategy::ImportFrequency())\n        {\n            m_importFrequency = cellValue.GetDuration();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::InstrumentGroup())\n        {\n            m_instrumentGroup = cellValue.GetInstrumentGroupIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::UnderlyingInstrument())\n        {\n            m_underlyingInstrument = cellValue.GetInstrumentIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::StartTime())\n        {\n            m_startTime = cellValue.GetDateTime();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::MaturityDate())\n        {\n            m_maturityDate = cellValue.GetDateTime();\n        }\n\n        ++it;\n    }\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n<fim-suffix><fim-middle>    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason);<fim-suffix>\/\/ app parameters tbricks::StringParameter m_clientID; tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint; std::unique_ptr<DeribitClient> m_client; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::DistributedValuesRequest> m_requestMap; tbricks::SparseHash<tbricks::Identifier, tbricks::DistributedValuesRequest> m_pendingRequests; tbricks::Set<tbricks::Identifier> m_supported_values; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::VenueInstrumentIdentifier> m_viidMap;<fim-middle>std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Reset(); } else { TBDEBUG(\"Unknown stream\");<fim-suffix><fim-middle>} }"}
{"content":"<fim-prefix>#include \"ReversalManager.h\"\n#include \"tbricks_definitions.h\"\n#include <map>\n\nusing namespace tbricks;\n\nReversalManager::ReversalManager(IHandler& callback)\n: m_callback(callback)\n, m_scheduledTimer(*this)\n, m_positionRetriever(*this)\n{\n}\n\nvoid ReversalManager::Start( const PortfolioIdentifier& portfolioId,\n            const Integer& priceSource,\n            const Time& startTime)\n{\n    m_portfolioId = portfolioId;\n    m_priceSource = priceSource;\n    m_scheduledTimer.Start(startTime);\n}\n\nvoid ReversalManager::Stop()\n{\n    m_scheduledTimer.Stop();\n    m_positionRetriever.Stop();\n}\n\nvoid ReversalManager::HandleTimerEvent(Timer & timer)\n{\n    TBDEBUG(__func__);\n    m_positionRetriever.RetreivePositions(m_portfolioId);\n}\n\nvoid ReversalManager::HandleError(const tbricks::String& error)\n{\n    m_callback.HandleError(error);\n}\n\nvoid ReversalManager::HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions)\n{\n    for (const auto& [_, position] : positions)\n    {\n        Price reversalPrice;\n        const auto& ivid = position.GetInstrumentVenueIdentification();\n\n        StatisticsStream stream;\n        if (m_priceSource == position_reversals::enumerations::PositionReversalPriceSource::PositionReversalPriceSourceOpen)\n        {\n            stream.SetSubscribedFields(StatisticsStream::Fields::OpeningPrice());\n        }\n        else\n        {\n            stream.SetSubscribedFields(StatisticsStream::Fields::ClosingPrice());\n        }\n\n        stream.Open(Stream::SNAPSHOT, ivid, StatisticsStream::Options());\n        Statistics stats;\n        stream.GetSnapshot(stats);\n\n        if (m_priceSource == position_reversals::enumerations::PositionReversalPriceSource::PositionReversalPriceSourceOpen)\n        {\n            if (stats.HasOpeningPrice())\n            {\n                reversalPrice = stats.GetOpeningPrice();\n            }\n        }\n        else\n        {\n            if (stats.HasClosingPrice())\n            {\n                reversalPrice = stats.GetClosingPrice();\n            }\n        }\n\n        if (not reversalPrice.Empty())\n<fim-suffix><fim-middle>        {\n            m_positionReverser.ReversePosition(position, reversalPrice);\n        }\n        else"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000,<fim-suffix>\/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode =<fim-middle>const std::string & reason = \"\");"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const<fim-suffix>\/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void<fim-middle>tbricks::StrategyParameters & parameters); protected:"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n<fim-suffix><fim-middle>    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n<fim-suffix><fim-middle>void InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n<fim-suffix><fim-middle>template <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n<fim-suffix><fim-middle>    return {buffer.GetString()};\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n<fim-suffix><fim-middle>    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to; return std::move(sstrm).str(); } public: BadPreferencesStorageCast(const PreferencesStorageKind from, const PreferencesStorageKind to) : Exception(PreferenceKindsToString(from, to)) {} }; template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage); template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage); #define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\ { \\ if (TB_UNLIKELY(!pPreferencesStorage)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY((pPreferencesStorage->GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\ throw BadPreferencesStorageCast(pPreferencesStorage->GetKind(), kind); \\ } \\ \\ return reinterpret_cast<specifier type*>(pPreferencesStorage); \\ } #define PREFERENCES_STORAGE_REF_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type & pref_storage_cast(specifier PreferencesStorage & preferencesStorage) \\ { \\ if (TB_UNLIKELY((preferencesStorage.GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\ throw BadPreferencesStorageCast(preferencesStorage.GetKind(), kind); \\ } \\ \\ return reinterpret_cast<specifier type&>(preferencesStorage); \\ } #define PREFERENCES_STORAGE_CAST_IMPL(specifier, type, kind) \\ PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\<fim-suffix><fim-middle>PREFERENCES_STORAGE_REF_CAST_IMPL(specifier, type, kind)"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n<fim-suffix><fim-middle>    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n<fim-suffix><fim-middle>{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;"}
{"content":"<fim-prefix>#include \"ReversalManager.h\" #include \"tbricks_definitions.h\" #include <map> using namespace tbricks; ReversalManager::ReversalManager(IHandler& callback) : m_callback(callback) , m_scheduledTimer(*this) , m_positionRetriever(*this) { } void ReversalManager::Start( const PortfolioIdentifier& portfolioId, const Integer& priceSource, const Time& startTime) { m_portfolioId = portfolioId; m_priceSource = priceSource; m_scheduledTimer.Start(startTime); } void ReversalManager::Stop()<fim-suffix>m_positionRetriever.Stop(); } void ReversalManager::HandleTimerEvent(Timer & timer) { TBDEBUG(__func__); m_positionRetriever.RetreivePositions(m_portfolioId); } void ReversalManager::HandleError(const tbricks::String& error) { m_callback.HandleError(error); } void ReversalManager::HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions) { for (const auto&<fim-middle>{ m_scheduledTimer.Stop();"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected:<fim-suffix>void HandleUnsubscribe(tbricks::MarketDataItem<fim-middle>"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n<fim-suffix><fim-middle>        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n<fim-suffix><fim-middle>    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Reset(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Fail();<fim-suffix>TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void<fim-middle>} else {"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return<fim-suffix>} enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } }<fim-middle>{}; }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; explicit InstrumentManager(IHandler& handler); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler interface void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId, const tbricks::CalculatedInstrumentValues::Update & update) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final; private: void OpenInstrumentStream(); void OpenIAPStream(); void OpenCIVStream(); void EnrichInstruments(); void ModifyGroup(); void CheckResolutionStatus(); void CheckModificationStatus(); struct InstrumentDetails { tbricks::Instrument instrument; tbricks::DateTime maturityDate; tbricks::InstrumentIdentifier<fim-suffix><fim-middle>underlyingInstrument; tbricks::Price underlyingPrice;"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\"\n#include \"tbricks_definitions.h\"\n#include <cstdlib>\n\nusing namespace tbricks;\n\nExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) :\n        Pricing(request)\n{\n    srand (time(NULL)); \/\/ Initialize random seed.\n\n    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n    SnapshotDone();\n}\n\nvoid ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request)\n{\n    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n}\n\nvoid ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request)\n{\n    for (const auto & civ_it : request.GetColumns())\n    {\n        if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue())\n        {\n            Double x;\n            StrategyParameters parameters;\n            civ_it.GetColumnInfo().GetParameters(parameters);\n            parameters.GetParameter(strategy_parameters::X(), x);\n            for (const auto & ivids_it : values)\n<fim-suffix><fim-middle>            {\n                CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId());\n                Double result;\n                if( x.Empty() )"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto& msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\<fim-suffix>return v->value.GetDouble(); \\ } \\ return default; \\ } \\ EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price,<fim-middle>{ \\"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int<fim-suffix><fim-middle>size) { if (eof())"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\"\n#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include \"execution\/TbOrderManager.h\"\n#include \"execution\/TbOrderMinion.h\"\n#include \"execution\/TbChildOrder.h\"\n\n#include <AsyncTask.h>\n#include <memory>\n\nusing namespace tbricks;\n\nnamespace sp = go_flat::strategy_parameters;\n\nGoFlatPlugin::GoFlatPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_portfolio(sp::Portfolio())\n    , m_statusText(sp::PlugInStatusDescription())\n    , m_executorType(execution::OrderExecutorType::ORDER_MANAGER)\n{\n    TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered());\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    switch (m_executorType)\n    {\n        case execution::OrderExecutorType::ORDER_MANAGER:\n            m_orders = std::make_unique<execution::TbOrderManager>(*this);\n            break;\n        case execution::OrderExecutorType::CHILD_ORDER:\n            m_orders = std::make_unique<execution::TbChildOrder>(*this, *this);\n            break;\n        case execution::OrderExecutorType::ORDER_MINION:\n            m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters);\n            break;\n    }\n\n    m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier());\n}\n\nvoid GoFlatPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n\n    if (not m_positions or m_positions->GetData().empty())\n    {\n        SetTransactionFail(\"No positions\", StrategyState::PAUSED);\n        return;\n    }\n    if (m_orders)\n    {\n        if (not m_positions->GetData().empty())\n        {\n            for (const auto& [ivid, pos] : m_positions->GetData())\n            {\n                if (m_executorType == execution::OrderExecutorType::ORDER_MINION)\n                {\n                    execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get());\n                    minion->MonitorInstrument(ivid);\n                }\n                TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos);\n                if (not pos.Empty() and pos != 0.0)\n                {\n                    m_orders->CreateOrder(ivid, -pos, m_portfolio.GetPortfolioIdentifier());\n                }\n            }\n            m_positions->Stop();\n            SetState(StrategyState::RUNNING);\n            return;\n        }\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid GoFlatPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_orders)\n    {\n        m_orders->DeleteOrders();\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid GoFlatPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_DELETE);\n    if (m_orders)\n    {\n        m_orders->DeleteOrders();\n    }\n    SetState(StrategyState::DELETED);\n}\n\nvoid GoFlatPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(\"Modify request: \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n\n    if (modifier.GetParameters().HasParameter(sp::Portfolio()) and not m_portfolio.Empty())\n    {\n        m_positions = std::make_unique<PositionsData>(m_portfolio.GetPortfolioIdentifier(), m_statusText);\n    }\n}\n\nvoid GoFlatPlugin::HandleValidateRequest(ValidationContext &context)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \" : \" << context);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); } const tbricks::DateTime& GetTimerLastFired() const { return m_timerLastFired; } private: IHandler& m_handler; tbricks::Timer<fim-suffix>tbricks::DateTime m_startTime; tbricks::Duration m_frequency; tbricks::DateTime m_timerLastFired; };<fim-middle>m_startTimerEvent;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return false; } void<fim-suffix><fim-middle>DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) {<fim-suffix><fim-middle>switch(volModelType) {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final {} void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup; } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument; } const tbricks::DateTime&<fim-suffix><fim-middle>GetMaturityDate() final { return m_maturityDate; }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void<fim-suffix><fim-middle>HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <deribit\/DeribitInstrument.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0; virtual void HandleInstrumentManagerReady() = 0; virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0; virtual void HandleInstrumentError(const tbricks::String & error) = 0; }; explicit InstrumentManager(IHandler & handler); ~InstrumentManager() override; \/\/ Add instruments from Deribit void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Core functionality void Start(); void SyncInstruments(); void Clear(); bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); } protected: \/\/ Common stream callbacks void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ Instrument::Stream<fim-suffix>const tbricks::Instrument & instrument) override; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::InstrumentIdentifier & id) override;<fim-middle>callbacks void HandleInstrument(const tbricks::StreamIdentifier & stream,"}
{"content":"<fim-prefix>VOLATILITY(ccs,<fim-suffix><fim-middle>CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing)"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; namespace dv = deribit_contributor::distributed_values; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); m_supported_values.insert(dv::DeribitTicker().GetIdentifier()); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::FailWithReason(const String & reason) { SetTransactionFail(reason, StrategyState::PAUSED); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); DistributedValuesReply reply(request.GetIdentifier(), false); \/\/ Check that all objects are supported by the app InstrumentIdentifier instrumentId; for (const auto & object : request.GetObjects()) { auto & objParams = object.GetParameters(); if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency())) { \/\/<fim-suffix><fim-middle>if instrument is not defined in the request             TBDEBUG(\"Object missing required parameters:\\n\""}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } Strategy::SetState(StrategyState::RUNNING); return true; }<fim-suffix>{ TBWARNING(__func__ << \" : Instrument<fim-middle>void InstrumentEnricherPlugin::HandleInstrumentManagerFailed(const String& reason)"}
{"content":"<fim-prefix>#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include <strategy\/Logger.h>\n#include <strategy\/stream_filter\/PositionByPortfolioFilter.h>\n#include <strategy\/SparseSet.h>\n#include <sstream>\n#include <vector>\n\nusing namespace tbricks;\n\nnamespace cps = go_flat::calculated_properties::position;\n\nPositionsData::PositionsData(const PortfolioIdentifier& portfolioId, StringParameter& status)\n: m_appStatus(status)\n, m_stream(*this)\n{\n    TBDEBUG(__func__ << \" : \" << portfolioId);\n<fim-suffix><fim-middle>    CalculatedPropertiesTable::Stream::Options options;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } Strategy::SetState(StrategyState::RUNNING); return true; } void InstrumentEnricherPlugin::HandleImportComplete(const String& status) { TBDEBUG(__func__ <<<fim-suffix>m_plugInStatusDescription = status; HandlePauseRequest();<fim-middle>\" : \" << status);"}
{"content":"<fim-prefix>#include \"ReversalManager.h\" #include \"tbricks_definitions.h\" #include <map> using namespace tbricks; ReversalManager::ReversalManager(IHandler& callback) : m_callback(callback) , m_scheduledTimer(*this)<fim-suffix>{ } void ReversalManager::Start( const<fim-middle>, m_positionRetriever(*this)"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include<fim-suffix><fim-middle>\"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\""}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return<fim-suffix><fim-middle>new type; switch(volatilityModelType) {"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way ==<fim-suffix><fim-middle>std::ios_base::cur && (m_index + offset) < m_data.GetSize())"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\" class PositionsData; namespace execution { class OrderExecutor; } namespace misc { class AsyncProcessor; } class GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler { public: GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ Strategy methods void HandleDeleteRequest() override; void HandleRunRequest() override; void HandlePauseRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier &modifier)<fim-suffix><fim-middle>override; void HandleValidateRequest(tbricks::ValidationContext &context) override;"}
{"content":"<fim-prefix>#include \"TbChildOrder.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbChildOrder::TbChildOrder(IExecutionHandler& handler, Strategy& app)\n: OrderExecutor(handler)\n, m_app(app)\n, m_stream(*this)\n{\n    StrategyStream::Options opts;\n    opts.SetFilter(StrategyByParentFilter(app.GetIdentifier()));\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, opts, StrategyStream::ToStrategyEngine);\n    TBDEBUG(__func__ << \" opened stream with options: \" << opts);\n}\n\nTbChildOrder::~TbChildOrder()\n{\n    m_stream.Close();\n    DeleteOrders();\n}\n\nvoid TbChildOrder::DeleteOrders()\n{\n    TBDEBUG(__func__);\n    for (const auto& [ivid,childId] : m_childMap)\n    {\n        if (m_childData[childId].GetState().IsDeleted())\n        {\n            continue;\n        }\n        Strategy::SendDeleteRequest(childId);\n        TBDUMP(\"Sent deletion for \" << childId << \" [\" << ivid << \"]\");\n    }\n}\n\nvoid TbChildOrder::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume,\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n\n    StrategyOptions opts{plug_ins::Order()}; \/\/ very few app definitions in this namespace\n\n    StrategyAttributes attrs;\n    attrs.SetExtraData(m_app.GetExtraData());\n    opts.SetAttributes(attrs);\n\n    StrategyParameters params;\n    params.SetParameter(strategy_parameters::Portfolio(), portfolio);\n    params.SetParameter(strategy_parameters::ActiveVolume(), volume.Abs());\n    params.SetParameter(strategy_parameters::Instrument(), ivid.GetInstrumentIdentifier());\n    params.SetParameter(strategy_parameters::Venue(), ivid.GetVenue());\n    params.SetParameter(strategy_parameters::MIC(), ivid.GetMIC());\n    if (volume < 0.0)\n    {\n        params.SetParameter(strategy_parameters::Side(), Side{Side::SELL});\n    }\n    else\n    {\n        params.SetParameter(strategy_parameters::Side(), Side{Side::BUY});\n    }\n\n    auto res = Strategy::SendCreateRequest(opts, params, *this);\n    TBDEBUG(\"Sent creation request for child \" << res.GetStrategyIdentifier());\n    TBDUMP(opts);\n    TBDUMP(params);\n    m_childMap[ivid] = res.GetStrategyIdentifier();\n    m_requests[res.GetRequestIdentifier()] = res.GetStrategyIdentifier();\n}\n\nvoid TbChildOrder::HandleStreamOpen(const StreamIdentifier& stream)\n{\n    TBDEBUG(__func__ << \" : \" << stream);\n}\n\nvoid TbChildOrder::HandleStreamStale(const StreamIdentifier& stream)\n{\n    TBWARNING(__func__ << \" : \" << stream);\n}\n\nvoid TbChildOrder::HandleStreamFailed(const StreamIdentifier& stream)\n<fim-suffix><fim-middle>{\n    TBERROR(__func__ << \" : \" << stream);\n    m_handler.PanicStop(\"Strategy stream failed\");\n}"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) {<fim-suffix>return false; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for<fim-middle>TBDEBUG(__func__ << \", ivid = \" << ivid);"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(\"HandleRunRequest\"); SetState(StrategyState::RUNNING); } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(\"HandlePauseRequest\");<fim-suffix><fim-middle>SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest()"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const<fim-suffix><fim-middle>tbricks::StreamIdentifier & stream);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const<fim-suffix>}; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public: subscriptions(const std::string_view id, DeribitMethod method); void AddChannel(const std::string & channel); }; class subscriptions_reply : public JsonReply { public: subscriptions_reply(JsonReply && base); std::vector<std::string_view> GetChannels() const; };<fim-middle>std::string_view val); void SetRefreshToken(const std::string_view val);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default;<fim-suffix>virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class<fim-middle>virtual void HandleWebsocketConnected() = 0;"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n<fim-suffix><fim-middle>{\n    if (!m_parameters_provider) return true;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"..\/VolatilityManagerSettings.h\"\n#include \"..\/ImpliedVolatilitySourcesManagerCore.h\"\n#include \"..\/..\/preferences_editor\/tbricks_definitions.h\" \/\/ FIXME: Remove when cp definitions are generated for shared\/system meta (TB-103467)\n#include <shared\/Macros.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/String.h>\n#include <strategy\/Instrument.h>\n#include <strategy\/Definitions.h>\n#include <strategy\/Logger.h>\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n#include <iostream>\n#include <cmath>\n\nconst CalculatedPropertyFilter PreferencesStorage::dummyFilter = CalculatedPropertyFilter::Condition(\n    vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::NE, Integer());\n\nPreferencesStorage::PreferencesStorage() :\n    autoFit(false),\n    autoApplyAutoFit(false),\n    globalAvoidExtraFits(true),\n    globalUnderlyingTradingStatusTracking(true),\n    optionTradingStatusTracking(volatility_manager_settings::DEFAULT_AUTO_FIT_OPTION_TRADING_STATUS_TRACKING),\n    loggingMode(enumerations::VolatilityManagerLoggingModeVerbose),\n    maxAllowedFitRejects(),\n    maturityExcludedFromGlobalActions(false),\n    sendQuotingRecommendations(false),\n    quotingRecommendations(),\n    parallelShift(true),\n    curveShiftUnits(enumerations::VolatilityManagerCurveShiftUnitsVolatility),\n    ATMVolatilityShiftMode(ATM_VolatilityShiftModeShiftSingleATM_Point),\n    includeExoticOptions(volatility_manager_settings::DEFAULT_USE_EXOTIC_OPTIONS_OPTION),\n    autoFetchATMVolatilityPath(false),\n    globalAutoFetchATMVolatilityPath(volatility_manager_settings::DEFAULT_ATM_VOL_PATH_AUTO_FETCH_OPTION),\n    instrumentGroupType(VolatilityManagerInstrumentGroupTypeDerivative),\n    suggestContext(parameter_contexts::VM_Suggest()),\n    trackingAreaType(enumerations::VolatilityManagerTrackingAreaTypeBasedOnAllStrikes),\n    volatilityCurveSafetyCheckEnabled(false),\n    safetyParameterChange(volatility_manager_settings::DEFAULT_SAFETY_PARAMETERS_CHANGES),\n    safetyModelChange(volatility_manager_settings::DEFAULT_SAFETY_MODEL_CHANGES),\n    checkForStaticArbitrage(false),\n    calendarSpreadArbitrageTolerance(volatility_manager_settings::DEFAULT_CALENDAR_SPREAD_ARBITRAGE_TOLERANCE),\n    butterflyArbitrageTolerance(volatility_manager_settings::DEFAULT_BUTTERFLY_ARBITRAGE_TOLERANCE),\n    enableCurveQualityMetrics(false),\n    fitWeighting(FitWeightingInvertedSpread),\n    autocorrectFitWeights(true),\n    fitOnlyATMVol(false),\n    addVirtualBids(volatility_manager_settings::DEFAULT_ADD_VIRTUAL_BIDS),\n    virtualBidRatio(volatility_manager_settings::DEFAULT_VIRTUAL_BID_MULTIPLIER),\n    robustFittingOnWings(false),\n    robustFittingOnWingsStrength(volatility_manager_settings::DEFAULT_ROBUST_FITTING_ON_WINGS_STRENGTH),\n    autoResetSwimRefPriceToATM(false),\n    crossingProcessing(tbricks::enumerations::VolatilityManagerCrossingProcessingSkip),\n    anomalyDetection(false),\n    anomalyDetectionSensitivity(volatility_manager_settings::DEFAULT_ANOMALY_DETECTION_SENSITIVITY),\n    enableAmerican(true),\n    enableATM(true),\n    enableDeepITM(true),\n    enableDeepOTM(true),\n    enableEuropean(true),\n    enableITM(true),\n    enableCashDelivery(true),\n    enableCrossings(true),\n    enableLowBids(true),\n    enablePhysicalDelivery(true),\n    enableSmallDelta(true),\n    enableWideSpreads(true),\n    enableNoSpreads(true),\n    enableOTM(true),\n    enableLowVolumes(true),\n    minimumBidPrice(),\n    minimumVolume(),\n    manuallyToggledPoints(),\n    impliedVolatilitySources(),\n    tradingPhaseProcessing(enumerations::VolatilityManagerTradingPhaseProcessingAllTradingPhases),\n    showExcludedPoints(volatility_manager_settings::DEFAULT_SHOW_EXCLUDED_VOL_POINTS),\n    autocorrectVolatilityChartZooming(true),\n    deltaValueForVerticalLines(volatility_manager_settings::DEFAULT_DELTA_VALUE_FOR_VERTICAL_LINES),\n    showVerticalLinesAtGivenDelta(volatility_manager_settings::DEFAULT_SHOW_VERTICAL_LINES_AT_DELTA),\n    volatilityCurveChartAutoRangePadding(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_PADDING),\n    portfolio(),\n    preserveZooming(volatility_manager_settings::DEFAULT_PRESERVE_ZOOMING_OPTION),\n    distanceBetweenCurvePoints(volatility_manager_settings::CHART_DEFAULT_CURVE_DISTANCE_BETWEEN_DRAWN_POINTS),\n    autoRangeMode(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_MODE),\n    showReferenceVols(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_VOLS),\n    showReferenceCurve(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_CURVE),\n    showBidAskRange(volatility_manager_settings::DEFAULT_SHOW_BID_ASK_RANGE),\n    putCallColors(enumerations::VolatilityManagerPut_DIV_CallColorsDefault),\n    colorScheme(enumerations::VolatilityManagerChartColorSchemePale)\n{\n    Table impliedVolSources;\n    ImpliedVolatilitySourcesManagerCore::SetupTable(impliedVolSources, \/* useTreeNodes = *\/ true);\n    impliedVolatilitySources.SetDefault(impliedVolSources);\n\n    m_scopeLevelAnchoredPreferences = {\n        tree_node_parameters::VolatilityManagerAutomaticFit(),\n        tree_node_parameters::VolatilityManagerAutoApplyAutoFit(),\n        tree_node_parameters::VolatilityManagerAutoResetSwimReferencePrice(),\n        tree_node_parameters::VolatilityManagerMaturityExcluded(),\n        tree_node_parameters::VolatilityManagerManuallyToggledVolatilityPoints()\n    };\n\n    CalculatedPropertyFilter defaultInstrumentFilter = CalculatedPropertyFilter::Condition(\n        vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::EQ, Enumeration(Instrument::CFI_Variant::Undefined));\n\n    instrumentFilter.SetDefault(defaultInstrumentFilter);\n}\n\nPreferencesStorage::~PreferencesStorage()\n{}\n\nvoid PreferencesStorage::Clear()\n{\n    autoFit.ClearValue();\n    autoApplyAutoFit.ClearValue();\n    globalAvoidExtraFits.ClearValue();\n    globalUnderlyingTradingStatusTracking.ClearValue();\n    optionTradingStatusTracking.ClearValue();\n    loggingMode.ClearValue();\n    maxAllowedFitRejects.ClearValue();\n    maturityExcludedFromGlobalActions.ClearValue();\n    sendQuotingRecommendations.ClearValue();\n    quotingRecommendations.ClearValue();\n\n    parallelShift.ClearValue();\n    curveShiftUnits.ClearValue();\n    ATMVolatilityShiftMode.ClearValue();\n    includeExoticOptions.ClearValue();\n    autoFetchATMVolatilityPath.ClearValue();\n    globalAutoFetchATMVolatilityPath.ClearValue();\n    instrumentGroupType.ClearValue();\n    suggestContext.ClearValue();\n    trackingAreaType.ClearValue();\n    volatilityCurveSafetyCheckEnabled.ClearValue();\n    safetyParameterChange.ClearValue();\n    safetyModelChange.ClearValue();\n    checkForStaticArbitrage.ClearValue();\n    calendarSpreadArbitrageTolerance.ClearValue();\n    butterflyArbitrageTolerance.ClearValue();\n    enableCurveQualityMetrics.ClearValue();\n\n    fitWeighting.ClearValue();\n    autocorrectFitWeights.ClearValue();\n    fitOnlyATMVol.ClearValue();\n    addVirtualBids.ClearValue();\n    virtualBidRatio.ClearValue();\n    robustFittingOnWings.ClearValue();\n    robustFittingOnWingsStrength.ClearValue();\n    autoResetSwimRefPriceToATM.ClearValue();\n    crossingProcessing.ClearValue();\n    anomalyDetection.ClearValue();\n    anomalyDetectionSensitivity.ClearValue();\n\n    enableAmerican.ClearValue();\n    enableATM.ClearValue();\n    enableDeepITM.ClearValue();\n    enableDeepOTM.ClearValue();\n    enableEuropean.ClearValue();\n    enableITM.ClearValue();\n    enableCashDelivery.ClearValue();\n    enableCrossings.ClearValue();\n    enableLowBids.ClearValue();\n    enablePhysicalDelivery.ClearValue();\n    enableSmallDelta.ClearValue();\n    enableWideSpreads.ClearValue();\n    enableNoSpreads.ClearValue();\n    enableOTM.ClearValue();\n    enableLowVolumes.ClearValue();\n    minimumBidPrice.ClearValue();\n    minimumVolume.ClearValue();\n    manuallyToggledPoints.ClearValue();\n    impliedVolatilitySources.ClearValue();\n    instrumentFilter.ClearValue();\n    tradingPhaseProcessing.ClearValue();\n\n    showExcludedPoints.ClearValue();\n    autocorrectVolatilityChartZooming.ClearValue();\n    deltaValueForVerticalLines.ClearValue();\n    showVerticalLinesAtGivenDelta.ClearValue();\n    volatilityCurveChartAutoRangePadding.ClearValue();\n    autoRangeMode.ClearValue();\n    portfolio.ClearValue();\n    preserveZooming.ClearValue();\n    distanceBetweenCurvePoints.ClearValue();\n    showReferenceCurve.ClearValue();\n    showReferenceVols.ClearValue();\n    showBidAskRange.ClearValue();\n    putCallColors.ClearValue();\n    colorScheme.ClearValue();\n}\n\nvoid PreferencesStorage::Copy(const PreferencesStorage & preferencesStorage)\n{\n    autoFit = preferencesStorage.autoFit;\n    autoApplyAutoFit = preferencesStorage.autoApplyAutoFit;\n    globalAvoidExtraFits = preferencesStorage.globalAvoidExtraFits;\n    globalUnderlyingTradingStatusTracking = preferencesStorage.globalUnderlyingTradingStatusTracking;\n    optionTradingStatusTracking = preferencesStorage.optionTradingStatusTracking;\n    loggingMode = preferencesStorage.loggingMode;\n    maxAllowedFitRejects = preferencesStorage.maxAllowedFitRejects;\n    maturityExcludedFromGlobalActions = preferencesStorage.maturityExcludedFromGlobalActions;\n    sendQuotingRecommendations = preferencesStorage.sendQuotingRecommendations;\n    quotingRecommendations = preferencesStorage.quotingRecommendations;\n\n    parallelShift = preferencesStorage.parallelShift;\n    curveShiftUnits = preferencesStorage.curveShiftUnits;\n    ATMVolatilityShiftMode = preferencesStorage.ATMVolatilityShiftMode;\n    includeExoticOptions = preferencesStorage.includeExoticOptions;\n    autoFetchATMVolatilityPath = preferencesStorage.autoFetchATMVolatilityPath;\n    globalAutoFetchATMVolatilityPath = preferencesStorage.globalAutoFetchATMVolatilityPath;\n    instrumentGroupType = preferencesStorage.instrumentGroupType;\n    suggestContext = preferencesStorage.suggestContext;\n    trackingAreaType = preferencesStorage.trackingAreaType;\n    volatilityCurveSafetyCheckEnabled = preferencesStorage.volatilityCurveSafetyCheckEnabled;\n    safetyParameterChange = preferencesStorage.safetyParameterChange;\n    safetyModelChange = preferencesStorage.safetyModelChange;\n    checkForStaticArbitrage = preferencesStorage.checkForStaticArbitrage;\n    calendarSpreadArbitrageTolerance = preferencesStorage.calendarSpreadArbitrageTolerance;\n    butterflyArbitrageTolerance = preferencesStorage.butterflyArbitrageTolerance;\n    enableCurveQualityMetrics = preferencesStorage.enableCurveQualityMetrics;\n\n    fitWeighting = preferencesStorage.fitWeighting;\n    autocorrectFitWeights = preferencesStorage.autocorrectFitWeights;\n    fitOnlyATMVol = preferencesStorage.fitOnlyATMVol;\n    addVirtualBids = preferencesStorage.addVirtualBids;\n    virtualBidRatio = preferencesStorage.virtualBidRatio;\n    robustFittingOnWings = preferencesStorage.robustFittingOnWings;\n    robustFittingOnWingsStrength = preferencesStorage.robustFittingOnWingsStrength;\n    autoResetSwimRefPriceToATM = preferencesStorage.autoResetSwimRefPriceToATM;\n    crossingProcessing = preferencesStorage.crossingProcessing;\n    anomalyDetection = preferencesStorage.anomalyDetection;\n    anomalyDetectionSensitivity = preferencesStorage.anomalyDetectionSensitivity;\n\n    enableAmerican = preferencesStorage.enableAmerican;\n    enableATM = preferencesStorage.enableATM;\n    enableDeepITM = preferencesStorage.enableDeepITM;\n    enableDeepOTM = preferencesStorage.enableDeepOTM;\n    enableEuropean = preferencesStorage.enableEuropean;\n    enableITM = preferencesStorage.enableITM;\n    enableCashDelivery = preferencesStorage.enableCashDelivery;\n    enableCrossings = preferencesStorage.enableCrossings;\n    enableLowBids = preferencesStorage.enableLowBids;\n    enablePhysicalDelivery = preferencesStorage.enablePhysicalDelivery;\n    enableSmallDelta = preferencesStorage.enableSmallDelta;\n    enableWideSpreads = preferencesStorage.enableWideSpreads;\n    enableNoSpreads = preferencesStorage.enableNoSpreads;\n    enableOTM = preferencesStorage.enableOTM;\n    enableLowVolumes = preferencesStorage.enableLowVolumes;\n    minimumBidPrice = preferencesStorage.minimumBidPrice;\n    minimumVolume = preferencesStorage.minimumVolume;\n    manuallyToggledPoints = preferencesStorage.manuallyToggledPoints;\n    impliedVolatilitySources = preferencesStorage.impliedVolatilitySources;\n    instrumentFilter = preferencesStorage.instrumentFilter;\n    tradingPhaseProcessing = preferencesStorage.tradingPhaseProcessing;\n<fim-suffix><fim-middle>    showExcludedPoints = preferencesStorage.showExcludedPoints;\n    autocorrectVolatilityChartZooming = preferencesStorage.autocorrectVolatilityChartZooming;\n    deltaValueForVerticalLines = preferencesStorage.deltaValueForVerticalLines;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler & handler)\n    : m_instrumentStream(*this)\n    , m_handler(handler)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Clear()\n{\n    m_tbricksInstruments.clear();\n    m_deribitInstruments.clear();\n    m_pendingCreates.clear();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n    \n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByVenueFilter(m_handler.GetVenueIdentifier()) && InstrumentStream::Filters::DeletedFilter(\/*deleted=*\/false));\n    m_instrumentStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n    \n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() \n            << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    String key = GetInstrumentKey(deribitInstrument);\n    m_deribitInstruments[key] = deribitInstrument;\n}\n\nString InstrumentManager::GetInstrumentKey(const Instrument & instrument)\n{\n    return instrument.GetShortName();\n}\n\nString InstrumentManager::GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    return deribitInstrument->instrument_name;\n}\n\nvoid InstrumentManager::Start()\n{\n    Clear();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::SyncInstruments()\n{\n    TBDEBUG(__func__ << \": Comparing \" << m_tbricksInstruments.size() \n            << \" Tbricks instruments with \" << m_deribitInstruments.size() \n            << \" Deribit instruments\");\n            \n    for (const auto & [key, deribitInst] : m_deribitInstruments)\n    {\n        auto tbricks_it = m_tbricksInstruments.find(key);\n        if (tbricks_it == m_tbricksInstruments.end())\n        {\n            if (not deribitInst->is_active)\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not active\");\n                continue;\n            }\n            if (deribitInst->instrument_type == \"linear\")\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is linear\");\n                continue;\n            }\n            if ((deribitInst->settlement_period != \"month\") and not deribitInst->settlement_period.Empty())\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not a monthly option\");\n                continue;\n            }\n            \n            CreateInstrument(deribitInst);\n        }\n        else\n        {\n            const auto & instrument = tbricks_it->second;\n            ModifyInstrument(instrument, deribitInst);\n        }\n    }\n}\n\nvoid InstrumentManager::CreateInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    TBDEBUG(__func__ << \": Creating instrument \" << deribitInstrument->instrument_name);\n\n    Instrument::Options options;\n    \n    options.SetShortName(deribitInstrument->instrument_name);\n    options.SetLongName(deribitInstrument->instrument_name);\n    \n    CFI cfi;\n    if (deribitInstrument->option_type == \"call\")\n    {\n        cfi = CFI(\"OC\", CFI::V2015);\n    }\n    else if (deribitInstrument->option_type == \"put\")\n    {\n        cfi = CFI(\"OP\", CFI::V2015);\n    }\n    options.SetCFI(cfi);\n\n    std::vector<VenueInstrumentIdentifier> viids;\n    VenueInstrumentIdentifier viid;\n    viid.SetVenueIdentifier(m_handler.GetVenueIdentifier());\n    viid.SetMIC(MIC(\"XCYS\")); \/\/ dummy MIC\n    viid.Add(\"symbol\", deribitInstrument->instrument_name);\n    viids.push_back(viid);\n    options.SetVenueInstrumentIdentifiers(viids);\n\n    std::vector<InstrumentGroup> instrumentGroups;\n    \n    InstrumentAttributes attributes;\n    \n    if (not deribitInstrument->expiration_timestamp.Empty())\n    {\n        attributes.SetMaturityDate(deribitInstrument->expiration_timestamp.GetCalendarDate());\n    }\n    \n    if (deribitInstrument->strike)\n    {\n        attributes.SetAttribute(instrument_attributes::StrikePrice(), Price(*deribitInstrument->strike));\n    }\n    \n    if (deribitInstrument->contract_size != 0.0)\n    {\n        attributes.SetAttribute(instrument_attributes::InstrumentMultiplier(), deribitInstrument->contract_size);\n    }\n\n    if (!deribitInstrument->counter_currency.Empty())\n    {\n        auto base_ccy = Currency(deribitInstrument->counter_currency);\n        attributes.SetAttribute(instrument_attributes::BaseCurrency(), base_ccy);\n        instrumentGroups.emplace_back(base_ccy.GetInstrumentGroupIdentifier());\n    }\n    \n    options.SetInstrumentGroups(instrumentGroups);\n\n    options.SetAttributes(attributes);\n\n    auto result = Instrument::SendCreateRequest(options, *this);\n    m_pendingCreates[result.GetRequestIdentifier()] = deribitInstrument->instrument_name;\n    TBDEBUG(__func__ << \": \" << options);\n}\n\nvoid InstrumentManager::ModifyInstrument(const Instrument & instrument, const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    TBFULLDUMP(__func__ << \": Potentially modifying instrument \" << deribitInstrument->instrument_name);\n\n    InstrumentModifier mod(instrument.GetIdentifier());\n    \n    CFI cfi;\n    if (deribitInstrument->option_type == \"call\")\n    {\n        cfi = CFI(\"OC\", CFI::V2015);\n    }\n    else if (deribitInstrument->option_type == \"put\")\n    {\n        cfi = CFI(\"OP\", CFI::V2015);\n    }\n    if (cfi != instrument.GetCFI())\n    {\n        mod.SetCFI(cfi);\n    }\n\n    VenueInstrumentIdentifier viid;\n    viid.SetVenueIdentifier(m_handler.GetVenueIdentifier());\n<fim-suffix><fim-middle>    viid.SetMIC(MIC(\"XCYS\")); \/\/ dummy MIC\n    viid.Add(\"symbol\", deribitInstrument->instrument_name);"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\"<fim-suffix>#include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"MyCustomVolatilityModel.h\" #endif<fim-middle>#include \"ConstantVolatility.h\""}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>TbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n<fim-suffix><fim-middle>    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel) VOLATILITY_MODEL_WRAP(None,ConstantVolatility) VOLATILITY_MODEL_WRAP(MyCustom,MyCustomVolatilityModel)"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\ntypedef std::pair<DeribitMethod, std::string> Method;\n\nstatic std::vector<Method> GetAvailableMethods()\n{\n    return {\n<fim-suffix><fim-middle>            {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)},\n            {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)},\n            {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)},\n            {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)},"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\"\n#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include \"execution\/TbOrderManager.h\"\n#include \"execution\/TbOrderMinion.h\"\n#include \"execution\/TbChildOrder.h\"\n\n#include <AsyncTask.h>\n#include <memory>\n\nusing namespace tbricks;\n\nnamespace sp = go_flat::strategy_parameters;\n\nGoFlatPlugin::GoFlatPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_portfolio(sp::Portfolio())\n    , m_statusText(sp::PlugInStatusDescription())\n    , m_executorType(execution::OrderExecutorType::ORDER_MANAGER)\n{\n    TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered());\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    switch (m_executorType)\n    {\n        case execution::OrderExecutorType::ORDER_MANAGER:\n            m_orders = std::make_unique<execution::TbOrderManager>(*this);\n            break;\n        case execution::OrderExecutorType::CHILD_ORDER:\n            m_orders = std::make_unique<execution::TbChildOrder>(*this, *this);\n            break;\n        case execution::OrderExecutorType::ORDER_MINION:\n            m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters);\n            break;\n    }\n\n    m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier());\n}\n<fim-suffix><fim-middle>void GoFlatPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include \"shared\/app\/app.h\"\nCLANG_RESTORE_WARNINGS\n<fim-suffix><fim-middle>#include <limits>"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n<fim-suffix><fim-middle>    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/EventProcessor.h> #include <future> namespace misc { class AsyncProcessor { private: const tbricks::EventProcessor& m_proc; tbricks::StrategyIdentifier m_id; std::string m_result; public: AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc), m_id(appId) {}; void DoAsync() { std::thread([this]{ std::this_thread::sleep_for(std::chrono::seconds(3)); m_result = \"ASYNC SUCCESS\"; tbricks::UserData payload;<fim-suffix>}).detach(); } bool<fim-middle>payload.Set(&m_result, 0); \/\/ we can do shallow copy because the string is a member variable             m_proc.ScheduleStrategyEvent(m_id, payload);"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\" using namespace tbricks; InstrumentManager::InstrumentManager(IHandler& handler) : m_handler(handler) , m_instrumentStream(*this) , m_iapStream(*this) { TBDEBUG(__func__ << \" ctor\"); } InstrumentManager::~InstrumentManager() { TBDEBUG(__func__ << \" dtor\"); Stop(); } void InstrumentManager::Stop() { TBDEBUG(__func__); m_instrumentCache.clear(); m_underlyingCache.clear(); m_instrumentStream.Close(); } void InstrumentManager::Start() { TBDEBUG(__func__); Stop(); OpenInstrumentStream(); } void InstrumentManager::OpenInstrumentStream() { TBDEBUG(__func__); InstrumentStream::Options options; options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup())); m_instrumentStream.Open(Stream::SNAPSHOT, options); TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter()); } void InstrumentManager::OpenIAPStream() { TBDEBUG(__func__); tbricks::InstrumentAggregateParameters::Stream::Options options; for (const auto& [instId, _] : m_instrumentCache) { options.AddInstrument(instId); } options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()}); m_iapStream.Close(); m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options); TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options); } void InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); } void InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID) { TBWARNING(\"Instrument cache stream staled = \" << streamID); } void InstrumentManager::HandleStreamFailed(const StreamIdentifier& streamID) { m_handler.HandleInstrumentManagerFailed(\"Instrument stream failed\"); } void InstrumentManager::HandleSnapshotEnd(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); if (streamID == m_instrumentStream.GetIdentifier()) { TBDEBUG(\"Instruments snapshot done, enriching...\"); OpenIAPStream(); } else if (streamID == m_iapStream.GetIdentifier()) { \/\/ All data is collected, now perform the next steps EnrichInstruments(); } } void InstrumentManager::HandleInstrument(const StreamIdentifier& streamID, const Instrument& instrument) { TBDEBUG(__func__ << \" : stream = \" << streamID << \", instrument ID = \" << instrument.GetIdentifier()); TBDUMP(instrument); if (streamID == m_instrumentStream.GetIdentifier()) { m_instrumentCache[instrument.GetIdentifier()] = instrument; } else { TBWARNING(\"Instrument update received<fim-suffix>} } void InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID, const InstrumentIdentifier& instrumentID, const<fim-middle>from unknown stream = \" << streamID);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);\n\n     if (id.second != m_tickerId)\n    {\n        TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);\n        return;\n    }\n\n    if (value.Empty() or (value == \"{}\") or value.HasError())\n    {\n        Price emptyPrice;\n        Volume emptyVolume {0};\n        iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale);\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\");\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        bbo.SetAskPrice(emptyPrice);\n        bbo.SetBidPrice(emptyPrice);\n        bbo.SetAskVolume(emptyVolume);\n        bbo.SetBidVolume(emptyVolume);\n        return;\n    }\n\n    iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk);\n    iStatus.SetVenueInstrumentMarketDataStatus(\"OK\");\n\n    deribit::ticker_update update(value);\n\n    if (update.IsOpen())\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed);\n    }\n    else\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed);\n    }\n\n    bbo.SetAskPrice(update.GetAsk());\n    bbo.SetBidPrice(update.GetBid());\n    bbo.SetAskVolume(update.GetAskVolume());\n    bbo.SetBidVolume(update.GetBidVolume());\n    auto millis = update.GetTimestamp();\n    DateTime timestamp = DateTime::Now();\n    if (millis > 0)\n    {\n        timestamp = DateTime::Create(millis \/ 1000);\n    }\n    bbo.SetExchangeModifiedDatetime(timestamp);\n<fim-suffix><fim-middle>    stats.SetLastPrice(update.GetLastPrice());\n    stats.SetOpenInterest(update.GetOpenInterest());\n    stats.SetDailySettlementPrice(update.GetSettlementPrice());"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT, PUBLIC_GetInstruments, }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; case DeribitMethod::PUBLIC_GetInstruments: return \"public\/get_instruments\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) {<fim-suffix>{ case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {};<fim-middle>switch (e)"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear(); m_wasStreamStale = false; TBDEBUG(__func__); if (m_positionStream.IsOpen()) { m_positionStream.Close(); } m_positionStream.Open( Stream::SNAPSHOT, portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, AnyPositionFilter()); } void PositionRetriever::Stop() { m_positionStream.Close(); m_positions.clear(); } void PositionRetriever::HandleStreamOpen(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { if (not m_wasStreamStale) { TBDEBUG(__func__ << \" Stream opened: \" << stream_id); } else { TBNOTICE(\"Stream reconnected\"); m_wasStreamStale = false; } } else { TBDEBUG(__func__ << \" Unknown opened stream: \" << stream_id); } } void PositionRetriever::HandleStreamStale(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBWARNING(__func__ << \" Stream became stale: \" << stream_id); m_wasStreamStale = true; } else { TBWARNING(__func__ << \" Unknown stale stream: \" << stream_id); } } void PositionRetriever::HandleStreamFailed(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { std::stringstream error; error << \"Stream failed: \" << stream_id; m_callback.HandleError(error.str()); } else { TBWARNING(__func__ << \" Unknown failed stream: \" << stream_id); } } void PositionRetriever::HandleSnapshotEnd(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBDEBUG(__func__ << \" Snapshot end received on stream: \" << stream_id); m_callback.HandlePositions(m_positions); } else { TBDEBUG(__func__ << \" Received snapshot end on unknown stream: \" << stream_id); } } void PositionRetriever::HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) { TBDEBUG(__func__ << \" \" << stream_id); TBDUMP(position); if (m_positionStream.GetIdentifier() == stream_id) { m_positions.emplace(position.GetIdentifier(), position); } else { TBDEBUG(__func__ << \" Received position on unknown stream: \" << stream_id); } } void PositionRetriever::HandlePositionInvalidate( const tbricks::StreamIdentifier & stream_id, const tbricks::Identifier & id) { if (m_positionStream.GetIdentifier() == stream_id) { TBDEBUG(__func__ << \" Received invalidated position on stream: \" << stream_id); m_positions.erase(id); } else { TBDEBUG(__func__ << \" Received invalidated position on unknown stream: \" <<<fim-suffix><fim-middle>stream_id); }"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume {0}; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail() { InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to<fim-suffix>m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::SendSnapshotDoneIfNeeded() { TBDEBUG(__func__); if (TB_UNLIKELY(!m_snapshotDone)) { m_mdItem.SendSnapshotDone();<fim-middle>DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\" #include \"tbricks_definitions.h\" #include <cstdlib> #include <set> using namespace tbricks; ExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void<fim-suffix>RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin2::Calculate(const RequestAndIVIDs & values, const CalculatedValuesRequestFull & request) { m_rows = values; for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, civ_it.GetColumnId(), x); } } else { TBERROR(\"System asked for calculation which the plugin does not support!\"); } } Send(); } void ExampleCalcAppPlugin2::Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x) { CalculatedValueIdentifier calc_id(rowId, columnId); Double result; if( x.Empty()<fim-middle>ExampleCalcAppPlugin2::HandlePricingModifyRequest(const PricingModifyRequest& request) {"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing,<fim-suffix>VOLATILITY(custom, Custom)<fim-middle>Wing)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void<fim-suffix><fim-middle>HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n<fim-suffix><fim-middle>    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n    ~DeribitContributor() noexcept override = default;\n\nprotected:\n    void HandleRunRequest() override;\n    void HandlePauseRequest() override;\n    void HandleDeleteRequest() override;\n    void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override;\n    void HandleValidateRequest(tbricks::ValidationContext & context) override;\n    void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override;\n    void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override;\n\n    void HandleDeribitConnected() override;\n    void HandleDeribitDisconnected() override;\n    void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override;\n\nprivate:\n    void FailWithReason(const tbricks::String & reason);\n    std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument);\n\n    tbricks::StringParameter m_clientID;\n    tbricks::StringParameter m_clientSecret;\n    tbricks::StringParameter m_endpoint;\n<fim-suffix><fim-middle>    std::unique_ptr<DeribitClient> m_client;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters<fim-suffix><fim-middle>objectParams; InstrumentStatus status;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler<fim-suffix><fim-middle>{ public: DeribitMdp(); ~DeribitMdp() noexcept override = default;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VizualizationApp methods void HandleStrategyViewCreate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleStrategyViewUpdate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleStrategyViewDelete( tbricks::visualization::models::AppViewModel& viewModel) final; void HandleGridViewCreate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleGridViewUpdate( tbricks::visualization::models::GridViewModel&<fim-suffix>void HandleGridViewDelete(tbricks::visualization::models::GridViewModel& viewModel) final; \/\/<fim-middle>viewModel, const tbricks::visualization::ViewModelUpdate& update) final;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n    TBDUMP(update);\n}\n\nstd::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream)\n{\n    auto it_streams = m_streams.find(stream);\n    if (it_streams == m_streams.end())\n    {\n        return std::nullopt;\n    }\n\n    return GetModel(it_streams->second);\n}\n\nstd::optional<DeribitModel *> DeribitMdp::GetModel(const InstrumentIdentifier & instrument)\n{\n    auto it_models = m_models.find(instrument);\n    if (it_models == m_models.end())\n    {\n        return std::nullopt;\n    }\n\n    return &it_models->second;\n}\n<fim-suffix><fim-middle>DEFINE_STRATEGY_ENTRY(DeribitMdp)"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS)<fim-suffix><fim-middle>VOLATILITY(svi, SVI)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override;<fim-suffix>void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected()<fim-middle>void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor<fim-suffix>{ public: DeribitContributor(const tbricks::InitializationReason & reason,<fim-middle>: public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp>\n#include <shared\/SuppressSfApiClangWarnings.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/Price.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/Boolean.h>\n#include <strategy\/calculated_property\/CalculatedPropertyFilter.h>\n#include <strategy\/TreeNodeParameters.h>\n#include <strategy\/parameter\/StrategyParameters.h>\n#include <strategy\/parameter\/StrategyInstanceParameters.h>\nCLANG_RESTORE_WARNINGS\n#include <set>\n\nusing namespace tbricks;\n\nenum class PreferencesStorageKind\n{\n    Common = 0,\n    Wing,\n    CCS,\n    SVI\n};\n\nstd::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind);\n\n\/**\n * Struct representing the various settings common to all VMs; it is subclassed by structs\n * containing additional parameters relevant for particular VMs\n *\/\nclass PreferencesStorage: public Printable\n{\npublic:\n    PreferencesStorage();\n\nprotected:\n    PreferencesStorage(const PreferencesStorage & storage) = default;\n    PreferencesStorage & operator=(const PreferencesStorage & storage) = default;\n\npublic:\n    virtual ~PreferencesStorage();\n\n    virtual PreferencesStorageKind GetKind() const = 0;\n\n    virtual void Clear();\n    virtual void Copy(const PreferencesStorage & preferencesStorage);\n\n    virtual bool FillFromTreeNodeParameters(const TreeNodeParameters & parameters);\n    virtual bool FillFromStrategyParameters(const StrategyParameters & parameters);\n    virtual bool FillFromStrategyInstanceParameters(const StrategyInstanceParameters & parameters);\n\n    virtual bool GetParameter(const TreeNodeParameterDefinition & def, AnyType & value) const;\n    virtual bool GetParameter(const ParameterDefinition & def, AnyType & value) const;\n\n    virtual void GetParameters(TreeNodeParameters & parameters) const;\n    virtual void GetParameters(StrategyParameters & parameters) const;\n    virtual void GetParameters(StrategyInstanceParameters & parameters) const;\n\n    virtual bool GetNonDefaultParameter(const TreeNodeParameterDefinition & def, AnyType & value) const;\n    virtual bool GetNonDefaultParameter(const ParameterDefinition & def, AnyType & value) const;\n\n    virtual void GetNonDefaultParameters(TreeNodeParameters & parameters) const;\n    virtual void GetNonDefaultParameters(StrategyParameters & parameters) const;\n    virtual void GetNonDefaultParameters(StrategyInstanceParameters & parameters) const;\n\n    virtual bool Merge(const PreferencesStorage & preferencesStorage);\n\n    virtual std::ostream & Print(std::ostream & strm) const override;\n\n    virtual const std::set<TreeNodeParameterDefinition> & GetLevelAnchoredParameters() const { return m_scopeLevelAnchoredPreferences; }\n\n    static const CalculatedPropertyFilter dummyFilter;\n\n    ValueWithDefault<Boolean>   autoFit;\n    ValueWithDefault<Boolean>   autoApplyAutoFit;\n    ValueWithDefault<Boolean>   globalAvoidExtraFits;\n    ValueWithDefault<Boolean>   globalUnderlyingTradingStatusTracking;\n    ValueWithDefault<Boolean>   optionTradingStatusTracking;\n    ValueWithDefault<Integer>   loggingMode;\n    ValueWithDefault<Integer>   maxAllowedFitRejects;\n    ValueWithDefault<Boolean>   maturityExcludedFromGlobalActions;\n    ValueWithDefault<Boolean>   sendQuotingRecommendations;\n    ValueWithDefault<Table>     quotingRecommendations;\n\n    ValueWithDefault<Boolean>    parallelShift;\n    ValueWithDefault<Enumeration> curveShiftUnits;\n    ValueWithDefault<Integer>    ATMVolatilityShiftMode;\n    ValueWithDefault<Boolean>    includeExoticOptions;\n    ValueWithDefault<Boolean>    autoFetchATMVolatilityPath;\n    ValueWithDefault<Boolean>    globalAutoFetchATMVolatilityPath;\n    ValueWithDefault<Integer>    instrumentGroupType;\n    ValueWithDefault<Identifier> suggestContext;\n    ValueWithDefault<Integer>    trackingAreaType;\n    ValueWithDefault<Boolean>    volatilityCurveSafetyCheckEnabled;\n    ValueWithDefault<Double>     safetyParameterChange;\n    ValueWithDefault<Double>     safetyModelChange;\n    ValueWithDefault<Boolean>    checkForStaticArbitrage;\n    ValueWithDefault<Double>     calendarSpreadArbitrageTolerance;\n    ValueWithDefault<Double>     butterflyArbitrageTolerance;\n    ValueWithDefault<Boolean>    enableCurveQualityMetrics;\n\n    ValueWithDefault<Integer>   fitWeighting;\n    ValueWithDefault<Boolean>   autocorrectFitWeights;\n    ValueWithDefault<Boolean>   fitOnlyATMVol;\n    ValueWithDefault<Boolean>   addVirtualBids;\n    ValueWithDefault<Double>    virtualBidRatio;\n    ValueWithDefault<Boolean>   robustFittingOnWings;\n    ValueWithDefault<Double>    robustFittingOnWingsStrength;\n    ValueWithDefault<Boolean>   autoResetSwimRefPriceToATM;\n    ValueWithDefault<Integer>   crossingProcessing;\n    ValueWithDefault<Boolean>   anomalyDetection;\n    ValueWithDefault<Double>    anomalyDetectionSensitivity;\n\n    ValueWithDefault<Boolean>   enableAmerican;\n    ValueWithDefault<Boolean>   enableATM;\n    ValueWithDefault<Boolean>   enableDeepITM;\n    ValueWithDefault<Boolean>   enableDeepOTM;\n    ValueWithDefault<Boolean>   enableEuropean;\n    ValueWithDefault<Boolean>   enableITM;\n    ValueWithDefault<Boolean>   enableCashDelivery;\n    ValueWithDefault<Boolean>   enableCrossings;\n    ValueWithDefault<Boolean>   enableLowBids;\n    ValueWithDefault<Boolean>   enablePhysicalDelivery;\n    ValueWithDefault<Boolean>   enableSmallDelta;\n    ValueWithDefault<Boolean>   enableWideSpreads;\n    ValueWithDefault<Boolean>   enableNoSpreads;\n    ValueWithDefault<Boolean>   enableOTM;\n    ValueWithDefault<Boolean>   enableLowVolumes;\n    ValueWithDefault<Price>     minimumBidPrice;\n    ValueWithDefault<Volume>    minimumVolume;\n    ValueWithDefault<Table>     manuallyToggledPoints;\n    ValueWithDefault<Table>     impliedVolatilitySources;\n    ValueWithDefault<CalculatedPropertyFilter>    instrumentFilter;\n    ValueWithDefault<Integer>   tradingPhaseProcessing;\n\n    ValueWithDefault<Boolean>    showExcludedPoints;\n    ValueWithDefault<Boolean>    autocorrectVolatilityChartZooming;\n    ValueWithDefault<Double>     deltaValueForVerticalLines;\n    ValueWithDefault<Boolean>    showVerticalLinesAtGivenDelta;\n    ValueWithDefault<Double>     volatilityCurveChartAutoRangePadding;\n    ValueWithDefault<Identifier> portfolio;\n    ValueWithDefault<Boolean>    preserveZooming;\n    ValueWithDefault<Double>     distanceBetweenCurvePoints;\n    ValueWithDefault<Integer>    autoRangeMode;\n    ValueWithDefault<Boolean>    showReferenceVols;\n    ValueWithDefault<Boolean>    showReferenceCurve;\n    ValueWithDefault<Boolean>    showBidAskRange;\n    ValueWithDefault<Integer>    putCallColors;\n    ValueWithDefault<Integer>    colorScheme;\n\nprotected:\n    std::set<TreeNodeParameterDefinition>    m_scopeLevelAnchoredPreferences;\n};\n<fim-suffix><fim-middle>class CommonPreferencesStorage: public PreferencesStorage\n{\npublic:\n    CommonPreferencesStorage() = default;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem<fim-suffix><fim-middle>& item, DistributedValues::Stream::IHandler & handler)"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\" using namespace tbricks; InstrumentManager::InstrumentManager(IHandler& handler) : m_handler(handler) , m_instrumentStream(*this) , m_iapStream(*this) , m_failed(0) { TBDEBUG(__func__ << \" ctor\"); } InstrumentManager::~InstrumentManager() { TBDEBUG(__func__ << \" dtor\"); Stop(); } void InstrumentManager::Stop() { TBDEBUG(__func__); m_instrumentCache.clear(); m_underlyingCache.clear(); m_instrumentModifyRequests.clear(); m_instrumentStream.Close(); } void InstrumentManager::Start() { TBDEBUG(__func__); m_failed = 0; Stop(); OpenInstrumentStream(); } void InstrumentManager::OpenInstrumentStream() { TBDEBUG(__func__); InstrumentStream::Options options; options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup())); m_instrumentStream.Open(Stream::SNAPSHOT, options); TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter()); } void InstrumentManager::OpenIAPStream() { TBDEBUG(__func__); tbricks::InstrumentAggregateParameters::Stream::Options options; for (const auto& [instId, _] : m_instrumentCache) { options.AddInstrument(instId); } options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()}); m_iapStream.Close(); m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options); TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options); } void InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID) { TBDEBUG(__func__ << \" : \" << streamID); } void InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID) { TBWARNING(\"Instrument cache stream staled = \" << streamID); } void InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID) { m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\"); } void InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID) { TBDEBUG(__func__ << \" : \" << streamID); if (streamID == m_instrumentStream.GetIdentifier()) { TBDEBUG(\"Instruments snapshot done, opening parameters stream...\"); OpenIAPStream(); } else if (streamID == m_iapStream.GetIdentifier()) { \/\/ all data is collected, now perform the next steps EnrichInstruments(); } } void InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument) { TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier()); TBDUMP(instrument); if (streamID == m_instrumentStream.GetIdentifier()) { m_instrumentCache[instrument.GetIdentifier()] = instrument; } else { TBWARNING(\"Instrument update received from unknown stream = \" << streamID); } } void InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID, const InstrumentIdentifier& instrumentID, const InstrumentAggregateParameters::Update& update) { TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update); InstrumentIdentifier underlyingId; if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId)) { m_underlyingCache[instrumentID] = underlyingId; } } void InstrumentManager::CheckModificationStatus() { if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty()) { const int total = m_instrumentCache.size(); std::stringstream result; result << \"Total instruments = \" << total << \", successful = \" << total - m_failed << \", failed = \" << m_failed; m_handler.HandleImportComplete(result.str()); } } void InstrumentManager::EnrichInstruments() { TBDEBUG(__func__); for (const auto& [instID, instrument] : m_instrumentCache) { InstrumentModifier instrumentModifier(instID); DateTime tbMaturityDate; instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate); if (tbMaturityDate != m_handler.GetMaturityDate()) { InstrumentAttributes attributes; attributes.SetAttribute(instrument_attributes::MaturityDate(), m_handler.GetMaturityDate()); instrumentModifier.SetAttributes(attributes); Instrument::RequestResult result = Instrument::SendModifyRequest(instrumentModifier, *this); m_instrumentModifyRequests.emplace(result.GetRequestIdentifier(), instID); } } ModifyGroup(); CheckModificationStatus(); } void InstrumentManager::ModifyGroup() { TBDEBUG(__func__); InstrumentGroupIdentifier groupID = m_handler.GetInstrumentGroup().GetIdentifier(); std::vector<InstrumentParameterDefinition> defs; defs.push_back(instrument_parameters::UnderlyingInstrument()); InstrumentGroupParameters groupParams(groupID, defs); InstrumentIdentifier underlyingInstrument; groupParams.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingInstrument); InstrumentGroupParameters::Modifier modifier; if (underlyingInstrument.Empty()) { modifier.SetParameter(instrument_parameters::UnderlyingInstrument(), m_handler.GetUnderlyingInstrument()); } else { TBNOTICE(\"Not changing existing underlying instrument for group\"); } if (not modifier.Empty()) { Identifier id = InstrumentGroupParameters::SendModifyRequest(groupID, modifier, *this); m_groupModifyRequests.emplace(id, groupID); } }<fim-suffix>{ TBDEBUG(__func__ << \" : \" << id); if (const<fim-middle>void InstrumentManager::HandleRequestReply(const Identifier& id, class Status status, const String& status_text)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider<fim-suffix><fim-middle>{ public: DeribitMdp(); ~DeribitMdp() noexcept override = default;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const<fim-suffix><fim-middle>tbricks::InstrumentIdentifier & instrument);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Reset(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Fail(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update) { TBDEBUG(__func__ << \": \" << stream); TBDUMP(update); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->HandleDistributedValuesUpdate(update); } else { TBDEBUG(\"No Deribit model associated with stream: \" << stream); } } std::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream) { auto it_streams = m_streams.find(stream); if (it_streams == m_streams.end()) { return std::nullopt; } return GetModel(it_streams->second); } std::optional<DeribitModel *> DeribitMdp::GetModel(const InstrumentIdentifier & instrument) { auto it_models = m_models.find(instrument); if (it_models == m_models.end()) {<fim-suffix>return &it_models->second; }<fim-middle>return std::nullopt; }"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VizualizationApp methods void HandleStrategyViewCreate(<fim-suffix>void HandleStrategyViewUpdate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleStrategyViewDelete( tbricks::visualization::models::AppViewModel& viewModel) final; void HandleGridViewCreate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleGridViewUpdate(<fim-middle>tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n<fim-suffix><fim-middle>{\npublic:\n    heartbeat(JsonReply && base);"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler&<fim-suffix>~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const<fim-middle>handler);"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <third_party\/include\/rapidjson\/document.h>\n#include <deribit\/DeribitInstrument.h>\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler,\n                          public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0;\n        virtual void HandleInstrumentManagerReady() = 0;\n        virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0;\n        virtual void HandleInstrumentError(const tbricks::String & error) = 0;\n    };\n\n    explicit InstrumentManager(IHandler & handler);\n    ~InstrumentManager() override;\n\n    void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument);\n\n    void Start();\n    void SyncInstruments();\n    void Clear();\n    bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); }\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamStale(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;\n<fim-suffix><fim-middle>    void HandleInstrument(const tbricks::StreamIdentifier & stream, \n                         const tbricks::Instrument & instrument) override;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier & stream, "}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n<fim-suffix><fim-middle>private:\n    MemBuf _buffer;\n};"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update)<fim-suffix>std::optional<DeribitModel *> GetModel(const<fim-middle>override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler);<fim-suffix>void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update<fim-middle>~DeribitModel() noexcept = default;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume {0}; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void<fim-suffix>{ InstrumentStatus status;<fim-middle>DeribitModel::Fail()"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool<fim-suffix>void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String &<fim-middle>throttled = true);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const<fim-suffix>~PositionsData(); void Stop(); public: using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>;<fim-middle>tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem<fim-suffix>{ TBDEBUG(__func__ << \", item =<fim-middle>& item)"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (m_volatility_model->IsInterpolated()) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group\n    , const InstrumentGroupAggregateParameters::Update & update)\n{\n    return HandleVolatilityGroupParameters(&update);\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group)\n{\n    PDEBUGN(\"Handle volatility group parameters snapshot done\");\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerSnapshot(m_group);\n    }\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType()\n{\n    PDEBUGN(\"VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType\");\n    if (SwitchVolatilityModel()) {\n        for (auto subscriber : m_subscribers) {\n            subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n        }\n    }\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParameters(const InstrumentGroupAggregateParameters::Update * update)\n{\n    PDEBUGN(\"Handle volatility group parameters\");\n    if (update) {\n        PDUMPN(\"Update = \" << *update);\n    }\n\n    bool changed = false;\n\n    changed |= SwitchVolatilityModel();\n    if (!changed && m_volatility_model) {\n        if (update) {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*update, *m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        } else {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        }\n    }\n\n    if (changed) {\n        m_volatility_models.clear();\n    }\n\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n    }\n\n    return changed;\n}\n\nbool VolatilityCurveHandler::SwitchVolatilityModel()\n{\n    PDEBUGN(\"Switch volatility model\");\n    if (!m_parameters_provider) return false;\n\n    const Integer & type = m_parameters_provider->GetVolatilityModelType();\n    PDEBUGN(\"New volatility model type \" << type);\n\n    const VolatilitySurfaceContainer * container = m_parameters_provider->GetVolatilitySurfaceContainer();\n    const auto interpolated = container && volatility::InterpolatedVolatilityModel::IsApplicable(*container, m_plugin.GetVolatilitySurfaceDefinitions(type), m_maturity_date);\n\n    if (m_volatility_model\n        && type == m_volatility_model->GetVolatilityModelType()\n        && interpolated == m_volatility_model->IsInterpolated())\n    {\n        PDEBUGN(\"Volatility model is not changed\");\n        return false;\n    }\n\n    bool changed = static_cast<bool>(m_volatility_model);\n    m_volatility_model.reset();\n    m_volatility_models.clear();\n\n    if (type.Empty()) {\n        PDEBUGN(\"Volatility type is empty, cached shared volatility models are cleared\");\n        return changed;\n    }\n\n    if (interpolated)\n    {\n        m_volatility_model = std::make_shared<volatility::InterpolatedVolatilityModel>(type.GetInt32());\n    } else {\n        switch(type.GetInt()) {\n            case pricing::VolatilityModelNone:\n                m_volatility_model = std::make_shared<volatility::ConstantVolatility>();\n                break;\n            case pricing::VolatilityModelCCS:\n                m_volatility_model = std::make_shared<volatility::ClampedCubicSpline>();\n                break;\n            case pricing::VolatilityModelCustom:\n                m_volatility_model = std::make_shared<volatility::CustomVolatilityModel>();\n                break;\n            case pricing::VolatilityModelWing:\n                m_volatility_model = std::make_shared<volatility::WingVolatilityModel>();\n                break;\n            case pricing::VolatilityModelSVI:\n            default:\n                m_volatility_model = std::make_shared<volatility::StochasticVolatilityInspired>();\n                break;\n        }\n    }\n<fim-suffix><fim-middle>    if (container) {\n        m_volatility_model->UpdateVolatilitySurfaceParameters(*m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n    }"}
{"content":"<fim-prefix>#include \"PositionReversalsPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; PositionReversalsPlugin::PositionReversalsPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_manager(*this) , m_portfolio(position_reversals::strategy_parameters::Portfolio()) , m_startTime(position_reversals::strategy_parameters::PositionReversalStartTime()) , m_priceSource(position_reversals::strategy_parameters::PositionReversalPriceSource()) , m_status(position_reversals::strategy_parameters::StatusInformationText()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); if (GetTransactionOperation().IsRun()) { DoRun(); } } bool PositionReversalsPlugin::CanRun(tbricks::String& error) { TBDEBUG(__func__); if (m_portfolio.GetPortfolioIdentifier().Empty()) { error = \"No portfolio selected\"; return false; } if (m_startTime.GetTime().Empty()) { error = \"No start time selected\"; return false; } if (m_priceSource.GetInteger().Empty()) { error = \"No price source selected\"; return false; } return true; } void PositionReversalsPlugin::DoRun() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); String error; if (CanRun(error)) { m_manager.Start(m_portfolio.GetPortfolioIdentifier(), m_priceSource.GetInteger(), m_startTime.GetTime()); SetState(StrategyState::RUNNING); } else { m_status = error; SetTransactionFail(error); } } void PositionReversalsPlugin::DoPause() { m_manager.Stop(); SetState(StrategyState::PAUSED); } void PositionReversalsPlugin::HandleRunRequest(void) { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); } else { DoRun(); } } void PositionReversalsPlugin::HandlePauseRequest(void) { TBDEBUG(__func__); if (GetState().IsPaused()) { TBDEBUG(\"Already paused\"); } else { DoPause(); } } void PositionReversalsPlugin::HandleDeleteRequest(void) { TBDEBUG(__func__); DoPause(); SetState(StrategyState::DELETED); } void PositionReversalsPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" modifier: \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void PositionReversalsPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" constext:\" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void PositionReversalsPlugin::HandleStrategyViewCreate( visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \", update: \" << update); viewModel.MergeUpdate(update); viewModel.ApplyModifications(); } void PositionReversalsPlugin::HandleStrategyViewUpdate( visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \", update: \" << update); m_status = \"\"; viewModel.MergeUpdate(update); viewModel.ApplyModifications(); } void PositionReversalsPlugin::HandleStrategyViewDelete(visualization::models::AppViewModel& viewModel) { TBDEBUG(__func__); } void PositionReversalsPlugin::HandleGridViewUpdate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \" update = \" << update); viewModel.MergeUpdate(update); viewModel.ApplyModifications(); viewModel.RejectUnconfirmedModifications(); } void PositionReversalsPlugin::HandleGridViewDelete(visualization::models::GridViewModel& viewModel) { TBDEBUG(__func__); } void PositionReversalsPlugin::HandleGridViewCreate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \" update = \" << update); HandleGridViewUpdate(viewModel, update); } void PositionReversalsPlugin::HandleError(const tbricks::String& error) { m_status = error; } void PositionReversalsPlugin::HandlePositionsReversed() {<fim-suffix><fim-middle>m_status = \"Position reversals done!\";"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely picked up by another calc app \/\/ the engine was just checking if we responded to it } } Send(); } \/\/<fim-suffix><fim-middle>Note that here we use DEFINE_PRICING_ENTRY instead of the normal DEFINE_STRATEGY_ENTRY DEFINE_PRICING_ENTRY(ExampleCalcAppPlugin)"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument); private: std::map<tbricks::StreamIdentifier, tbricks::InstrumentIdentifier> m_streams; std::map<tbricks::InstrumentIdentifier, DeribitModel><fim-middle>& stream_id, const tbricks::DistributedValues::Update & update) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n<fim-suffix><fim-middle>    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nusing InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>;\nusing UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>;\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n<fim-suffix><fim-middle>    InstrumentManager(IHandler& handler);\n    ~InstrumentManager();\n    void Start();\n    void Stop();"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/String.h> #include <strategy\/type\/Volume.h> namespace execution { struct Stats { tbricks::Volume bought;<fim-suffix><fim-middle>tbricks::Volume sold;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"shared\/API.h\"\n\nclass ExampleCalcAppPlugin : public tbricks::Pricing\n{\npublic:\n\n    ExampleCalcAppPlugin(const tbricks::PricingRequest & request);\n    void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override;\n\nprivate:\n\n    using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>;\n\n    void HandleDeleteRequest() override {};\n    void HandleRunRequest() override {};\n    void HandlePauseRequest() override {};\n<fim-suffix><fim-middle>    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override {};\n    void HandleValidateRequest(tbricks::ValidationContext &context) override {};"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument); private: std::map<tbricks::StreamIdentifier, tbricks::InstrumentIdentifier> m_streams; std::map<tbricks::InstrumentIdentifier, DeribitModel><fim-suffix><fim-middle>m_models; };"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n<fim-suffix><fim-middle>        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n<fim-suffix><fim-middle>        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::CalculatedInstrumentValues::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n\n    explicit InstrumentManager(IHandler& handler);\n    ~InstrumentManager() noexcept override;\n    void Start();\n    void Stop();\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;\n\n    void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {};\n\n    void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID,\n                                             const tbricks::InstrumentIdentifier & instrumentID,\n                                             const tbricks::InstrumentAggregateParameters::Update & update) override;\n\n    void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId,\n                                                  const tbricks::CalculatedInstrumentValues::Update & update) final;\n\n    void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final;\n\nprivate:\n    void OpenInstrumentStream();\n    void OpenIAPStream();\n    void OpenCIVStream();\n    void EnrichInstruments();\n    void ModifyGroup();\n    void CheckResolutionStatus();\n    void CheckModificationStatus();\n<fim-suffix><fim-middle>    struct InstrumentDetails\n    {\n        tbricks::Instrument             instrument;\n        tbricks::DateTime               maturityDate;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h><fim-suffix>#include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from =<fim-middle>SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h>"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm;<fim-suffix>} Binary_ostream & operator<<(Binary_ostream &<fim-middle>ostm.write(val, size); return ostm;"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n<fim-suffix><fim-middle>        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_plugInStatusDescription.Clear();\n        m_instrumentManager.Start();\n\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n<fim-suffix><fim-middle>    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n        Channel channel; \/\/ should be always sorted\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n<fim-suffix><fim-middle>private:\n    void OnLoginReply(SingleTransaction & t);\n    void OnSetHeartbeatReply(SingleTransaction & t);\n    void OnHeartbeat(deribit::JsonReply && incoming);"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (m_volatility_model->IsInterpolated()) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group\n    , const InstrumentGroupAggregateParameters::Update & update)\n{\n    return HandleVolatilityGroupParameters(&update);\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group)\n<fim-suffix><fim-middle>{\n    PDEBUGN(\"Handle volatility group parameters snapshot done\");\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerSnapshot(m_group);"}
{"content":"<fim-prefix>#include \"ReversalManager.h\" #include \"tbricks_definitions.h\" #include <map> using namespace tbricks; ReversalManager::ReversalManager(IHandler& callback) : m_callback(callback) , m_scheduledTimer(*this) , m_positionRetriever(*this) { } void ReversalManager::Start( const PortfolioIdentifier& portfolioId, const Integer& priceSource, const Time& startTime) { m_portfolioId = portfolioId; m_priceSource = priceSource; m_scheduledTimer.Start(startTime); } void ReversalManager::Stop() { m_scheduledTimer.Stop(); m_positionRetriever.Stop(); } void ReversalManager::HandleTimerEvent(Timer & timer) { TBDEBUG(__func__); m_positionRetriever.RetreivePositions(m_portfolioId); } void ReversalManager::HandleError(const tbricks::String& error) { m_callback.HandleError(error); } void ReversalManager::HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions) { for (const auto& [_, position] : positions) { Price reversalPrice; const auto& ivid = position.GetInstrumentVenueIdentification(); StatisticsStream stream; if (m_priceSource == position_reversals::enumerations::PositionReversalPriceSource::PositionReversalPriceSourceOpen) { stream.SetSubscribedFields(StatisticsStream::Fields::OpeningPrice()); } else { stream.SetSubscribedFields(StatisticsStream::Fields::ClosingPrice()); } stream.Open(Stream::SNAPSHOT, ivid, StatisticsStream::Options()); Statistics stats; stream.GetSnapshot(stats); if (m_priceSource == position_reversals::enumerations::PositionReversalPriceSource::PositionReversalPriceSourceOpen) { if (stats.HasOpeningPrice()) { reversalPrice = stats.GetOpeningPrice(); } } else { if (stats.HasClosingPrice()) { reversalPrice = stats.GetClosingPrice(); } }<fim-suffix>{<fim-middle>if (not reversalPrice.Empty())"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const<fim-suffix><fim-middle>tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); }"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n<fim-suffix><fim-middle>{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler & handler)\n    : m_instrumentStream(*this)\n    , m_handler(handler)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Clear()\n{\n    m_tbricksInstruments.clear();\n    m_deribitInstruments.clear();\n    m_pendingCreates.clear();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n    \n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByVenueFilter(m_handler.GetVenueIdentifier()) && InstrumentStream::Filters::DeletedFilter(\/*deleted=*\/false));\n    m_instrumentStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n    \n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() \n            << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    String key = GetInstrumentKey(deribitInstrument);\n    m_deribitInstruments[key] = deribitInstrument;\n}\n\nString InstrumentManager::GetInstrumentKey(const Instrument & instrument)\n{\n    return instrument.GetShortName();\n}\n\nString InstrumentManager::GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    return deribitInstrument->instrument_name;\n}\n\nvoid InstrumentManager::Start()\n{\n    Clear();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::SyncInstruments()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \": Comparing \" << m_tbricksInstruments.size() \n            << \" Tbricks instruments with \" << m_deribitInstruments.size() \n            << \" Deribit instruments\");"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept<fim-suffix><fim-middle>override = default;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) {<fim-suffix>void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update<fim-middle>"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include <shared\/API.h>"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin2 : public tbricks::Pricing { public: ExampleCalcAppPlugin2(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; bool HandlePartialPricingModifyRequest(const tbricks::CalculatedValuesRequestUpdate &update) override; private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override {}; void HandleRunRequest() override {}; void HandlePauseRequest() override {}; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override {}; void HandleValidateRequest(tbricks::ValidationContext &context) override {}; void Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request); void<fim-suffix><fim-middle>Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x);"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n<fim-suffix><fim-middle>void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n<fim-suffix><fim-middle>    return false;\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void<fim-suffix>{ TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription =<fim-middle>InstrumentEnricherPlugin::HandleRunRequest()"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n\npublic_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n{\n}\n\nheartbeat::heartbeat(JsonReply && base)\n    : JsonReply(std::move(base))\n    , type {Pointer(\"\/params\/type\").Get(msg)->GetString()}\n{\n}\n\nstd::string_view heartbeat::GetType() const\n{\n    return type;\n}\n\nbool heartbeat::IsTestRequest() const\n{\n    return type == \"test_request\" ? true : false;\n}\n\nsubscriptions::subscriptions(const std::string_view id, DeribitMethod method)\n    : JsonCall(id, method)\n{\n    auto & params = msg[\"params\"];\n    Value v(rapidjson::kArrayType);\n    params.AddMember(\"channels\", v, msg.GetAllocator());\n}\n\nvoid subscriptions::AddChannel(const std::string & channel)\n<fim-suffix><fim-middle>{\n    auto ptr = Pointer(\"\/params\/channels\");\n    if (ptr.IsValid())\n    {"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear(); m_wasStreamStale = false; TBDEBUG(__func__); if (m_positionStream.IsOpen()) { m_positionStream.Close(); } m_positionStream.Open( Stream::SNAPSHOT, portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, AnyPositionFilter()); } void PositionRetriever::Stop() { m_positionStream.Close(); m_positions.clear(); } void PositionRetriever::HandleStreamOpen(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { if (not m_wasStreamStale) { TBDEBUG(__func__ << \" Stream opened: \" << stream_id); } else { TBNOTICE(\"Stream reconnected\"); m_wasStreamStale = false; } } else { TBDEBUG(__func__ << \" Unknown opened stream: \" << stream_id); } } void PositionRetriever::HandleStreamStale(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBWARNING(__func__ << \" Stream became stale: \" << stream_id); m_wasStreamStale = true; } else { TBWARNING(__func__ << \" Unknown stale stream: \" << stream_id); } } void PositionRetriever::HandleStreamFailed(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { std::stringstream error; error << \"Stream failed: \" <<<fim-suffix>m_callback.HandleError(error.str()); } else { TBWARNING(__func__ << \" Unknown failed stream: \" << stream_id); } } void PositionRetriever::HandleSnapshotEnd(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBDEBUG(__func__ << \" Snapshot end received on stream: \" << stream_id); m_callback.HandlePositions(m_positions); } else { TBDEBUG(__func__ << \" Received snapshot end on unknown stream: \" << stream_id); } } void PositionRetriever::HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) { TBDEBUG(__func__ << \" \" << stream_id); TBDUMP(position); if (m_positionStream.GetIdentifier() == stream_id) { m_positions.emplace(position.GetIdentifier(), position); } else { TBDEBUG(__func__ << \" Received position on<fim-middle>stream_id;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification &<fim-suffix>\/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream<fim-middle>ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to<fim-suffix>SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned<fim-middle>send when performing WebSocket upgrade.         \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol."}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void<fim-suffix>void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); };<fim-middle>SetGrantType(GrantType type);"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h>\n#include <shared\/volatility\/ClampedCubicSpline.h>\n#include <shared\/volatility\/StochasticVolatilityInspired.h>\n#include <shared\/volatility\/WingVolatilityModel.h>\n\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypeRef>\nModelTypeRef vol_model_cast(volatility::IVolatilityModel & model);\n\ntemplate <class ModelTypeRef>\nModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model);\n\n#define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\\n    template <> \\\n    inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\\n    { \\\n        if (TB_UNLIKELY(!pModel)) { \\\n            return nullptr; \\\n        } \\\n        \\\n        if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\\n            TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\\n            throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\\n        } \\\n        \\\n        return reinterpret_cast<specifier volatility::model*>(pModel); \\\n    }\n\n#define VOL_MODEL_REF_CAST_IMPL(specifier, model, type) \\\n    template <> \\\n    inline specifier volatility::model & vol_model_cast(specifier volatility::IVolatilityModel & rModel) \\\n    { \\\n        if (TB_UNLIKELY(rModel.GetVolatilityModelType() != type)) { \\\n            TBWARNING(\"Detected attempt to cast volatility model of type \" << rModel.GetVolatilityModelType() << \" to type \" << type); \\\n            throw volatility::VolatilityModelTypeMismatchException(rModel.GetVolatilityModelType(), type); \\\n        } \\\n        \\\n        return reinterpret_cast<specifier volatility::model&>(rModel); \\\n    }\n<fim-suffix><fim-middle>#define VOL_MODEL_CAST_IMPL(specifier, model, type) \\\n    VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\\n    VOL_MODEL_REF_CAST_IMPL(specifier, model, type)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/String.h> #include <strategy\/type\/Volume.h> namespace execution { struct Stats { tbricks::Volume bought; tbricks::Volume sold; tbricks::Double valueBought; tbricks::Double valueSold; }; enum class<fim-suffix><fim-middle>OrderExecutorType {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/VisualizationApp.h> #include <strategy\/visualization\/ViewModelUpdate.h> #include <strategy\/visualization\/ICellValue.h> #include <strategy\/visualization\/Grid.h> #include \"InstrumentManager.h\" #include \"TimerController.h\"<fim-suffix>, public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final;<fim-middle>class InstrumentEnricherPlugin : public tbricks::VisualizationApp"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status,<fim-suffix><fim-middle>const std::string & reason = \"\");"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely picked up by another calc app \/\/ the engine was just checking if we responded to it } } Send(); } \/\/ Note<fim-suffix><fim-middle>that here we use DEFINE_PRICING_ENTRY instead of the normal DEFINE_STRATEGY_ENTRY DEFINE_PRICING_ENTRY(ExampleCalcAppPlugin)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n<fim-suffix><fim-middle>        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\" #include \"DeribitProtocol.h\" #include <strategy\/Logger.h> #include <algorithm> using namespace tbricks; bool DeribitClient::Session::IsExpired() const { return DateTime::Now() > expires_datetime; } void DeribitClient::Session::SetExpires(int seconds) { expires = seconds; expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt()); } void DeribitClient::Session::Reset() { connected = false; logged_in = false; token.Clear(); refresh.Clear(); expires.Clear(); expires_datetime.Clear(); } std::ostream & DeribitClient::Session::Print(std::ostream & strm) const { strm << \"<Session> {\\n\"; strm << \" connected = \" << std::boolalpha << connected << \"\\n\"; strm << \" logged_in = \" << std::boolalpha << logged_in << \"\\n\"; strm << \" heartbeat = \" << hb << \"\\n\"; strm << \" userId = \" << userId << \"\\n\"; strm << \" secret = \" << secret << \"\\n\"; strm << \" host_port_path = \" << host_port_path << \"\\n\"; strm << \" token = \" << token << \"\\n\"; strm << \" refresh = \" << refresh << \"\\n\"; strm << \" expires = \" << expires << \"\\n\"; strm << \" expires_datetime = \" << expires_datetime << \"\\n\"; strm << \"}\"; return strm; } std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t) { strm << \"<SingleTransaction> {\\n\"; strm << \" id : \" << t.id << \"\\n\"; strm << \" method : \" << Resolve(t.method) << \"\\n\"; if (t.call) { strm << \" call : \" << t.call->ToString() << \"\\n\"; } if (t.reply) { strm << \" reply : \" << t.reply->ToString() << \"\\n\"; } if (not t.reqChannels.empty()) { strm << \" reqChannels : \" << t.reqChannels << \"\\n\"; } strm << \"}\"; return strm; } DeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type) : m_handler(handler) , m_timer(*this, \"deribit_refresh\") { TBDEBUG(__func__ << \" : \" << endpoint); std::string url(endpoint.GetCString()); auto found = url.find(\":\/\/\"); if (found != std::string::npos) { url = url.substr(found + 3); } m_session.host_port_path = url; std::vector<String> slices; m_session.host_port_path.Split(':', slices); TBDUMP(slices); switch (type) { case DeribitHost::NONE: m_conf.header.insert({\"Host\", slices[0].GetCString()}); break; default: m_conf.header.insert({\"Host\", Resolve(type)}); break; } } DeribitClient::~DeribitClient() { TBDEBUG(__func__); Disconnect(); } void DeribitClient::Connect(const String & userId, const String & secret) { TBDEBUG(__func__ << \" : userId=\" << userId << \" secret=\" << secret); m_session.userId = userId; m_session.secret = secret; m_ws = std::make_unique<TbWebsocketClient>(*this, m_session.host_port_path, m_conf); m_ws->Connect(); } void DeribitClient::Disconnect() { TBDEBUG(__func__); if (m_ws) { m_session.logged_in = false; m_ws->Shutdown(); } } void DeribitClient::SetHeartbeat(int seconds) { TBDEBUG(__func__ << \" : \" << seconds << \"s\"); m_session.hb = seconds; if (m_ws) { auto & t = NewTransaction(); t.method = DeribitMethod::PUBLIC_SetHeartbeat; t.call = std::make_unique<deribit::public_set_heartbeat>(t.id.ToString().GetCString()); auto msg = dynamic_cast<deribit::public_set_heartbeat *>(t.call.get()); msg->SetInterval(seconds); PerformTransaction(t); } else<fim-suffix><fim-middle>{"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply &&<fim-suffix>bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public: subscriptions(const std::string_view id, DeribitMethod method); void AddChannel(const std::string & channel); }; class subscriptions_reply : public JsonReply { public: subscriptions_reply(JsonReply && base); std::vector<std::string_view> GetChannels() const; }; class subscription_update : public JsonReply { public: subscription_update(JsonReply && base); std::string_view GetChannel() const; std::string_view GetData(); private:<fim-middle>base); std::string_view GetType() const;"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\" #include \"ConstantVolatility.h\"<fim-suffix>#include \"WingVolatilityModel.h\" #endif<fim-middle>#include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\""}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n<fim-suffix><fim-middle>{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); } void DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request) { TBDEBUG(__func__<fim-suffix>} void DeribitContributor::FailWithReason(const String & reason) { SetTransactionFail(reason, StrategyState::PAUSED); } void DeribitContributor::HandleDeribitConnected() { TBDEBUG(__func__); SetState(StrategyState::RUNNING); m_client->SetHeartbeat(30); } void DeribitContributor::HandleDeribitDisconnected() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); }<fim-middle><< \": \" << request);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) {<fim-suffix><fim-middle>if (val.size() <= 0)"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item)<fim-suffix><fim-middle>override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n<fim-suffix><fim-middle>    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {"}
{"content":"<fim-prefix>#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include <strategy\/Logger.h>\n#include <strategy\/stream_filter\/PositionByPortfolioFilter.h>\n#include <strategy\/SparseSet.h>\n#include <sstream>\n#include <vector>\n\nusing namespace tbricks;\n\nnamespace cps = go_flat::calculated_properties::position;\n\nPositionsData::PositionsData(const PortfolioIdentifier& portfolioId, StringParameter& status)\n: m_appStatus(status)\n, m_stream(*this)\n{\n    TBDEBUG(__func__ << \" : \" << portfolioId);\n\n    CalculatedPropertiesTable::Stream::Options options;\n\n    options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {});\n\n    options.AddProperty(cps::Instrument());\n    options.AddProperty(cps::Venue());\n    options.AddProperty(cps::MIC());\n    options.AddProperty(cps::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS());\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n    TBDUMP(\"Stream opened with options: \" << options);\n}\n\nPositionsData::~PositionsData()\n{\n    TBDEBUG(__func__);\n    m_stream.Close();\n}\n\nvoid PositionsData::Stop()\n{\n    TBDEBUG(__func__);\n    m_stream.Close();\n}\n\nvoid PositionsData::HandleStreamOpen(const StreamIdentifier& stream)\n{\n    m_appStatus = \"Waiting for positions data\";\n}\n\nvoid PositionsData::HandleStreamStale(const StreamIdentifier& stream)\n<fim-suffix><fim-middle>{\n    m_appStatus = \"STALE STREAM for positions data\";\n}"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\"\n#include \"StochasticVolatilityInspired.h\"\n#include \"ClampedCubicSpline.h\"\n#include \"WingVolatilityModel.h\"\n#include \"ConstantVolatility.h\"\n#include \"MyCustomVolatilityModel.h\"\n\nusing namespace tbricks;\nusing namespace volatility;\n\nIVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType)\n{\n#define VOLATILITY_MODEL_WRAP(name, type) \\\n    case VolatilityModel##name: \\\n        return new type;\n\n    switch(volatilityModelType)\n    {\n#include \"VolatilityModelList.h\"\n        default:\n            return nullptr;\n#undef VOLATILITY_MODEL_WRAP\n    }\n}\n\nSharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType)\n{\n    return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType));\n}\n\nstd::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType)\n{\n    std::vector<InstrumentParameterDefinition> defs;\n\n#define VOLATILITY_MODEL_WRAP(name, type) \\\n    case VolatilityModel##name: \\\n        { \\\n            volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\\n            return defs; \\\n        }\n\n    switch(volatilityModelType)\n    {\n#include \"VolatilityModelList.h\"\n    default:\n        return defs;\n#undef VOLATILITY_MODEL_WRAP\n    }\n}\n\nstd::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType)\n{\n    std::vector<InstrumentParameterDefinition> defs;\n<fim-suffix><fim-middle>#define VOLATILITY_MODEL_WRAP(name, type) \\\n    case VolatilityModel##name: \\\n        { \\\n            volatility::GetVolatilitySurfaceParametersDefinitions<VolatilityModel##name>(defs); \\"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel<fim-suffix>case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>(); case VolatilityModelSVI:<fim-middle>volModelType) { switch(volModelType) {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update &<fim-suffix>protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice &<fim-middle>update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); }"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)<fim-suffix>return ostm; ostm.write(val.c_str(), val.size()); return<fim-middle>{ if (val.size() <= 0)"}
{"content":"<fim-prefix>#include \"DeribitClient.h\" #include \"DeribitProtocol.h\" #include <strategy\/Logger.h> #include <algorithm> using namespace tbricks; bool DeribitClient::Session::IsExpired() const { return DateTime::Now() > expires_datetime; } void DeribitClient::Session::SetExpires(int seconds) { expires = seconds; expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt()); } void DeribitClient::Session::Reset() { connected = false; logged_in = false; token.Clear(); refresh.Clear(); expires.Clear(); expires_datetime.Clear(); } std::ostream & DeribitClient::Session::Print(std::ostream & strm) const { strm << \"<Session> {\\n\"; strm << \" connected = \" << std::boolalpha << connected << \"\\n\"; strm << \" logged_in = \" << std::boolalpha << logged_in << \"\\n\"; strm << \" heartbeat = \" << hb << \"\\n\"; strm << \" userId = \" << userId << \"\\n\"; strm << \" secret = \" << secret << \"\\n\"; strm << \" host_port_path = \" << host_port_path << \"\\n\"; strm << \" token = \" << token << \"\\n\"; strm << \" refresh = \" << refresh << \"\\n\"; strm << \" expires = \" << expires << \"\\n\"; strm << \" expires_datetime = \" << expires_datetime << \"\\n\"; strm << \"}\"; return strm; } std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t) { strm << \"<SingleTransaction> {\\n\"; strm << \" id : \" << t.id << \"\\n\"; strm << \" method : \" <<<fim-suffix>if (t.call) { strm << \" call : \" << t.call->ToString() << \"\\n\"; } if (t.reply) { strm << \" reply : \" << t.reply->ToString() << \"\\n\"; } if (not t.reqChannels.empty()) { strm << \" reqChannels : \" << t.reqChannels << \"\\n\"; } strm << \"}\"; return strm; } DeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type) : m_handler(handler) , m_timer(*this, \"deribit_refresh\") { TBDEBUG(__func__ << \" : \" << endpoint); std::string url(endpoint.GetCString()); auto found = url.find(\":\/\/\"); if (found != std::string::npos) { url = url.substr(found + 3); } m_session.host_port_path = url; std::vector<String> slices; m_session.host_port_path.Split(':', slices); TBDUMP(slices); switch (type) { case DeribitHost::NONE: m_conf.header.insert({\"Host\", slices[0].GetCString()}); break; default: m_conf.header.insert({\"Host\", Resolve(type)}); break; } } DeribitClient::~DeribitClient() { TBDEBUG(__func__); Disconnect(); } void DeribitClient::Connect(const String & userId, const String & secret) { TBDEBUG(__func__<fim-middle>Resolve(t.method) << \"\\n\";"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear(); m_wasStreamStale = false; TBDEBUG(__func__); if (m_positionStream.IsOpen()) { m_positionStream.Close(); } m_positionStream.Open( Stream::SNAPSHOT, portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, AnyPositionFilter()); } void PositionRetriever::Stop() { m_positionStream.Close(); m_positions.clear(); }<fim-suffix><fim-middle>void PositionRetriever::HandleStreamOpen(const StreamIdentifier& stream_id)"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\" class PositionsData; namespace execution { class OrderExecutor; } namespace misc { class AsyncProcessor; } class GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler { public: GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ Strategy methods void HandleDeleteRequest() override; void HandleRunRequest() override; void HandlePauseRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override; void HandleValidateRequest(tbricks::ValidationContext &context) override;<fim-suffix>\/\/ OrderHandler::IHandler void PanicStop(const tbricks::String& msg)<fim-middle>void HandleScheduledEvent(tbricks::UserData&& data) override;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream)<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument); private: std::map<tbricks::StreamIdentifier, tbricks::InstrumentIdentifier> m_streams; std::map<tbricks::InstrumentIdentifier, DeribitModel><fim-middle>override; \/\/ DistributedValues Stream IHandler     void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override;"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    if (not m_client)\n    {\n        m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_PROD);\n    }\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n<fim-suffix><fim-middle>        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nusing InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>;\nusing UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>;\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n<fim-suffix><fim-middle>    explicit InstrumentManager(IHandler& handler);\n    ~InstrumentManager();\n    void Start();\n    void Stop();"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \": \" << context);"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) {<fim-suffix>} #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ {<fim-middle>return true; } return false;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include \"InstrumentManager.h\"\n#include \"TimerController.h\"\n\nclass InstrumentEnricherPlugin : public tbricks::Strategy\n                               , public InstrumentManager::IHandler\n                               , public TimerController::IHandler\n\n<fim-suffix><fim-middle>{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include \"PositionReversalsPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; PositionReversalsPlugin::PositionReversalsPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_manager(*this) , m_portfolio(position_reversals::strategy_parameters::Portfolio()) , m_startTime(position_reversals::strategy_parameters::PositionReversalStartTime()) , m_priceSource(position_reversals::strategy_parameters::PositionReversalPriceSource()) , m_status(position_reversals::strategy_parameters::StatusInformationText()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); if (GetTransactionOperation().IsRun()) { DoRun(); } } bool PositionReversalsPlugin::CanRun(tbricks::String& error) { TBDEBUG(__func__); if (m_portfolio.GetPortfolioIdentifier().Empty()) { error = \"No portfolio selected\"; return false; } if (m_startTime.GetTime().Empty()) { error = \"No start time selected\"; return false; } if (m_priceSource.GetInteger().Empty()) { error = \"No price source selected\"; return false; } return true; } void PositionReversalsPlugin::DoRun() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); String error; if (CanRun(error)) { m_manager.Start(m_portfolio.GetPortfolioIdentifier(), m_priceSource.GetInteger(), m_startTime.GetTime()); SetState(StrategyState::RUNNING); } else { m_status = error; SetTransactionFail(error); } } void PositionReversalsPlugin::DoPause() { m_manager.Stop(); SetState(StrategyState::PAUSED); } void PositionReversalsPlugin::HandleRunRequest(void) { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); } else { DoRun(); } } void PositionReversalsPlugin::HandlePauseRequest(void) { TBDEBUG(__func__); if (GetState().IsPaused()) { TBDEBUG(\"Already paused\"); } else { DoPause(); } } void PositionReversalsPlugin::HandleDeleteRequest(void) { TBDEBUG(__func__); DoPause(); SetState(StrategyState::DELETED); } void PositionReversalsPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" modifier: \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void PositionReversalsPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" constext:\" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void PositionReversalsPlugin::HandleStrategyViewCreate( visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \", update: \" << update); viewModel.MergeUpdate(update); viewModel.ApplyModifications(); } void PositionReversalsPlugin::HandleStrategyViewUpdate( visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \", update: \" << update); m_status = \"\"; viewModel.MergeUpdate(update); viewModel.ApplyModifications(); } void PositionReversalsPlugin::HandleStrategyViewDelete(visualization::models::AppViewModel& viewModel) { TBDEBUG(__func__); } void PositionReversalsPlugin::HandleGridViewUpdate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \" update = \" << update); viewModel.MergeUpdate(update); viewModel.ApplyModifications(); viewModel.RejectUnconfirmedModifications(); } void PositionReversalsPlugin::HandleGridViewDelete(visualization::models::GridViewModel& viewModel) { TBDEBUG(__func__); } void PositionReversalsPlugin::HandleGridViewCreate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate&<fim-suffix>{ TBDEBUG(__func__ << \" update = \" << update); HandleGridViewUpdate(viewModel, update); } void PositionReversalsPlugin::HandleError(const tbricks::String& error) { m_status = error; } void PositionReversalsPlugin::HandlePositionsReversed()<fim-middle>update)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status); ~PositionsData(); void Stop(); public: using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>; const Data& GetData() const {<fim-suffix><fim-middle>return m_data; }"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType) { return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType)); } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs; #undef VOLATILITY_MODEL_WRAP } } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilitySurfaceParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include<fim-suffix><fim-middle>\"VolatilityModelList.h\" default:"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI)<fim-suffix><fim-middle>VOLATILITY(wing, Wing) VOLATILITY(custom, Custom)"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/type\/Price.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/Boolean.h> #include <strategy\/calculated_property\/CalculatedPropertyFilter.h> #include <strategy\/TreeNodeParameters.h> #include <strategy\/parameter\/StrategyParameters.h> #include <strategy\/parameter\/StrategyInstanceParameters.h> CLANG_RESTORE_WARNINGS #include <set> using namespace tbricks; enum class PreferencesStorageKind { Common = 0, Wing, CCS, SVI }; std::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind); \/** * Struct representing the various settings common to all VMs; it is subclassed by structs * containing additional parameters relevant for particular VMs *\/ class PreferencesStorage: public Printable { public: PreferencesStorage(); protected: PreferencesStorage(const PreferencesStorage & storage) = default; PreferencesStorage & operator=(const PreferencesStorage & storage) = default; public: virtual ~PreferencesStorage(); virtual PreferencesStorageKind GetKind() const = 0; virtual void Clear(); virtual void Copy(const PreferencesStorage & preferencesStorage); virtual bool FillFromTreeNodeParameters(const TreeNodeParameters & parameters); virtual bool FillFromStrategyParameters(const StrategyParameters & parameters); virtual bool FillFromStrategyInstanceParameters(const StrategyInstanceParameters & parameters); virtual bool GetParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetParameters(TreeNodeParameters & parameters) const; virtual void GetParameters(StrategyParameters & parameters) const; virtual void GetParameters(StrategyInstanceParameters & parameters) const; virtual bool GetNonDefaultParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetNonDefaultParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetNonDefaultParameters(TreeNodeParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyInstanceParameters & parameters) const; \/\/ Update local values with non-empty values from the passed in preferences storage; \/\/ return true if something got changed as a result, false otherwise virtual bool Merge(const PreferencesStorage & preferencesStorage); virtual std::ostream & Print(std::ostream & strm) const override; \/\/ List of preferences that shouldn't be copied to other scope levels virtual const std::set<TreeNodeParameterDefinition> & GetLevelAnchoredParameters() const { return m_scopeLevelAnchoredPreferences; } \/\/ In case it is necessary to include all the exotic instruments, \/\/ we can't persist empty filter since it would be aggregated. \/\/ Hence, this dummy non-empty filter needs to be used for clear operations. static const CalculatedPropertyFilter dummyFilter; \/\/ Autofit settings ValueWithDefault<Boolean> autoFit; ValueWithDefault<Boolean> autoApplyAutoFit; ValueWithDefault<Boolean> globalAvoidExtraFits; ValueWithDefault<Boolean> globalUnderlyingTradingStatusTracking; ValueWithDefault<Boolean> optionTradingStatusTracking; ValueWithDefault<Integer> loggingMode; ValueWithDefault<Integer> maxAllowedFitRejects; ValueWithDefault<Boolean> maturityExcludedFromGlobalActions; ValueWithDefault<Boolean> sendQuotingRecommendations; ValueWithDefault<Table> quotingRecommendations; \/\/ General settings ValueWithDefault<Boolean> parallelShift; ValueWithDefault<Enumeration> curveShiftUnits; ValueWithDefault<Integer> ATMVolatilityShiftMode; ValueWithDefault<Boolean> includeExoticOptions; ValueWithDefault<Boolean> autoFetchATMVolatilityPath; ValueWithDefault<Boolean> globalAutoFetchATMVolatilityPath; ValueWithDefault<Integer> instrumentGroupType; ValueWithDefault<Identifier> suggestContext; ValueWithDefault<Integer> trackingAreaType; ValueWithDefault<Boolean> volatilityCurveSafetyCheckEnabled; ValueWithDefault<Double> safetyParameterChange; ValueWithDefault<Double> safetyModelChange; ValueWithDefault<Boolean> checkForStaticArbitrage; ValueWithDefault<Double> calendarSpreadArbitrageTolerance; ValueWithDefault<Double> butterflyArbitrageTolerance; ValueWithDefault<Boolean> enableCurveQualityMetrics; \/\/ Fit settings ValueWithDefault<Integer> fitWeighting; ValueWithDefault<Boolean> autocorrectFitWeights; ValueWithDefault<Boolean> fitOnlyATMVol; ValueWithDefault<Boolean> addVirtualBids; ValueWithDefault<Double> virtualBidRatio; ValueWithDefault<Boolean> robustFittingOnWings; ValueWithDefault<Double> robustFittingOnWingsStrength; ValueWithDefault<Boolean> autoResetSwimRefPriceToATM; ValueWithDefault<Integer> crossingProcessing; ValueWithDefault<Boolean> anomalyDetection; ValueWithDefault<Double> anomalyDetectionSensitivity; \/\/ Implied vol filtering ValueWithDefault<Boolean> enableAmerican; ValueWithDefault<Boolean> enableATM; ValueWithDefault<Boolean> enableDeepITM; ValueWithDefault<Boolean> enableDeepOTM; ValueWithDefault<Boolean> enableEuropean; ValueWithDefault<Boolean> enableITM; ValueWithDefault<Boolean> enableCashDelivery; ValueWithDefault<Boolean> enableCrossings; ValueWithDefault<Boolean> enableLowBids; ValueWithDefault<Boolean> enablePhysicalDelivery; ValueWithDefault<Boolean> enableSmallDelta; ValueWithDefault<Boolean> enableWideSpreads; ValueWithDefault<Boolean> enableNoSpreads; ValueWithDefault<Boolean> enableOTM; ValueWithDefault<Boolean> enableLowVolumes; ValueWithDefault<Price> minimumBidPrice; ValueWithDefault<Volume> minimumVolume; ValueWithDefault<Table> manuallyToggledPoints; ValueWithDefault<Table> impliedVolatilitySources; ValueWithDefault<CalculatedPropertyFilter> instrumentFilter; ValueWithDefault<Integer> tradingPhaseProcessing; \/\/ Visualization settings ValueWithDefault<Boolean> showExcludedPoints; ValueWithDefault<Boolean> autocorrectVolatilityChartZooming; ValueWithDefault<Double> deltaValueForVerticalLines; ValueWithDefault<Boolean> showVerticalLinesAtGivenDelta; ValueWithDefault<Double> volatilityCurveChartAutoRangePadding; ValueWithDefault<Identifier> portfolio; ValueWithDefault<Boolean> preserveZooming; ValueWithDefault<Double> distanceBetweenCurvePoints; ValueWithDefault<Integer> autoRangeMode; ValueWithDefault<Boolean> showReferenceVols; ValueWithDefault<Boolean> showReferenceCurve; ValueWithDefault<Boolean> showBidAskRange; ValueWithDefault<Integer> putCallColors; ValueWithDefault<Integer> colorScheme; protected: std::set<TreeNodeParameterDefinition> m_scopeLevelAnchoredPreferences; }; class CommonPreferencesStorage: public PreferencesStorage { public: CommonPreferencesStorage()<fim-suffix><fim-middle>= default; CommonPreferencesStorage(const CommonPreferencesStorage & storage) = default;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer);<fim-suffix>return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define<fim-middle>m_doc->msg.Accept(writer);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n    Binary_ostream() { }\n    void close()\n    {\n        m_data.Clear();\n    }\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n    template <typename T>\n    void write(const T & t)\n    {\n        tbricks::Binary vec;\n        vec.Set(reinterpret_cast<const void *>(&t), sizeof(T));\n        write(vec);\n    }\n    void write(const std::string & s)\n    {\n        write(s.c_str(), s.size());\n    }\n    void write(const char * p, size_t size)\n    {\n        m_data.Append(p, size);\n    }\n\nprivate:\n    tbricks::Binary m_data;\n};\n\ntemplate <typename T>\nBinary_istream & operator>>(Binary_istream & istm, T & val)\n{\n    istm.read(val);\n\n    return istm;\n}\n\ntemplate <typename T>\nBinary_ostream & operator<<(Binary_ostream & ostm, const T & val)\n{\n    ostm.write(val);\n<fim-suffix><fim-middle>    return ostm;\n}"}
{"content":"<fim-prefix>#pragma once #include <strategy\/EventProcessor.h> #include <future> namespace misc { class AsyncProcessor { private: const tbricks::EventProcessor& m_proc; tbricks::StrategyIdentifier m_id; std::string m_result; public: AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc), m_id(appId) {}; void DoAsync() { std::thread([this]{ std::this_thread::sleep_for(std::chrono::seconds(3)); m_result = \"ASYNC SUCCESS\"; tbricks::UserData payload; payload.Set(&m_result, 0); \/\/ we can do shallow copy because the string is a member variable m_proc.ScheduleStrategyEvent(m_id, payload); }).detach(); } bool HasResult() const { return not m_result.empty(); } const std::string& GetResult() const { return m_result; }<fim-suffix><fim-middle>}; } \/\/ namespace misc"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n<fim-suffix><fim-middle>    {\n        return m_data;\n    }"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(),<fim-suffix>m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i<fim-middle>instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n<fim-suffix><fim-middle>        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer<fim-suffix><fim-middle>started, repeats \" + m_frequency.ToString();"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream & data); void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode,<fim-suffix>private: IWebsocketHandler & m_handler; tbricks::TCPStream m_tcp; std::random_device m_rd; std::shared_ptr<std::string> nonce_base64; Config m_config; std::string host; unsigned short port; std::string path; bool m_handshake_done = false;<fim-middle>size_t length);"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); \/\/ Perform an operation SetState(StrategyState::RUNNING); } }<fim-suffix>SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__<fim-middle>void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy,<fim-suffix>void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override;<fim-middle>public tbricks::IDistributionApp void HandleRunRequest() override;"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString();<fim-suffix><fim-middle>void Parse(const tbricks::String& str);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler { public: class IHandler { public: virtual<fim-suffix>virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual<fim-middle>~IHandler() = default;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n<fim-suffix><fim-middle>{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\nprotected:\n<fim-suffix><fim-middle>    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h><fim-suffix><fim-middle>#include <third_party\/include\/rapidjson\/pointer.h> namespace deribit {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy,<fim-suffix>void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void<fim-middle>public tbricks::IDistributionApp void HandleRunRequest() override;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); };<fim-suffix>{ public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public: subscriptions(const std::string_view id, DeribitMethod method); void AddChannel(const std::string & channel); }; class subscriptions_reply : public JsonReply {<fim-middle>class public_test : public JsonCall"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n<fim-suffix><fim-middle>    m_buffer << data;"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI)<fim-suffix><fim-middle>VOLATILITY(wing, Wing)"}
{"content":"<fim-prefix>#pragma once<fim-suffix>#include <map> class PositionReverser : public tbricks::IRequestReplyHandler { public: PositionReverser() = default; ~PositionReverser() = default; void ReversePosition(<fim-middle>#include \"shared\/API.h\""}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n<fim-suffix><fim-middle>            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n<fim-suffix><fim-middle>using namespace tbricks;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const<fim-suffix>const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const<fim-middle>double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n<fim-suffix><fim-middle>{\n    msg.Clear();\n    Parse(json);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update &<fim-suffix>const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone;<fim-middle>update);"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel<fim-suffix>} std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs; #undef VOLATILITY_MODEL_WRAP } } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilitySurfaceParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ }<fim-middle>volatilityModelType) { return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType));"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n<fim-suffix><fim-middle>        unsigned short default_port = 80;\n    };"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return<fim-suffix>return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default:<fim-middle>\"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat:"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <third_party\/include\/rapidjson\/document.h>\n#include <deribit\/DeribitInstrument.h>\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler,\n                          public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0;\n        virtual void HandleInstrumentManagerReady() = 0;\n        virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0;\n        virtual void HandleInstrumentError(const tbricks::String & error) = 0;\n    };\n\n    explicit InstrumentManager(IHandler & handler);\n    ~InstrumentManager() override;\n\n    void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument);\n\n    void Start();\n    void SyncInstruments();\n    void Clear();\n    bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); }\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamStale(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;\n\n    void HandleInstrument(const tbricks::StreamIdentifier & stream, \n                         const tbricks::Instrument & instrument) override;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier & stream, \n                                  const tbricks::InstrumentIdentifier & id) override;\n\n    void HandleRequestReply(const tbricks::Identifier & request_id,\n                            tbricks::Status status,\n                            const tbricks::String & status_text) override;\n\nprivate:\n    void OpenInstrumentStream();\n    static tbricks::String GetInstrumentKey(const tbricks::Instrument & instrument);\n    static tbricks::String GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument);\n    void CreateInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument);\n    void ModifyInstrument(const tbricks::Instrument& instrument, const std::shared_ptr<DeribitInstrument> & deribitInstrument);\n    \n    std::map<tbricks::String, tbricks::Instrument> m_tbricksInstruments;\n    std::map<tbricks::String, std::shared_ptr<DeribitInstrument>> m_deribitInstruments;\n<fim-suffix><fim-middle>    tbricks::InstrumentStream m_instrumentStream;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n<fim-suffix><fim-middle>void public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n<fim-suffix><fim-middle>                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewUpdate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    auto it = update.begin();\n    while (it != update.end())\n    {\n        TBDUMP(it.GetCell().GetCalculatedProperty() << \" \" << it.GetCell().GetCellValue());\n\n        auto & calcProp = it.GetCell().GetCalculatedProperty().GetDefinition();\n        auto & cellValue = it.GetCell().GetCellValue();\n\n        if (calcProp == instrument_enricher::calculated_properties::strategy::ImportFrequency())\n        {\n            m_importFrequency = cellValue.GetDuration();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::InstrumentGroup())\n        {\n            m_instrumentGroup = cellValue.GetInstrumentGroupIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::UnderlyingInstrument())\n        {\n            m_underlyingInstrument = cellValue.GetInstrumentIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::StartTime())\n        {\n            m_startTime = cellValue.GetDateTime();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::MaturityDate())\n        {\n            m_maturityDate = cellValue.GetDateTime();\n        }\n\n        ++it;\n    }\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       m_importOnce = true;\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\" #include \"shared\/order_minion\/OrderMinionCancelRequest.h\" #include \"shared\/order_minion\/tbricks_definitions.h\" #include \"shared\/sdk_definitions.h\" using namespace tbricks; namespace execution { TbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters) : OrderExecutor(handler) , m_controller( reason, app)<fim-suffix><fim-middle>{ TBDEBUG(__func__); } TbOrderMinion::~TbOrderMinion()"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const<fim-suffix>void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem<fim-middle>tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; };<fim-suffix><fim-middle>class Binary_istream"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n<fim-suffix><fim-middle>void TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n\nclass InstrumentEnricherPlugin : public tbricks::Strategy\n{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n\nprotected:\n    bool CheckRunningRequirement();\n\nprivate:\n<fim-suffix><fim-middle>    tbricks::InstrumentGroupParameter                   m_instrumentGroup;\n    tbricks::DateTimeParameter                          m_maturityDate;\n    tbricks::StringParameter                            m_plugInStatusDescription;"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\" #include \"ConstantVolatility.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include<fim-suffix>#endif \/\/<fim-middle>\"WingVolatilityModel.h\""}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream &<fim-suffix>{ int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; }<fim-middle>operator<<(Binary_ostream & ostm, const char * val)"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired) VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel) VOLATILITY_MODEL_WRAP(None,ConstantVolatility)"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n<fim-suffix><fim-middle>    {\n    }"}
{"content":"<fim-prefix>#ifndef TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H #define TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H \/** * This file is intended to introduce definitions of the customized metadata * items like instrument parameters or calculated values that are not supported * in the original version of the Pricing app. * * The following inclusion statement assumes tbricks_definitions.h was generated * with the commands: * * $ mkdir -p $TB_APPS\/production\/calculation\/custom_pricing * $ cd $TB_APPS\/production\/calculation\/custom_pricing * $ tbplugin export -s plugin -p \"Custom pricing\" -n pricing $TBRICKS_SYSTEM *\/ \/\/ #include \"..\/..\/custom_pricing\/tbricks_definitions.h\" #endif \/\/<fim-suffix><fim-middle>TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H"}
{"content":"<fim-prefix>#pragma once #include \"IExecutionHandler.h\" #include \"shared\/API.h\" namespace execution { class OrderExecutor { public: virtual ~OrderExecutor() = default; OrderExecutor(IExecutionHandler& handler) : m_handler(handler) { m_stats.bought = 0.0; m_stats.sold = 0.0; m_stats.valueBought = 0.0; m_stats.valueSold = 0.0; } virtual void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) = 0; virtual<fim-suffix><fim-middle>void DeleteOrders() = 0;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler, public InstrumentManager::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; void HandleInstrumentDownload(const rapidjson::Value & instruments) override; \/\/ InstrumentManager::IHandler const tbricks::VenueIdentifier & GetVenueIdentifier() const override; void HandleInstrumentManagerReady() override; void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) override; void HandleInstrumentError(const tbricks::String & error) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier><fim-suffix>\/\/ app parameters tbricks::StringParameter m_clientID; tbricks::StringParameter m_clientSecret;<fim-middle>ExtractVIID(const tbricks::Instrument & instrument);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator &<fim-suffix>void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem;<fim-middle>it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate) HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight) HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight) HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price, Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed) VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double, NextDividend) VALUE(next_dividend_date, Date, NextDividendDate) VALUE(underlying_settlement_date, Date, UnderlyingSettlementDateUsed) VALUE(final_settlement_date, Date, FinalSettlementDateUsed) VALUE(next_call_put_date, DateTime, NextCall_DIV_PutDate) VALUE(days_to_next_dividend, Integer, DaysToNextDividend) VALUE(trading_days_to_next_dividend, Integer,<fim-suffix><fim-middle>TradingDaysToNextDividend) VALUE(days_to_maturity, Integer, DaysToMaturity)"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using<fim-suffix><fim-middle>namespace rapidjson;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n<fim-suffix><fim-middle>    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler, visualization::Grid& instrumentsGrid)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n    , m_tasksDone(false)\n    , m_instrumentsGrid(instrumentsGrid)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n    m_tasksDone = false;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::OpenCIVStream()\n{\n    CalculatedInstrumentValues::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrumentVenueIdentification(InstrumentVenueIdentification(instId));\n    }\n    options.AddValue(calculated_values::UnderlyingPrice());\n\n    auto throttle = MaximumUpdateTimeThrottle(Duration::Seconds(5));\n    options.SetThrottle(throttle);\n    m_calculatedValuesStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened calculated instrument values stream : \" << m_calculatedValuesStream.GetIdentifier() << \" with options : \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n        OpenCIVStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        m_instrumentCache[instrument.GetIdentifier()].instrument = instrument;\n<fim-suffix><fim-middle>        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()].maturityDate = tbMaturityDate;\n    }"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType)<fim-suffix>case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>(); case VolatilityModelSVI: return std::make_unique<SVIPreferencesStorage>(); case custom::pricing::extended_enums::VolatilityModelMyCustom: return std::make_unique<MyCustomPreferencesStorage>(); default: return std::make_unique<CommonPreferencesStorage>(); }<fim-middle>{ switch(volModelType) {"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/type\/Price.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/Boolean.h> #include <strategy\/calculated_property\/CalculatedPropertyFilter.h> #include <strategy\/TreeNodeParameters.h> #include <strategy\/parameter\/StrategyParameters.h> #include <strategy\/parameter\/StrategyInstanceParameters.h> CLANG_RESTORE_WARNINGS #include <set> using namespace tbricks; enum class PreferencesStorageKind { Common = 0, Wing, CCS, SVI, MyCustom = 100000 }; std::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind); \/** * Struct representing the various settings common to all VMs; it is subclassed by structs * containing additional parameters relevant for particular VMs *\/ class PreferencesStorage: public Printable { public: PreferencesStorage(); protected: PreferencesStorage(const PreferencesStorage & storage) = default; PreferencesStorage & operator=(const PreferencesStorage & storage) = default; public: virtual ~PreferencesStorage(); virtual PreferencesStorageKind GetKind() const = 0; virtual void Clear(); virtual void Copy(const PreferencesStorage & preferencesStorage); virtual bool FillFromTreeNodeParameters(const TreeNodeParameters & parameters); virtual bool FillFromStrategyParameters(const StrategyParameters & parameters); virtual bool FillFromStrategyInstanceParameters(const StrategyInstanceParameters & parameters); virtual bool GetParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetParameters(TreeNodeParameters & parameters) const; virtual void GetParameters(StrategyParameters & parameters) const; virtual void GetParameters(StrategyInstanceParameters & parameters) const; virtual bool GetNonDefaultParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetNonDefaultParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetNonDefaultParameters(TreeNodeParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyInstanceParameters & parameters) const; \/\/ Update local values with non-empty values from the passed in preferences storage; \/\/ return true if something got changed as a result, false otherwise virtual bool Merge(const PreferencesStorage & preferencesStorage); virtual std::ostream & Print(std::ostream & strm) const override; \/\/ List of preferences that shouldn't be copied to other scope levels virtual const std::set<TreeNodeParameterDefinition> & GetLevelAnchoredParameters() const { return m_scopeLevelAnchoredPreferences; } \/\/ In case it is necessary to include all the exotic instruments, \/\/ we can't persist empty filter since it would be aggregated. \/\/ Hence, this dummy non-empty filter needs to be used for clear operations. static const CalculatedPropertyFilter dummyFilter; \/\/ Autofit settings ValueWithDefault<Boolean> autoFit; ValueWithDefault<Boolean> autoApplyAutoFit; ValueWithDefault<Boolean> globalAvoidExtraFits; ValueWithDefault<Boolean> globalUnderlyingTradingStatusTracking; ValueWithDefault<Boolean> optionTradingStatusTracking; ValueWithDefault<Integer> loggingMode; ValueWithDefault<Integer> maxAllowedFitRejects; ValueWithDefault<Boolean> maturityExcludedFromGlobalActions; ValueWithDefault<Boolean> sendQuotingRecommendations; ValueWithDefault<Table> quotingRecommendations; \/\/ General settings ValueWithDefault<Boolean> parallelShift; ValueWithDefault<Enumeration> curveShiftUnits; ValueWithDefault<Integer> ATMVolatilityShiftMode; ValueWithDefault<Boolean> includeExoticOptions; ValueWithDefault<Boolean> autoFetchATMVolatilityPath; ValueWithDefault<Boolean> globalAutoFetchATMVolatilityPath; ValueWithDefault<Integer> instrumentGroupType; ValueWithDefault<Identifier> suggestContext; ValueWithDefault<Integer> trackingAreaType; ValueWithDefault<Boolean> volatilityCurveSafetyCheckEnabled; ValueWithDefault<Double> safetyParameterChange;<fim-suffix>ValueWithDefault<Boolean> checkForStaticArbitrage; ValueWithDefault<Double> calendarSpreadArbitrageTolerance; ValueWithDefault<Double> butterflyArbitrageTolerance; ValueWithDefault<Boolean> enableCurveQualityMetrics; \/\/ Fit settings ValueWithDefault<Integer> fitWeighting; ValueWithDefault<Boolean> autocorrectFitWeights; ValueWithDefault<Boolean> fitOnlyATMVol; ValueWithDefault<Boolean> addVirtualBids; ValueWithDefault<Double> virtualBidRatio; ValueWithDefault<Boolean> robustFittingOnWings; ValueWithDefault<Double> robustFittingOnWingsStrength; ValueWithDefault<Boolean> autoResetSwimRefPriceToATM; ValueWithDefault<Integer> crossingProcessing; ValueWithDefault<Boolean> anomalyDetection; ValueWithDefault<Double> anomalyDetectionSensitivity; \/\/ Implied vol filtering ValueWithDefault<Boolean> enableAmerican; ValueWithDefault<Boolean> enableATM; ValueWithDefault<Boolean> enableDeepITM; ValueWithDefault<Boolean> enableDeepOTM; ValueWithDefault<Boolean> enableEuropean; ValueWithDefault<Boolean> enableITM; ValueWithDefault<Boolean> enableCashDelivery; ValueWithDefault<Boolean> enableCrossings; ValueWithDefault<Boolean> enableLowBids; ValueWithDefault<Boolean> enablePhysicalDelivery; ValueWithDefault<Boolean> enableSmallDelta; ValueWithDefault<Boolean> enableWideSpreads; ValueWithDefault<Boolean> enableNoSpreads; ValueWithDefault<Boolean> enableOTM; ValueWithDefault<Boolean> enableLowVolumes; ValueWithDefault<Price> minimumBidPrice; ValueWithDefault<Volume> minimumVolume; ValueWithDefault<Table> manuallyToggledPoints; ValueWithDefault<Table> impliedVolatilitySources; ValueWithDefault<CalculatedPropertyFilter> instrumentFilter; ValueWithDefault<Integer> tradingPhaseProcessing; \/\/ Visualization settings ValueWithDefault<Boolean> showExcludedPoints; ValueWithDefault<Boolean> autocorrectVolatilityChartZooming; ValueWithDefault<Double> deltaValueForVerticalLines; ValueWithDefault<Boolean> showVerticalLinesAtGivenDelta; ValueWithDefault<Double> volatilityCurveChartAutoRangePadding; ValueWithDefault<Identifier> portfolio; ValueWithDefault<Boolean> preserveZooming; ValueWithDefault<Double> distanceBetweenCurvePoints; ValueWithDefault<Integer> autoRangeMode; ValueWithDefault<Boolean> showReferenceVols; ValueWithDefault<Boolean> showReferenceCurve; ValueWithDefault<Boolean> showBidAskRange; ValueWithDefault<Integer><fim-middle>ValueWithDefault<Double> safetyModelChange;"}
{"content":"<fim-prefix>#include \"shared\/API.h\"\n#include \"InstrumentPricing.h\"\n#include \"util\/Log.h\"\n#include \"PricingPlugin.h\"\n#include \"InstrumentFilterSubscriber.h\"\n#include \"Underlying.h\"\n#include \"payments\/DividendInstrument.h\"\n#include \"payments\/PaymentInstrument.h\"\n#include \"UnderlyingComponentsManager.h\"\n#include \"price_providers\/BarrierInstrument.h\"\n#include \"models\/ModelCalculatorFactory.h\"\n#include \"models\/TurboOptionModelCalculator.h\"\n#include \"models\/TurboOptionWithDividendsModelCalculator.h\"\n#include \"models\/MiniFutureModelCalculator.h\"\n#include \"models\/CallableBullBearContractModelCalculator.h\"\n#include \"models\/CBBCWithDividendsModelCalculator.h\"\n#include \"models\/CBBCBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/CBBCWithDividendsBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/BondModelCalculator.h\"\n#include \"models\/EquityReturnModelCalculator.h\"\n#include \"price_providers\/PriceProviderEmpty.h\"\n#include \"price_providers\/PriceProviderSingle.h\"\n#include \"price_providers\/PriceProviderQuote.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/interest_rate\/YieldCurveWrapper.h\"\n#include \"UserPreferencesSubscriber.h\"\n#include \"time\/TimeOptions.h\"\n#include \"time\/TimeValues.h\"\n#include \"time\/VolatilityTimeWeights.h\"\n#include \"time\/CalendarUtils.h\"\n#include <cmath>\n#include <algorithm>\n#include <type_traits>\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include \"shared\/combination\/ICombinationModel.h\"\n#include \"shared\/Macros.h\"\n#include <shared\/instrument_types\/InstrumentTypes.h>\n#include <shared\/metaprogramming\/Defer.hpp>\n\n#include \"util\/Tokens.h\"\n\n#include \"models\/EquityModelCalculator.h\"\n#include \"models\/ExternalModelCalculator.h\"\n#include \"models\/ExternalTaylorModelCalculator.h\"\n#include \"models\/ExternalModelDistributionCalculator.h\"\n\n#include \"models\/PricingCombinationModel.h\"\n#include \"models\/util\/MiscCalculations.h\"\n#include \"models\/util\/DividendsUtil.h\"\n\n#include \"shared\/datetime_helpers\/DateTimeHelpers.h\"\n#include \"shared\/smart_pointers\/IntrusiveWeakPointer.hpp\"\n\n#include <shared\/time\/TimeParser.h>\n#include <shared\/StateRestorer.hpp>\n<fim-suffix><fim-middle>#include \"tbricks_definitions.h\"\n#include \"shared\/pricing\/tbricks_constants.h\""}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT, PUBLIC_GetInstruments, }; static std::string Resolve(DeribitMethod e) { switch<fim-suffix>return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; case DeribitMethod::PUBLIC_GetInstruments: return \"public\/get_instruments\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT };<fim-middle>(e) { case DeribitMethod::PUBLIC_Auth:"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) {<fim-suffix>}<fim-middle>String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include \"shared\/app\/app.h\"\nCLANG_RESTORE_WARNINGS\n\n#include <limits>\n\nusing namespace tbricks;\n\nclass ValuesRequest;\n\nstruct ImpliedValue\n{\n    void Clear();\n\n    friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value)\n    { return value.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    Double implied_volatility;\n};\n\nstruct FairPriceValue\n{\n    FairPriceValue & operator += (const FairPriceValue & fair_price_value);\n    FairPriceValue & operator += (const Double & value);\n    FairPriceValue   operator *  (const Double & mult) const;\n    FairPriceValue & operator *= (const Double & mult);\n\n    void Clear();\n\n    bool SetError(const String & error);\n\n    friend std::ostream & operator << (std::ostream & strm, const FairPriceValue & price)\n    { return price.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    Double fair_price;\n};\n\nstruct Greeks\n{\n    Greeks & operator += (const Greeks & greeks);\n    Greeks   operator  * (const Double & mult) const;\n    Greeks & operator *= (const Double & mult);\n\n    void Clear();\n    void ClearNoncombinationValues();\n\n    void Set(const Greeks & greeks);\n\n    bool SetError(const String & error);\n<fim-suffix><fim-middle>    void SetErrorToCCSVolatilityModelGreeks(const String & error);\n    void SetErrorToWingVolatilityModelGreeks(const String & error);"}
{"content":"<fim-prefix>#include \"TbChildOrder.h\" using namespace tbricks; namespace execution { TbChildOrder::TbChildOrder(IExecutionHandler& handler, Strategy& app) : OrderExecutor(handler) , m_app(app) , m_stream(*this) { StrategyStream::Options opts; opts.SetFilter(StrategyByParentFilter(app.GetIdentifier())); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, opts, StrategyStream::ToStrategyEngine); TBDEBUG(__func__ << \" opened stream with options: \" << opts); } TbChildOrder::~TbChildOrder() { m_stream.Close(); DeleteOrders(); } void TbChildOrder::DeleteOrders() { TBDEBUG(__func__); for (const auto& [ivid,childId] : m_childMap) { if (m_childData[childId].GetState().IsDeleted()) { \/\/ already deleted continue; } Strategy::SendDeleteRequest(childId); TBDUMP(\"Sent deletion for \" << childId << \" [\" << ivid << \"]\"); } } void TbChildOrder::CreateOrder( const InstrumentVenueIdentification& ivid, const Volume& volume, const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio); StrategyOptions opts{plug_ins::Order()}; \/\/ very few app definitions in this namespace StrategyAttributes attrs; attrs.SetExtraData(m_app.GetExtraData()); opts.SetAttributes(attrs); StrategyParameters params; params.SetParameter(strategy_parameters::Portfolio(), portfolio); params.SetParameter(strategy_parameters::ActiveVolume(), volume.Abs()); params.SetParameter(strategy_parameters::Instrument(), ivid.GetInstrumentIdentifier()); params.SetParameter(strategy_parameters::Venue(), ivid.GetVenue()); params.SetParameter(strategy_parameters::MIC(), ivid.GetMIC()); if (volume < 0.0) { params.SetParameter(strategy_parameters::Side(), Side{Side::SELL}); } else { params.SetParameter(strategy_parameters::Side(), Side{Side::BUY}); } auto res = Strategy::SendCreateRequest(opts, params, *this); TBDEBUG(\"Sent creation request for child \" << res.GetStrategyIdentifier()); TBDUMP(opts); TBDUMP(params); m_childMap[ivid] = res.GetStrategyIdentifier(); m_requests[res.GetRequestIdentifier()] = res.GetStrategyIdentifier(); } void TbChildOrder::HandleStreamOpen(const StreamIdentifier& stream) { TBDEBUG(__func__ << \" : \" << stream); } void TbChildOrder::HandleStreamStale(const StreamIdentifier& stream) { TBWARNING(__func__ << \" : \" << stream); } void TbChildOrder::HandleStreamFailed(const StreamIdentifier& stream) { TBERROR(__func__ << \" : \" << stream); m_handler.PanicStop(\"Strategy stream failed\"); } void TbChildOrder::HandleSnapshotEnd(const StreamIdentifier& stream) { TBDEBUG(__func__ << \" : \" << stream); } void TbChildOrder::HandleStrategyUpdate(const StreamIdentifier & stream, const StrategyUpdate & update) { TBDEBUG(__func__ << \" : \" << update); auto id = update.GetIdentifier(); auto& child = m_childData[id]; if (child.Empty()) { \/\/ first update child.Merge(update); Strategy::SendRunRequest(id); TBNOTICE(\"Sent run request for child \" << id); return; } \/\/ check update content if (update.HasTransactionState()) { if (update.GetTransactionState().IsFail()) { m_handler.PanicStop(update.GetStatusText()); return; } } const auto& params = update.GetParameters(); if (params.HasParameter(strategy_parameters::FilledVolume())) { Side side; child.GetParameters().GetParameter(strategy_parameters::Side(), side); if (side.IsBuy()) { params.GetParameter(strategy_parameters::FilledVolume(), m_stats.bought); params.GetParameter(strategy_parameters::AveragePaidBought(), m_stats.valueBought); m_stats.valueBought *= m_stats.bought; } else {<fim-suffix>params.GetParameter(strategy_parameters::AveragePaidSold(), m_stats.valueSold); m_stats.valueSold *= m_stats.sold; } } child.Merge(update); if (m_requests.empty()) { Volume active; for (const auto& [i,c] : m_childData) { c.GetParameters().GetParameter(strategy_parameters::ActiveVolume(), active); if (active > 0.0) { TBDEBUG(\"Still trading\"); return; } active.Clear(); } \/\/ all executed m_handler.AllDone(m_stats); } } void TbChildOrder::HandleStrategyInvalidate(const StreamIdentifier & stream, const StrategyIdentifier & id) { \/\/ should never happen with this filter TBDEBUG(__func__ << \" : \" << id); } void<fim-middle>params.GetParameter(strategy_parameters::FilledVolume(), m_stats.sold);"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String<fim-suffix>bool connected = false; bool logged_in<fim-middle>secret; tbricks::String host_port_path;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) {<fim-suffix>template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream &<fim-middle>out = m_data; }"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n    ~DeribitContributor() noexcept override = default;\n<fim-suffix><fim-middle>protected:\n    void HandleRunRequest() override;\n    void HandlePauseRequest() override;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream & data); void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length); private: IWebsocketHandler & m_handler; tbricks::TCPStream m_tcp; std::random_device m_rd; std::shared_ptr<std::string> nonce_base64; Config m_config; std::string host; unsigned short port; std::string<fim-suffix><fim-middle>path; bool m_handshake_done = false;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_importOnce(false)\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       m_importOnce = true;\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_plugInStatusDescription.Clear();\n        m_timerController.Start();\n    }\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::Stop()\n{\n    TBDEBUG(__func__);\n<fim-suffix><fim-middle>    if (m_timerController.IsActive())\n    {\n        m_timerController.Stop();\n    }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override =<fim-suffix>void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool<fim-middle>default; protected: \/\/ MarketDataProvider     void HandleSubscribe(tbricks::MarketDataItem & item) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime&<fim-suffix><fim-middle>GetMaturityDate() = 0;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public:<fim-suffix><fim-middle>InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod e)<fim-suffix><fim-middle>{ switch (e) {"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindPreferencesStorageByScopeDefinition(const ScopeDefinition & scope) const\n{\n    switch (scope.type)\n    {\n    case enumerations::VolatilityManagerPersistentPreferencesScopeUser:\n        return (scope.id == m_provider.GetUserIdentifier().GetUuid()) ? m_pUserScopePreferencesStorage.get() : nullptr;\n    case enumerations::VolatilityManagerPersistentPreferencesScopeProduct:\n        return FindProductScopePreferencesStorage(scope.id);\n    case enumerations::VolatilityManagerPersistentPreferencesScopeMaturity:\n        return FindMaturityScopePreferencesStorage(scope.id);\n    default:\n        return nullptr;\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductGroupIdsWithExistingPersistentPreferences(SparseSet<InstrumentGroupIdentifier> & productGroupIds) const\n{\n    productGroupIds.clear();\n    productGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & pair: m_productScopePreferencesStorages) {\n        TB_UNUSED(productGroupIds.insert(pair.first));\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductAndMaturityGroupIdsWithExistingPersistentPreferences(SparseHash<InstrumentGroupIdentifier, SparseSet<InstrumentGroupIdentifier>> & productAndMaturityGroupIds) const\n{\n    productAndMaturityGroupIds.clear();\n    productAndMaturityGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & [productGroupId, _]: m_productScopePreferencesStorages) {\n        TB_UNUSED(productAndMaturityGroupIds[productGroupId]);\n    }\n\n    for(const auto & pair: m_maturityScopePreferencesStoragesByProductGroupId) {\n        const InstrumentGroupIdentifier & productGroupId = pair.first;\n        SparseSet<InstrumentGroupIdentifier> & maturityGroupIds = productAndMaturityGroupIds[productGroupId];\n        maturityGroupIds.insert(pair.second.first);\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetMaturityGroupIdsWithExistingPersistentPreferences(const InstrumentGroupIdentifier & productGroupId,\n                                                                                            SparseSet<InstrumentGroupIdentifier> & maturityGroupIds) const\n{\n    if (TB_UNLIKELY(productGroupId.Empty())) {\n        return;\n    }\n\n    const auto [maturitiesBeginIt, maturitiesEndIt] = m_maturityScopePreferencesStoragesByProductGroupId.equal_range(productGroupId);\n    for (auto it = maturitiesBeginIt; it != maturitiesEndIt; it++) {\n        maturityGroupIds.insert(it->second.first);\n    }\n}\n\nbool PersistentPreferencesManagerCore::GetAggregatePreferencesForProductScope(const InstrumentGroupIdentifier & productGroupId,\n                                                                              PreferencesStorage & preferencesStorage) const\n{\n    TBDEBUG(\"PersistentPreferencesManagerCore::GetAggregatePreferencesForProductScope: product group id = \" << productGroupId);\n\n    preferencesStorage.Clear();\n\n    if (m_provider.IsPreferencesPersistenceDisabled())\n    {\n        if (TB_UNLIKELY(!m_pNonPersistentUserScopePreferences)) {\n            NOTIFY_WARNING(\"persistence of preferences is disabled but non-persistent in-memory storage is not allocated\");\n            return false;\n        }\n\n        preferencesStorage.Copy(*m_pNonPersistentUserScopePreferences);\n        return true;\n    }\n\n    preferencesStorage.Copy(*m_pUserScopePreferencesStorage);\n\n    const Integer & currentPreferencesScope = m_provider.GetCurrentPreferencesScope();\n    if (!currentPreferencesScope.Empty() && (currentPreferencesScope.GetInt32() == enumerations::VolatilityManagerPersistentPreferencesScopeUser)) {\n        TBDEBUG(\"Ignoring the actual product scope preferences because preferences scope is set to user\");\n        return true;\n    }\n<fim-suffix><fim-middle>    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it != m_productScopePreferencesStorages.end())\n    {\n        const PreferencesStoragePtr & pProductPreferencesStorage = it->second;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument); \/\/ app parameters tbricks::StringParameter m_clientID; tbricks::StringParameter m_clientSecret; tbricks::StringParameter<fim-suffix>tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::DistributedValuesRequest> m_requestMap; tbricks::SparseHash<tbricks::Identifier, tbricks::DistributedValuesRequest> m_pendingRequests;<fim-middle>m_endpoint; std::unique_ptr<DeribitClient> m_client;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy methods void HandleDeleteRequest()<fim-suffix><fim-middle>final; void HandleRunRequest() final;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"shared\/API.h\"\n#include \"ReversalManager.h\"\n\nclass PositionReversalsPlugin  : public tbricks::VisualizationApp\n                            , public ReversalManager::IHandler\n{\npublic:\n    PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n    ~PositionReversalsPlugin() = default;\n\n    bool CanRun(tbricks::String& error);\n    void DoRun();\n    void DoPause();\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n\n    void HandleStrategyViewCreate(\n            tbricks::visualization::models::AppViewModel& viewModel,\n            const tbricks::visualization::ViewModelUpdate& update) final;\n    void HandleStrategyViewUpdate(\n            tbricks::visualization::models::AppViewModel& viewModel,\n            const tbricks::visualization::ViewModelUpdate& update) final;\n    void HandleStrategyViewDelete(\n            tbricks::visualization::models::AppViewModel& viewModel) final;\n    void HandleGridViewCreate(\n            tbricks::visualization::models::GridViewModel& viewModel,\n            const tbricks::visualization::ViewModelUpdate& update) final;\n    void HandleGridViewUpdate(\n            tbricks::visualization::models::GridViewModel& viewModel,\n            const tbricks::visualization::ViewModelUpdate& update) final;\n    void HandleGridViewDelete(tbricks::visualization::models::GridViewModel& viewModel) final;\n\n    void HandleError(const tbricks::String& error) final;\n    void HandlePositionsReversed() final;\n\nprivate:\n\n    ReversalManager m_manager;\n<fim-suffix><fim-middle>    tbricks::PortfolioIdentifierParameter   m_portfolio;\n    tbricks::TimeParameter                  m_startTime;\n    tbricks::IntegerParameter               m_priceSource;"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum<fim-suffix>NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE,<fim-middle>class DeribitMethod {"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear();<fim-suffix><fim-middle>m_wasStreamStale = false;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <optional> struct DeribitInstrument { tbricks::String instrument_name; tbricks::String instrument_type; tbricks::String kind; tbricks::String settlement_currency; tbricks::String settlement_period; tbricks::String quote_currency; tbricks::String counter_currency; tbricks::String option_type; \/\/ \"call\" or \"put\" for options std::optional<tbricks::Double> strike; \/\/ Only for options tbricks::DateTime expiration_timestamp; tbricks::Double tick_size; tbricks::Double contract_size; tbricks::Boolean is_active; \/\/ Constructor that safely extracts data from rapidjson Value static std::optional<DeribitInstrument> FromJson(const rapidjson::Value& value) { DeribitInstrument data; \/\/ Required fields - if any of these are missing, return nullopt if (!value.HasMember(\"instrument_name\") || !value[\"instrument_name\"].IsString() || !value.HasMember(\"kind\") || !value[\"kind\"].IsString() || !value.HasMember(\"settlement_currency\") || !value[\"settlement_currency\"].IsString() || !value.HasMember(\"counter_currency\") || !value[\"counter_currency\"].IsString() || !value.HasMember(\"is_active\") || !value[\"is_active\"].IsBool()) { return std::nullopt; } data.instrument_name = value[\"instrument_name\"].GetString(); data.kind = value[\"kind\"].GetString(); data.settlement_currency = value[\"settlement_currency\"].GetString(); data.counter_currency = value[\"counter_currency\"].GetString(); data.is_active = value[\"is_active\"].GetBool(); \/\/ Optional fields - use safe accessors data.instrument_type = value.HasMember(\"instrument_type\") && value[\"instrument_type\"].IsString() ? value[\"instrument_type\"].GetString() : \"\"; data.quote_currency = value.HasMember(\"quote_currency\") && value[\"quote_currency\"].IsString() ? value[\"quote_currency\"].GetString() : \"\"; data.option_type = value.HasMember(\"option_type\") && value[\"option_type\"].IsString() ? value[\"option_type\"].GetString() : \"\"; data.settlement_period = value.HasMember(\"settlement_period\") && value[\"settlement_period\"].IsString() ? value[\"settlement_period\"].GetString() : \"\"; if (value.HasMember(\"strike\") && value[\"strike\"].IsNumber()) { data.strike = value[\"strike\"].GetDouble(); } \/\/ Convert timestamp to DateTime if (value.HasMember(\"expiration_timestamp\") &&<fim-suffix>\/\/ Deribit timestamps are in milliseconds, Tbricks is microseconds data.expiration_timestamp = tbricks::DateTime::Create(value[\"expiration_timestamp\"].GetUint64() * 1000); } data.tick_size = value.HasMember(\"tick_size\") && value[\"tick_size\"].IsNumber()<fim-middle>value[\"expiration_timestamp\"].IsUint64()) {"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if<fim-suffix>throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename<fim-middle>((m_index + str.size()) > m_data.GetSize())"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (m_volatility_model->IsInterpolated()) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group\n    , const InstrumentGroupAggregateParameters::Update & update)\n{\n    return HandleVolatilityGroupParameters(&update);\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group)\n{\n    PDEBUGN(\"Handle volatility group parameters snapshot done\");\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerSnapshot(m_group);\n    }\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType()\n{\n    PDEBUGN(\"VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType\");\n    if (SwitchVolatilityModel()) {\n        for (auto subscriber : m_subscribers) {\n            subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n        }\n    }\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParameters(const InstrumentGroupAggregateParameters::Update * update)\n{\n    PDEBUGN(\"Handle volatility group parameters\");\n    if (update) {\n        PDUMPN(\"Update = \" << *update);\n    }\n\n    bool changed = false;\n\n    changed |= SwitchVolatilityModel();\n    if (!changed && m_volatility_model) {\n        if (update) {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*update, *m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        } else {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        }\n    }\n\n    if (changed) {\n        m_volatility_models.clear();\n    }\n\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n    }\n\n    return changed;\n}\n\nbool VolatilityCurveHandler::SwitchVolatilityModel()\n{\n    PDEBUGN(\"Switch volatility model\");\n    if (!m_parameters_provider) return false;\n\n    const Integer & type = m_parameters_provider->GetVolatilityModelType();\n    PDEBUGN(\"New volatility model type \" << type);\n\n    const VolatilitySurfaceContainer * container = m_parameters_provider->GetVolatilitySurfaceContainer();\n    const auto interpolated = container && volatility::InterpolatedVolatilityModel::IsApplicable(*container, m_plugin.GetVolatilitySurfaceDefinitions(type), m_maturity_date);\n\n    if (m_volatility_model\n        && type == m_volatility_model->GetVolatilityModelType()\n        && interpolated == m_volatility_model->IsInterpolated())\n    {\n        PDEBUGN(\"Volatility model is not changed\");\n        return false;\n    }\n\n    bool changed = static_cast<bool>(m_volatility_model);\n    m_volatility_model.reset();\n    m_volatility_models.clear();\n\n    if (type.Empty()) {\n        PDEBUGN(\"Volatility type is empty, cached shared volatility models are cleared\");\n        return changed;\n    }\n\n    if (interpolated)\n    {\n        m_volatility_model = std::make_shared<volatility::InterpolatedVolatilityModel>(type.GetInt32());\n    } else {\n<fim-suffix><fim-middle>        switch(type.GetInt()) {\n            case pricing::VolatilityModelNone:\n                m_volatility_model = std::make_shared<volatility::ConstantVolatility>();\n                break;"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \" + m_frequency.ToString(); } m_handler.HandleTimerControllerUpdate(status, \/*error =*\/ false); } void TimerController::Stop() { TBDEBUG(__func__);<fim-suffix><fim-middle>m_startTimerEvent.Stop();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; explicit InstrumentManager(IHandler& handler); ~InstrumentManager();<fim-suffix>protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& streamID) final; void HandleStreamStale(const tbricks::StreamIdentifier& streamID) final; void HandleStreamFailed(const tbricks::StreamIdentifier& streamID) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& streamID) final; \/\/ InstrumentStream::IHandler void<fim-middle>void Start(); void Stop();"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update &<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier &<fim-middle>update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream);"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n<fim-suffix><fim-middle>    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy,<fim-suffix>void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override;<fim-middle>public tbricks::IDistributionApp void HandleRunRequest() override;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n<fim-suffix><fim-middle>        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; void HandleInstrumentDownload(const rapidjson::Value & instruments) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument<fim-suffix>tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint; std::unique_ptr<DeribitClient> m_client; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::DistributedValuesRequest> m_requestMap; tbricks::SparseHash<tbricks::Identifier, tbricks::DistributedValuesRequest> m_pendingRequests; tbricks::Set<tbricks::Identifier> m_supported_values; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::VenueInstrumentIdentifier> m_viidMap;<fim-middle>& instrument); \/\/ app parameters     tbricks::StringParameter m_clientID;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n<fim-suffix><fim-middle>class MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::CalculatedInstrumentValues::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n\n    InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid);\n    ~InstrumentManager() noexcept override;\n    void Start();\n    void Stop();\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;\n\n    void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {};\n\n    void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID,\n                                             const tbricks::InstrumentIdentifier & instrumentID,\n                                             const tbricks::InstrumentAggregateParameters::Update & update) override;\n\n    void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId,\n                                                  const tbricks::CalculatedInstrumentValues::Update & update) final;\n    void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final;\n\nprivate:\n    void OpenInstrumentStream();\n    void OpenIAPStream();\n    void OpenCIVStream();\n    void EnrichInstruments();\n    void ModifyGroup();\n    void CheckResolutionStatus();\n    void CheckModificationStatus();\n    void PopulateGrid();\n\n    struct InstrumentDetails\n    {\n        tbricks::Instrument             instrument;\n        tbricks::DateTime               maturityDate;\n        tbricks::InstrumentIdentifier   underlyingInstrument;\n        tbricks::Price                  underlyingPrice;\n        tbricks::RowEntityIdentifier    gridRowIdentifier;\n    };\n<fim-suffix><fim-middle>    using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, InstrumentDetails>;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const<fim-suffix>class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply &&<fim-middle>std::string_view val); };"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n<fim-suffix><fim-middle>    void HandleTimerEvent(tbricks::Timer & timer) final;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem<fim-suffix><fim-middle>& item)"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)\n    {\n        strm << \"  subscription : \" << Resolve(subscription) << \"\\n\";\n    }\n    if (interval != DeribitInterval::NONE)\n<fim-suffix><fim-middle>    {\n        strm << \"  interval : \" << Resolve(interval) << \"\\n\";\n    }\n    strm << \"  channel : \" << channel << \"\\n\";"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/VisualizationApp.h>\n#include <strategy\/visualization\/ViewModelUpdate.h>\n#include <strategy\/visualization\/ICellValue.h>\n#include <strategy\/visualization\/Grid.h>\n#include \"InstrumentManager.h\"\n#include \"TimerController.h\"\n\nclass InstrumentEnricherPlugin : public tbricks::VisualizationApp\n                               , public InstrumentManager::IHandler\n                               , public TimerController::IHandler\n\n{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n<fim-suffix><fim-middle>    void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel,\n                                  const tbricks::visualization::ViewModelUpdate & update) final;\n    void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel,"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override; \/\/ MDTracker::IHandler void HandleBBOUpdate( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::BestPrice& before, const tbricks::BestPrice& change ) override; void HandleSnapshotEnd(const tbricks::InstrumentVenueIdentification& ivid) override; private: void EmergencyStop(); void DeleteSingleOrder(const tbricks::OrderIdentifier& id); void CreateSingleOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, const tbricks::Price& price, const tbricks::Side& side, const tbricks::PortfolioIdentifier& portfolio); tbricks::Price RoundPriceToTicks(const tbricks::Price& price, const tbricks::Side& side, const tbricks::InstrumentVenueIdentification& ivid); void UpdateStats(const tbricks::Order::Update& update, const tbricks::Order& current); private: tbricks::Hash<tbricks::OrderIdentifier, tbricks::Order> m_orderData; tbricks::Hash<tbricks::Identifier, tbricks::OrderIdentifier> m_requests; tbricks::Hash<tbricks::InstrumentVenueIdentification, tbricks::OrderIdentifier> m_activeOrders; private: struct OrderRequest { tbricks::InstrumentVenueIdentification ivid; tbricks::Volume volume; \/\/ negative for<fim-suffix>}; MDTracker m_md; tbricks::Hash<tbricks::InstrumentVenueIdentification,OrderRequest> m_orderQueue; }; }<fim-middle>sell         tbricks::PortfolioIdentifier portfolio;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n<fim-suffix><fim-middle>    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }"}
{"content":"<fim-prefix>#include \"TbChildOrder.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbChildOrder::TbChildOrder(IExecutionHandler& handler, Strategy& app)\n: OrderExecutor(handler)\n, m_app(app)\n, m_stream(*this)\n{\n    StrategyStream::Options opts;\n    opts.SetFilter(StrategyByParentFilter(app.GetIdentifier()));\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, opts, StrategyStream::ToStrategyEngine);\n    TBDEBUG(__func__ << \" opened stream with options: \" << opts);\n}\n\nTbChildOrder::~TbChildOrder()\n{\n    m_stream.Close();\n    DeleteOrders();\n}\n\nvoid TbChildOrder::DeleteOrders()\n{\n    TBDEBUG(__func__);\n    for (const auto& [ivid,childId] : m_childMap)\n    {\n        if (m_childData[childId].GetState().IsDeleted())\n<fim-suffix><fim-middle>        {\n            continue;\n        }"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include \"InstrumentManager.h\"\n\nclass InstrumentEnricherPlugin : public tbricks::Strategy\n                               , public InstrumentManager::IHandler\n<fim-suffix><fim-middle>{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const<fim-suffix>bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice<fim-middle>{ return m_stream.GetIdentifier(); }"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return<fim-suffix>return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; }<fim-middle>i->value.GetString(); }"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VizualizationApp methods void HandleStrategyViewCreate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleStrategyViewUpdate(<fim-suffix>void HandleStrategyViewDelete( tbricks::visualization::models::AppViewModel& viewModel) final; void HandleGridViewCreate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleGridViewUpdate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final;<fim-middle>tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy methods void<fim-suffix>void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context)<fim-middle>HandleDeleteRequest() final;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n<fim-suffix><fim-middle>{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \", item = \" << item);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return<fim-suffix>} template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string<fim-middle>istm;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n<fim-suffix><fim-middle>    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n<fim-suffix><fim-middle>    m_instrument_enricherAppAction.Clear();\n}"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { Price emptyPrice; Volume emptyVolume {0}; iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); deribit::ticker_update update(value); \/\/ Handle the trading phase if (update.IsOpen()) { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed); } else { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed); } \/\/ BBO bbo.SetAskPrice(update.GetAsk()); bbo.SetBidPrice(update.GetBid()); bbo.SetAskVolume(update.GetAskVolume()); bbo.SetBidVolume(update.GetBidVolume()); auto millis = update.GetTimestamp(); DateTime timestamp = DateTime::Now(); if (millis > 0) { timestamp = DateTime::Create(millis \/ 1000); } bbo.SetExchangeModifiedDatetime(timestamp); \/\/ Statistics stats.SetLastPrice(update.GetLastPrice()); stats.SetOpenInterest(update.GetOpenInterest()); stats.SetDailySettlementPrice(update.GetSettlementPrice()); stats.SetHighPrice(update.GetMaxPrice()); stats.SetLowPrice(update.GetMinPrice()); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail() { InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);<fim-suffix>m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::SendSnapshotDoneIfNeeded() {<fim-middle>m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"OrderExecutor.h\"\n#include \"shared\/MDTracker.h\"\n\n<fim-suffix><fim-middle>namespace execution {"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n<fim-suffix><fim-middle>{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n<fim-suffix><fim-middle>void TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/EventProcessor.h> #include <future> namespace misc { class AsyncProcessor { private: const tbricks::EventProcessor& m_proc; tbricks::StrategyIdentifier m_id; std::string m_result; public: AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc),<fim-suffix>{ std::thread([this]{ std::this_thread::sleep_for(std::chrono::seconds(3)); m_result = \"ASYNC SUCCESS\"; tbricks::UserData payload; payload.Set(&m_result, 0); \/\/ we can do shallow<fim-middle>m_id(appId) {}; void DoAsync()"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void<fim-suffix>void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request)<fim-middle>HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;\n    }\n}\n\nvoid InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n<fim-suffix><fim-middle>    {\n        const int total = m_instrumentCache.size();"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus<fim-suffix><fim-middle>& iStatus, Statistics & stats)"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source)\n{\n<fim-suffix><fim-middle>    if (!m_volatility_model) return {};\n    if (m_volatility_model->IsInterpolated()) return {};\n    if (source.Empty()) return m_volatility_model;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;<fim-suffix>void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream &<fim-middle>void HandleStreamOpen(tbricks::TCPStream & stream) final;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply<fim-suffix>const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val);<fim-middle>&&); bool IsError() const;"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi,<fim-suffix>VOLATILITY(custom,<fim-middle>SVI) VOLATILITY(wing, Wing)"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi,<fim-suffix><fim-middle>SVI) VOLATILITY(wing, Wing)"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem &<fim-suffix><fim-middle>item)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats); void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem; tbricks::Identifier m_tickerId; bool<fim-suffix>};<fim-middle>m_snapshotDone {false};"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n<fim-suffix><fim-middle>    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { Price emptyPrice; Volume emptyVolume {0}; iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); deribit::ticker_update update(value); \/\/ Handle the trading phase if (update.IsOpen()) { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed); }<fim-suffix>{ iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed); } \/\/ BBO bbo.SetAskPrice(update.GetAsk()); bbo.SetBidPrice(update.GetBid()); bbo.SetAskVolume(update.GetAskVolume()); bbo.SetBidVolume(update.GetBidVolume()); auto millis = update.GetTimestamp(); DateTime timestamp = DateTime::Now(); if (millis > 0) { timestamp = DateTime::Create(millis \/ 1000); } bbo.SetExchangeModifiedDatetime(timestamp); \/\/ Statistics stats.SetLastPrice(update.GetLastPrice()); stats.SetOpenInterest(update.GetOpenInterest()); stats.SetDailySettlementPrice(update.GetSettlementPrice()); stats.SetHighPrice(update.GetMaxPrice()); stats.SetLowPrice(update.GetMinPrice()); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail() { InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::SendSnapshotDoneIfNeeded() {<fim-middle>else"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n<fim-suffix><fim-middle>    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n<fim-suffix><fim-middle>    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n<fim-suffix><fim-middle>{\n    return isError;\n}"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)\n    {\n        HandleTickerUpdate(ticker, \"{}\");\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n    {\n        TBWARNING(\"Received unknown instrument ticker: \" << ticker);\n        return;\n    }\n    auto request = m_requestMap.find(id);\n    if (request != m_requestMap.end())\n    {\n        for (const auto & object : request->second.GetObjects())\n<fim-suffix><fim-middle>        {\n            InstrumentIdentifier instrument;\n            object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrument);\n            if (instrument == id)"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier());<fim-suffix><fim-middle>} void DeribitMdp::HandleSubscribe(MarketDataItem & item)"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->Reset();\n    }\n    else\n<fim-suffix><fim-middle>    {\n        TBDEBUG(\"Unknown stream\");\n    }\n}"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbChildOrder : public OrderExecutor, public tbricks::StrategyStream::IHandler, public tbricks::IRequestReplyHandler { public: TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app); ~TbChildOrder(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ StrategyStream::IHandler void HandleStrategyUpdate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyUpdate & update) final; void HandleStrategyInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyIdentifier & id) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text)<fim-suffix>private: tbricks::Strategy& m_app; tbricks::StrategyStream m_stream; tbricks::Hash<tbricks::Identifier,tbricks::StrategyIdentifier> m_requests; tbricks::Hash<tbricks::InstrumentVenueIdentification,tbricks::StrategyIdentifier> m_childMap; tbricks::Hash<tbricks::StrategyIdentifier,tbricks::StrategyData> m_childData; }; } \/\/<fim-middle>override; private:"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item,<fim-suffix><fim-middle>*this); m_models.emplace(instrument_id, model);"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    if (not m_client)\n    {\n        m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_PROD);\n    }\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \": \" << request);"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler & handler)\n    : m_instrumentStream(*this)\n    , m_handler(handler)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Clear()\n{\n    m_tbricksInstruments.clear();\n    m_deribitInstruments.clear();\n    m_pendingCreates.clear();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n    \n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByVenueFilter(m_handler.GetVenueIdentifier()) && InstrumentStream::Filters::DeletedFilter(\/*deleted=*\/false));\n    m_instrumentStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n    \n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() \n            << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    String key = GetInstrumentKey(deribitInstrument);\n    m_deribitInstruments[key] = deribitInstrument;\n}\n\nString InstrumentManager::GetInstrumentKey(const Instrument & instrument)\n{\n    return instrument.GetShortName();\n}\n\nString InstrumentManager::GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    return deribitInstrument->instrument_name;\n}\n\nvoid InstrumentManager::Start()\n{\n    Clear();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::SyncInstruments()\n{\n    TBDEBUG(__func__ << \": Comparing \" << m_tbricksInstruments.size() \n            << \" Tbricks instruments with \" << m_deribitInstruments.size() \n            << \" Deribit instruments\");\n            \n    for (const auto & [key, deribitInst] : m_deribitInstruments)\n    {\n        auto tbricks_it = m_tbricksInstruments.find(key);\n        if (tbricks_it == m_tbricksInstruments.end())\n        {\n            if (not deribitInst->is_active)\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not active\");\n                continue;\n            }\n            if (deribitInst->instrument_type == \"linear\")\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is linear\");\n                continue;\n            }\n            if ((deribitInst->settlement_period != \"month\") and not deribitInst->settlement_period.Empty())\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not a monthly option\");\n                continue;\n            }\n            \n            CreateInstrument(deribitInst);\n        }\n        else\n        {\n            const auto & instrument = tbricks_it->second;\n            ModifyInstrument(instrument, deribitInst);\n        }\n    }\n}\n\nvoid InstrumentManager::CreateInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    TBDEBUG(__func__ << \": Creating instrument \" << deribitInstrument->instrument_name);\n\n    Instrument::Options options;\n    \n    options.SetShortName(deribitInstrument->instrument_name);\n    options.SetLongName(deribitInstrument->instrument_name);\n    \n    CFI cfi;\n    if (deribitInstrument->option_type == \"call\")\n    {\n        cfi = CFI(\"OC\", CFI::V2015);\n    }\n    else if (deribitInstrument->option_type == \"put\")\n    {\n        cfi = CFI(\"OP\", CFI::V2015);\n    }\n    options.SetCFI(cfi);\n\n    std::vector<VenueInstrumentIdentifier> viids;\n    VenueInstrumentIdentifier viid;\n    viid.SetVenueIdentifier(m_handler.GetVenueIdentifier());\n    viid.SetMIC(MIC(\"XCYS\")); \/\/ dummy MIC\n    viid.Add(\"symbol\", deribitInstrument->instrument_name);\n    viids.push_back(viid);\n    options.SetVenueInstrumentIdentifiers(viids);\n\n    std::vector<InstrumentGroup> instrumentGroups;\n    \n    InstrumentAttributes attributes;\n    \n    if (not deribitInstrument->expiration_timestamp.Empty())\n    {\n        attributes.SetMaturityDate(deribitInstrument->expiration_timestamp.GetCalendarDate());\n    }\n    \n    if (deribitInstrument->strike)\n    {\n        attributes.SetAttribute(instrument_attributes::StrikePrice(), Price(*deribitInstrument->strike));\n    }\n    \n    if (deribitInstrument->contract_size != 0.0)\n    {\n        attributes.SetAttribute(instrument_attributes::InstrumentMultiplier(), deribitInstrument->contract_size);\n    }\n\n    if (!deribitInstrument->counter_currency.Empty())\n    {\n        auto base_ccy = Currency(deribitInstrument->counter_currency);\n        attributes.SetAttribute(instrument_attributes::BaseCurrency(), base_ccy);\n        instrumentGroups.emplace_back(base_ccy.GetInstrumentGroupIdentifier());\n    }\n    \n    options.SetInstrumentGroups(instrumentGroups);\n\n    options.SetAttributes(attributes);\n\n    auto result = Instrument::SendCreateRequest(options, *this);\n    m_pendingCreates[result.GetRequestIdentifier()] = deribitInstrument->instrument_name;\n    TBDEBUG(__func__ << \": \" << options);\n}\n\nvoid InstrumentManager::ModifyInstrument(const Instrument & instrument, const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    TBFULLDUMP(__func__ << \": Potentially modifying instrument \" << deribitInstrument->instrument_name);\n\n    InstrumentModifier mod(instrument.GetIdentifier());\n    \n    CFI cfi;\n    if (deribitInstrument->option_type == \"call\")\n    {\n        cfi = CFI(\"OC\", CFI::V2015);\n    }\n    else if (deribitInstrument->option_type == \"put\")\n    {\n        cfi = CFI(\"OP\", CFI::V2015);\n    }\n    if (cfi != instrument.GetCFI())\n    {\n        mod.SetCFI(cfi);\n    }\n\n    VenueInstrumentIdentifier viid;\n    viid.SetVenueIdentifier(m_handler.GetVenueIdentifier());\n    viid.SetMIC(MIC(\"XCYS\")); \/\/ dummy MIC\n    viid.Add(\"symbol\", deribitInstrument->instrument_name);\n\n    std::vector<VenueInstrumentIdentifier> viids;\n    instrument.GetVenueInstrumentIdentifiers(viids);\n    auto it = std::find_if(viids.begin(), viids.end(), [viid](const VenueInstrumentIdentifier& v) { return v == viid; });\n    if (it == viids.end())\n    {\n        viids.clear();\n        viids.push_back(viid);\n        mod.AddVenueInstrumentIdentifiers(viids);\n    }\n\n    std::vector<InstrumentGroupIdentifier> instrumentGroups;\n    \n    InstrumentAttributes attributes;\n    \n    if (not deribitInstrument->expiration_timestamp.Empty())\n    {\n        auto maturityDate = deribitInstrument->expiration_timestamp.GetDate().GetCalendarDate();\n        if (instrument.GetMaturityDate().ToString() != maturityDate.ToString())\n        {\n            TBDEBUG(__func__ << maturityDate << \" != \" << instrument.GetMaturityDate());\n            attributes.SetMaturityDate(maturityDate);\n        }\n    }\n    \n    if (deribitInstrument->strike)\n    {\n        Price strike_price(*deribitInstrument->strike);\n        if (std::abs(instrument.GetStrikePrice() - strike_price) > 0.0001)\n        {\n            attributes.SetAttribute(instrument_attributes::StrikePrice(), strike_price);\n        }\n    }\n    \n    if (deribitInstrument->contract_size != 0.0)\n<fim-suffix><fim-middle>    {\n        Double multiplier;\n        instrument.GetAttribute(instrument_attributes::InstrumentMultiplier(), multiplier);\n        if (std::abs(multiplier - deribitInstrument->contract_size) > 0.0001)"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\nusing Method = std::pair<DeribitMethod, std::string>;\n\n<fim-suffix><fim-middle>static std::vector<Method> GetAvailableMethods()\n{\n    return {"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n\ntemplate <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);\n}\n\ntemplate <>\nBinary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)\n{\n    if (val.size() <= 0)\n        return ostm;\n\n    ostm.write(val.c_str(), val.size());\n\n    return ostm;\n}\n\nBinary_ostream & operator<<(Binary_ostream & ostm, const char * val)\n{\n    int size = std::strlen(val);\n    if (size <= 0)\n        return ostm;\n\n    ostm.write(val, size);\n<fim-suffix><fim-middle>    return ostm;\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); }<fim-suffix>{ TBDEBUG(\"HandleRunRequest\"); SetState(StrategyState::RUNNING); } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(\"HandlePauseRequest\"); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(\"HandleDeleteRequest\"); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(\"Modify request: \" << modifier); \/\/ Accept all<fim-middle>void InstrumentEnricherPlugin::HandleRunRequest()"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n\nclass DeribitMdp : public tbricks::MarketDataProvider\n<fim-suffix><fim-middle>{\npublic:\n    DeribitMdp();\n    ~DeribitMdp() noexcept override = default;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n    \n    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);\n    \n    if (read > 0 && read < m_buffer.GetSize())\n<fim-suffix><fim-middle>    {\n        Binary fragment(&static_cast<char *>(m_buffer.GetData())[read], \n                       m_buffer.GetSize() - read);\n        m_buffer = fragment;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void<fim-suffix>}; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void<fim-middle>HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); }<fim-suffix>void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice<fim-middle>protected:"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\ntypedef std::pair<DeribitMethod, std::string> Method;\n\nstatic std::vector<Method> GetAvailableMethods()\n{\n    return {\n            {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)},\n            {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)},\n            {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)},\n            {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)},\n            {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)},\n            {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)},\n            {DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)},\n<fim-suffix><fim-middle>            {DeribitMethod::PUBLIC_GetInstruments, Resolve(DeribitMethod::PUBLIC_GetInstruments)},\n            {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)},\n            {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}};\n}"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); }<fim-suffix>private: IHandler& m_handler; tbricks::Timer m_startTimerEvent; tbricks::DateTime m_startTime; tbricks::Duration<fim-middle>const tbricks::DateTime& GetTimerLastFired() const { return m_timerLastFired; }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status); ~PositionsData(); void Stop(); public: using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>; const Data& GetData() const { return m_data; } protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ CalculatedPropertiesTable::Stream::IHandler void HandleCalculatedProperties(const tbricks::StreamIdentifier & stream_id, const tbricks::CalculatedPropertiesTable::Update & update) final; private: void RefreshStatusText(); private: tbricks::StringParameter& m_appStatus; tbricks::CalculatedPropertiesTable m_table; tbricks::CalculatedPropertiesTable::Stream m_stream; Data<fim-suffix><fim-middle>m_data;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n<fim-suffix><fim-middle>        SimpleWeb::CaseInsensitiveMultimap header;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n\nclass DeribitModel\n{\n\npublic:\n    DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler);\n    ~DeribitModel() noexcept = default;\n\n    void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update);\n\n    const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); }\n<fim-suffix><fim-middle>    bool IsSnapshotDone() const { return m_snapshotDone; }"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice)\nUNDER(underlying_bid_price, Price, UnderlyingBidPrice)\nUNDER(underlying_ask_price, Price, UnderlyingAskPrice)\nUNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed)\nUNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed)\nUNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus)\nUNDER(underlying_trading_status, Integer, UnderlyingTradingStatus)\nUNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase)\nUNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed)\nUNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange)\nUNDER(underlying_price_quality, Double, UnderlyingPriceQuality)\n\nFAIR(fair_market_price, Price, FairMarketPrice)\nFAIR(fair_bid_price, Price, FairBidPrice)\nFAIR(fair_ask_price, Price, FairAskPrice)\n<fim-suffix><fim-middle>GREEK(forward_price, Price, ForwardPrice)\nGREEK(quanto_forward_price, Price, QuantoForwardPrice)\nGREEK(spot_price, Price, SpotPrice)\nGREEK(strike_price, Price, StrikePriceInUnderlyingCurrency)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this<fim-suffix><fim-middle>limit will result in a message_size error code and the connection will be closed.         std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();"}
{"content":"<fim-prefix>#include \"TbChildOrder.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbChildOrder::TbChildOrder(IExecutionHandler& handler, Strategy& app)\n: OrderExecutor(handler)\n, m_app(app)\n, m_stream(*this)\n{\n    StrategyStream::Options opts;\n    opts.SetFilter(StrategyByParentFilter(app.GetIdentifier()));\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, opts, StrategyStream::ToStrategyEngine);\n    TBDEBUG(__func__ << \" opened stream with options: \" << opts);\n}\n\nTbChildOrder::~TbChildOrder()\n{\n    m_stream.Close();\n    DeleteOrders();\n}\n\nvoid TbChildOrder::DeleteOrders()\n{\n    TBDEBUG(__func__);\n    for (const auto& [ivid,childId] : m_childMap)\n    {\n        if (m_childData[childId].GetState().IsDeleted())\n        {\n            continue;\n        }\n        Strategy::SendDeleteRequest(childId);\n        TBDUMP(\"Sent deletion for \" << childId << \" [\" << ivid << \"]\");\n    }\n}\n\nvoid TbChildOrder::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume,\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n\n    StrategyOptions opts{plug_ins::Order()}; \/\/ very few app definitions in this namespace\n\n    StrategyAttributes attrs;\n    attrs.SetExtraData(m_app.GetExtraData());\n    opts.SetAttributes(attrs);\n\n    StrategyParameters params;\n    params.SetParameter(strategy_parameters::Portfolio(), portfolio);\n    params.SetParameter(strategy_parameters::ActiveVolume(), volume.Abs());\n    params.SetParameter(strategy_parameters::Instrument(), ivid.GetInstrumentIdentifier());\n    params.SetParameter(strategy_parameters::Venue(), ivid.GetVenue());\n    params.SetParameter(strategy_parameters::MIC(), ivid.GetMIC());\n    if (volume < 0.0)\n    {\n        params.SetParameter(strategy_parameters::Side(), Side{Side::SELL});\n    }\n    else\n    {\n        params.SetParameter(strategy_parameters::Side(), Side{Side::BUY});\n    }\n\n    auto res = Strategy::SendCreateRequest(opts, params, *this);\n    TBDEBUG(\"Sent creation request for child \" << res.GetStrategyIdentifier());\n    TBDUMP(opts);\n    TBDUMP(params);\n    m_childMap[ivid] = res.GetStrategyIdentifier();\n    m_requests[res.GetRequestIdentifier()] = res.GetStrategyIdentifier();\n}\n\nvoid TbChildOrder::HandleStreamOpen(const StreamIdentifier& stream)\n{\n    TBDEBUG(__func__ << \" : \" << stream);\n}\n\nvoid TbChildOrder::HandleStreamStale(const StreamIdentifier& stream)\n<fim-suffix><fim-middle>{\n    TBWARNING(__func__ << \" : \" << stream);\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n<fim-suffix><fim-middle>{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem &<fim-suffix>~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone()<fim-middle>item, tbricks::DistributedValues::Stream::IHandler & handler);"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include \"shared\/app\/app.h\"\nCLANG_RESTORE_WARNINGS\n\n#include <limits>\n\nusing namespace tbricks;\n\nclass ValuesRequest;\n\nstruct ImpliedValue\n{\n    void Clear();\n<fim-suffix><fim-middle>    friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value)\n    { return value.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class<fim-suffix><fim-middle>IHandler { public:"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n<fim-suffix><fim-middle>    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats); tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem;<fim-suffix><fim-middle>tbricks::Identifier m_tickerId;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n    ~DeribitContributor() noexcept override = default;\n\nprotected:\n    void HandleRunRequest() override;\n    void HandlePauseRequest() override;\n    void HandleDeleteRequest() override;\n    void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override;\n    void HandleValidateRequest(tbricks::ValidationContext & context) override;\n    void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override;\n    void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override;\n\n    void HandleDeribitConnected() override;\n    void HandleDeribitDisconnected() override;\n<fim-suffix><fim-middle>private:\n    void FailWithReason(const tbricks::String & reason);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n\nprotected:\n    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;\n    void HandleStreamClose(tbricks::TCPStream & stream) final;\n\n    void UpgradeWs();\n\nprivate:\n    std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept;\n\n    void ParseHttpReply(const tbricks::Binary & data);\n    std::size_t ReadWsReply(std::istream & data);\n    void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length);\n\nprivate:\n    IWebsocketHandler & m_handler;\n    tbricks::TCPStream m_tcp;\n    std::random_device m_rd;\n    std::shared_ptr<std::string> nonce_base64;\n\n    Config m_config;\n\n    std::string host;\n    unsigned short port;\n    std::string path;\n    bool m_handshake_done = false;\n\n<fim-suffix><fim-middle>    tbricks::Binary m_buffer;\n    std::string m_buffer_message;\n};"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long<fim-suffix>std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when<fim-middle>timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum.         \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed."}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h><fim-suffix><fim-middle>class DeribitModel { public:"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public<fim-suffix>public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override; \/\/ MDTracker::IHandler void HandleBBOUpdate( const tbricks::InstrumentVenueIdentification&<fim-middle>tbricks::OrderManager, public tbricks::IRequestReplyHandler,"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin : public tbricks::Pricing { public: ExampleCalcAppPlugin(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override {}; void HandleRunRequest() override {}; void HandlePauseRequest() override {}; void HandleModifyRequest(const<fim-suffix>void HandleValidateRequest(tbricks::ValidationContext &context) override {}; void Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull &<fim-middle>tbricks::StrategyModifier &modifier) override {};"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n<fim-suffix><fim-middle>    {\n        return m_index;\n    }\n    bool seekg(size_t pos)"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\"\n#include \"tbricks_definitions.h\"\n#include <cstdlib>\n\nusing namespace tbricks;\n\nExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) :\n        Pricing(request)\n{\n    srand (time(NULL)); \/\/ Initialize random seed.\n<fim-suffix><fim-middle>    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n    SnapshotDone();"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/test\/TestEngine.h>\n<fim-suffix><fim-middle>using namespace tbricks;\nusing namespace tbricks::test;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionRetriever : public tbricks::PositionStream::IHandler { public: class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId); void Stop(); \/\/ Common Stream methods void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final; void HandleStreamStale(const tbricks::StreamIdentifier &stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier &stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier &stream) final; \/** * PositionStream::IHandler<fim-suffix>const tbricks::Position &<fim-middle>*\/ void HandlePosition(const tbricks::StreamIdentifier & stream_id,"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item)<fim-suffix>void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const<fim-middle>override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n<fim-suffix><fim-middle>        m_index += size;\n    }"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters());<fim-suffix><fim-middle>MergeAttributes(modifier.GetAttributes()); }"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char *<fim-suffix>if (size <= 0) return ostm; ostm.write(val,<fim-middle>val) { int size = std::strlen(val);"}
{"content":"<fim-prefix>#pragma once\n\n#include <string_view>\n#include <strategy\/type\/String.h>\n\nnamespace deribit {\n\nstruct RapidDocument;\n\nclass UpdateData\n{\npublic:\n    UpdateData();\n    virtual ~UpdateData();\n\n    std::string_view ToString();\n    void Parse(const tbricks::String & str);\n\nprotected:\n    RapidDocument * m_doc;\n};\n\nclass ticker_update : public UpdateData\n{\npublic:\n    ticker_update(const tbricks::String & str);\n<fim-suffix><fim-middle>    std::string_view GetInstrumentName();"}
{"content":"<fim-prefix>#pragma once\n\n#include \"OrderExecutor.h\"\n\n#include \"shared\/order_minion\/OrderMinionController.h\"\n#include \"shared\/order_minion\/OrderMinionRequest.h\"\n\nnamespace execution {\n\nclass TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler\n{\npublic:\n    TbOrderMinion(IExecutionHandler& handler,\n                  tbricks::Strategy& app,\n                  const tbricks::InitializationReason& reason,\n                  const tbricks::StrategyParameters& parameters);\n    ~TbOrderMinion();\n\n<fim-suffix><fim-middle>    void DeleteOrders() override;\n    void CreateOrder(\n        const tbricks::InstrumentVenueIdentification& ivid,"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate)<fim-suffix>HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight) HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price, Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed) VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double, NextDividend) VALUE(next_dividend_date, Date, NextDividendDate) VALUE(underlying_settlement_date, Date, UnderlyingSettlementDateUsed) VALUE(final_settlement_date, Date, FinalSettlementDateUsed) VALUE(next_call_put_date, DateTime, NextCall_DIV_PutDate) VALUE(days_to_next_dividend, Integer, DaysToNextDividend) VALUE(trading_days_to_next_dividend, Integer,<fim-middle>HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight)"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n<fim-suffix><fim-middle>    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } private: bool CheckRunningRequirement(); \/\/ app parameters tbricks::InstrumentGroupParameter m_instrumentGroup; tbricks::DateTimeParameter m_maturityDate;<fim-suffix><fim-middle>tbricks::StringParameter m_plugInStatusDescription;"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\" #include \"tbricks_definitions.h\" #include <cstdlib> #include <set> using namespace tbricks; ExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin2::HandlePricingModifyRequest(const PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin2::Calculate(const RequestAndIVIDs & values, const CalculatedValuesRequestFull & request) { m_rows = values; for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, civ_it.GetColumnId(), x); } } else { TBERROR(\"System asked for calculation which the plugin does not support!\"); } } Send(); } void ExampleCalcAppPlugin2::Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x) { CalculatedValueIdentifier calc_id(rowId, columnId); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result<fim-suffix>Update(calc_id, result); } bool ExampleCalcAppPlugin2::HandlePartialPricingModifyRequest(const CalculatedValuesRequestUpdate &update) {<fim-middle>= x + (double)std::rand() \/ (double)RAND_MAX - 0.5;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\nprotected:\n<fim-suffix><fim-middle>    void HandleRunRequest() override;\n    void HandlePauseRequest() override;\n    void HandleDeleteRequest() override;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n\nprivate:\n    std::string_view type;\n};\n\nclass subscriptions : public JsonCall\n{\npublic:\n    subscriptions(const std::string_view id, DeribitMethod method);\n\n    void AddChannel(const std::string & channel);\n};\n\nclass subscriptions_reply : public JsonReply\n{\npublic:\n    subscriptions_reply(JsonReply && base);\n\n    std::vector<std::string_view> GetChannels() const;\n};\n<fim-suffix><fim-middle>class subscription_update : public JsonReply\n{\npublic:\n    subscription_update(JsonReply && base);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return<fim-suffix><fim-middle>m_index >= m_data.GetSize();"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\"<fim-suffix><fim-middle>class PositionsData;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int<fim-suffix>istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <><fim-middle>size = 0;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item);<fim-suffix><fim-middle>} void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired) VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel) VOLATILITY_MODEL_WRAP(None,ConstantVolatility)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(MyCustom,MyCustomVolatilityModel)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void<fim-suffix><fim-middle>HandleTimerEventHit() = 0;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats); void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem; tbricks::Identifier m_tickerId;<fim-suffix><fim-middle>bool m_snapshotDone {false}; };"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \", item = \" << item);\n}"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n<fim-suffix><fim-middle>Json::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing) VOLATILITY(custom, Custom)<fim-suffix><fim-middle>VOLATILITY(my_custom, MyCustom)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); } const<fim-suffix><fim-middle>tbricks::DateTime& GetTimerLastFired() const { return m_timerLastFired; }"}
{"content":"<fim-prefix>#pragma once<fim-suffix>{ public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept =<fim-middle>#include <shared\/API.h> class DeribitModel"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n<fim-suffix><fim-middle>        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);\n\n     if (id.second != m_tickerId)\n    {\n        TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);\n        return;\n    }\n<fim-suffix><fim-middle>    if (value.Empty() or (value == \"{}\") or value.HasError())\n    {\n        Price emptyPrice;\n        Volume emptyVolume {0};"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(\"HandleRunRequest\"); SetState(StrategyState::RUNNING); } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(\"HandlePauseRequest\"); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(\"HandleDeleteRequest\"); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(\"Modify request: \"<fim-suffix>\/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(\"HandleValidateRequest: \" << context); \/\/ No default validation so we just inform<fim-middle><< modifier);"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/<fim-suffix>void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription :<fim-middle>IWebsocketHandler     void HandleWebsocketConnected() final;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n<fim-suffix><fim-middle>    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const<fim-suffix>{ srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const<fim-middle>tbricks::PricingRequest& request) : Pricing(request)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void<fim-suffix>void HandleUnsubscribe(tbricks::MarketDataItem & item)<fim-middle>HandleSubscribe(tbricks::MarketDataItem & item) override;"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel) VOLATILITY_MODEL_WRAP(None,ConstantVolatility)"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n<fim-suffix><fim-middle>    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); }<fim-suffix>private: IHandler& m_handler; tbricks::Timer m_startTimerEvent; tbricks::DateTime m_startTime;<fim-middle>const tbricks::DateTime& GetTimerLastFired() const { return m_timerLastFired; }"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n<fim-suffix><fim-middle>class DeribitModel\n{"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return<fim-suffix>} Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) {<fim-middle>ostm; ostm.write(val.c_str(), val.size()); return ostm;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; namespace dv = deribit_contributor::distributed_values; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); m_supported_values.insert(dv::DeribitTicker().GetIdentifier()); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::FailWithReason(const String & reason) { SetTransactionFail(reason, StrategyState::PAUSED); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); DistributedValuesReply reply(request.GetIdentifier(), false); \/\/ Check that all objects are supported by the app InstrumentIdentifier instrumentId; for (const auto & object : request.GetObjects()) { auto & objParams = object.GetParameters(); if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency())) { \/\/ if instrument is not defined in the request TBDEBUG(\"Object missing required parameters:\\n\" << object << \"Rejecting request.\"); IDistributionApp::SendDistributedValuesReply(reply); return; } \/\/ Check instrument listed on venue Instrument i(instrumentId); auto [compatible, viid] = ExtractVIID(i); if (not compatible) { TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\"); IDistributionApp::SendDistributedValuesReply(reply); return; } } for (const auto & value : request.GetValues()) { if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end()) { TBDEBUG(\"Unsupported value:\\n\" << value << \"Rejecting request.\"); IDistributionApp::SendDistributedValuesReply(reply); return; } } if (GetState() == StrategyState::PAUSED) { TBDEBUG(\"Request cannot be answered immediately. App is paused.\"); return; } \/\/ Send successful reply reply.SetSupported(true); IDistributionApp::SendDistributedValuesReply(reply); } void DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); InstrumentIdentifier instrumentId; const auto & request_id = request.GetIdentifier(); \/\/ For all objects in the request ... for (const auto & object : request.GetObjects()) { if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId)) { auto [compatible, viid] = ExtractVIID({instrumentId}); if (m_client and compatible) { SparseHash<String, String> keys; viid.GetKeys(keys); auto & id = keys[\"symbol\"]; for (const auto & v : request.GetValues()) { if (v.GetDefinition() == dv::DeribitTicker()) { m_client->SubscribeToTicker({id}); } } m_requestMap[instrumentId] = request; m_symbolMap[id] = instrumentId; } else { TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId); } } } IDistributionApp::SnapshotDone(request_id);<fim-suffix><fim-middle>} void DeribitContributor::HandleDeribitConnected() {"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void<fim-suffix><fim-middle>* data, size_t size)"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update);<fim-suffix><fim-middle>BestPrice bbo;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) {<fim-suffix>TBSTATUS(__func__ << \": id=\" << id << \",<fim-middle>String value; it.GetValue(value);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n<fim-suffix><fim-middle>class Binary_ostream\n{\npublic:\n    Binary_ostream() { }"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/order_minion\/OrderMinionController.h\" #include \"shared\/order_minion\/OrderMinionRequest.h\" namespace execution { class TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler { public: TbOrderMinion(IExecutionHandler& handler, tbricks::Strategy& app, const tbricks::InitializationReason& reason, const tbricks::StrategyParameters& parameters); ~TbOrderMinion(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier&<fim-suffix>void MonitorInstrument(const<fim-middle>portfolio) override;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionReverser : public tbricks::IRequestReplyHandler { public: PositionReverser() = default; ~PositionReverser() = default; void ReversePosition( const tbricks::Position& position, const tbricks::Price& atPrice); \/\/ IRequestReplyHandler method void HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status,<fim-suffix><fim-middle>const tbricks::String & status_text) final;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return false; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream()<fim-suffix><fim-middle><< std::endl;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n    \n    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);\n    \n    if (read > 0 && read < m_buffer.GetSize())\n    {\n        Binary fragment(&static_cast<char *>(m_buffer.GetData())[read], \n                       m_buffer.GetSize() - read);\n        m_buffer = fragment;\n    }\n    else if (read == m_buffer.GetSize())\n<fim-suffix><fim-middle>    {\n        m_buffer.Clear();\n    }\n}"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const<fim-suffix><fim-middle>tbricks::InstrumentIdentifier & instrument);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void<fim-suffix>void SetRefreshToken(const<fim-middle>SetClientSecret(const std::string_view val);"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)\n    {\n        strm << \"  subscription : \" << Resolve(subscription) << \"\\n\";\n    }\n    if (interval != DeribitInterval::NONE)\n    {\n        strm << \"  interval : \" << Resolve(interval) << \"\\n\";\n    }\n    strm << \"  channel : \" << channel << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nDeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type)\n    : m_handler(handler)\n    , m_timer(*this, \"deribit_refresh\")\n{\n    TBDEBUG(__func__ << \" : \" << endpoint);\n\n    std::string url(endpoint.GetCString());\n    auto found = url.find(\":\/\/\");\n    if (found != std::string::npos)\n    {\n        url = url.substr(found + 3);\n    }\n    m_session.host_port_path = url;\n\n    std::vector<String> slices;\n    m_session.host_port_path.Split(':', slices);\n    TBDUMP(slices);\n    switch (type)\n    {\n    case DeribitHost::NONE:\n        m_conf.header.insert({\"Host\", slices[0].GetCString()});\n        break;\n    default:\n        m_conf.header.insert({\"Host\", Resolve(type)});\n        break;\n    }\n}\n\nDeribitClient::~DeribitClient()\n{\n    TBDEBUG(__func__);\n    Disconnect();\n}\n\nvoid DeribitClient::Connect(const String & userId, const String & secret)\n{\n    TBDEBUG(__func__ << \" : userId=\" << userId << \" secret=\" << secret);\n    m_session.userId = userId;\n    m_session.secret = secret;\n\n    m_ws = std::make_unique<TbWebsocketClient>(*this, m_session.host_port_path, m_conf);\n    m_ws->Connect();\n}\n\nvoid DeribitClient::Disconnect()\n{\n    TBDEBUG(__func__);\n    if (m_ws)\n<fim-suffix><fim-middle>    {\n        m_session.logged_in = false;\n        m_ws->Shutdown();\n    }"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear(); m_wasStreamStale = false; TBDEBUG(__func__); if (m_positionStream.IsOpen()) { m_positionStream.Close(); } m_positionStream.Open( Stream::SNAPSHOT, portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, AnyPositionFilter()); } void PositionRetriever::Stop() { m_positionStream.Close(); m_positions.clear(); } void PositionRetriever::HandleStreamOpen(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { if (not m_wasStreamStale) { TBDEBUG(__func__ << \" Stream opened: \" << stream_id); } else { TBNOTICE(\"Stream reconnected\"); m_wasStreamStale = false; } } else { TBDEBUG(__func__ << \" Unknown opened stream: \" << stream_id); } } void PositionRetriever::HandleStreamStale(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBWARNING(__func__ << \" Stream became stale: \" << stream_id); m_wasStreamStale = true; } else { TBWARNING(__func__ << \" Unknown stale stream: \" << stream_id); } } void PositionRetriever::HandleStreamFailed(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { std::stringstream error; error << \"Stream failed: \" << stream_id; m_callback.HandleError(error.str()); } else { TBWARNING(__func__ << \" Unknown failed stream: \" << stream_id); } } void PositionRetriever::HandleSnapshotEnd(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBDEBUG(__func__ << \" Snapshot end received on stream: \" << stream_id); m_callback.HandlePositions(m_positions); } else { TBDEBUG(__func__ << \" Received snapshot end on unknown stream: \" << stream_id); } } void PositionRetriever::HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) { TBDEBUG(__func__ << \" \" << stream_id); TBDUMP(position); if (m_positionStream.GetIdentifier() == stream_id) { m_positions.emplace(position.GetIdentifier(), position); } else { TBDEBUG(__func__ << \" Received position on unknown stream: \" << stream_id); } } void PositionRetriever::HandlePositionInvalidate( const tbricks::StreamIdentifier & stream_id, const tbricks::Identifier & id) { if (m_positionStream.GetIdentifier() == stream_id) { TBDEBUG(__func__ << \" Received invalidated position on stream: \" << stream_id); m_positions.erase(id); } else {<fim-suffix><fim-middle>TBDEBUG(__func__ << \" Received invalidated position on unknown stream: \" << stream_id);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp();<fim-suffix><fim-middle>~DeribitMdp() noexcept override = default;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n<fim-suffix><fim-middle>public_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler & handler)\n    : m_instrumentStream(*this)\n    , m_handler(handler)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Clear()\n{\n    m_tbricksInstruments.clear();\n    m_deribitInstruments.clear();\n    m_pendingCreates.clear();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n    \n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByVenueFilter(m_handler.GetVenueIdentifier()) && InstrumentStream::Filters::DeletedFilter(\/*deleted=*\/false));\n    m_instrumentStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n    \n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() \n            << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    String key = GetInstrumentKey(deribitInstrument);\n    m_deribitInstruments[key] = deribitInstrument;\n}\n\nString InstrumentManager::GetInstrumentKey(const Instrument & instrument)\n{\n    return instrument.GetShortName();\n}\n\nString InstrumentManager::GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    return deribitInstrument->instrument_name;\n}\n\nvoid InstrumentManager::Start()\n{\n    Clear();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::SyncInstruments()\n{\n    TBDEBUG(__func__ << \": Comparing \" << m_tbricksInstruments.size() \n            << \" Tbricks instruments with \" << m_deribitInstruments.size() \n            << \" Deribit instruments\");\n            \n    for (const auto & [key, deribitInst] : m_deribitInstruments)\n    {\n        auto tbricks_it = m_tbricksInstruments.find(key);\n        if (tbricks_it == m_tbricksInstruments.end())\n        {\n            if (not deribitInst->is_active)\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not active\");\n                continue;\n            }\n            if (deribitInst->instrument_type == \"linear\")\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is linear\");\n                continue;\n            }\n            if ((deribitInst->settlement_period != \"month\") and not deribitInst->settlement_period.Empty())\n            {\n                TBFULLDUMP(\"Skipping \" << key << \" because it is not a monthly option\");\n                continue;\n            }\n            \n            CreateInstrument(deribitInst);\n        }\n        else\n        {\n            const auto & instrument = tbricks_it->second;\n            ModifyInstrument(instrument, deribitInst);\n        }\n    }\n}\n\nvoid InstrumentManager::CreateInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    TBDEBUG(__func__ << \": Creating instrument \" << deribitInstrument->instrument_name);\n\n    Instrument::Options options;\n    \n    options.SetShortName(deribitInstrument->instrument_name);\n    options.SetLongName(deribitInstrument->instrument_name);\n    \n    CFI cfi;\n    if (deribitInstrument->option_type == \"call\")\n    {\n        cfi = CFI(\"OC\", CFI::V2015);\n    }\n    else if (deribitInstrument->option_type == \"put\")\n    {\n        cfi = CFI(\"OP\", CFI::V2015);\n    }\n    options.SetCFI(cfi);\n\n    std::vector<VenueInstrumentIdentifier> viids;\n    VenueInstrumentIdentifier viid;\n    viid.SetVenueIdentifier(m_handler.GetVenueIdentifier());\n    viid.SetMIC(MIC(\"XCYS\")); \/\/ dummy MIC\n    viid.Add(\"symbol\", deribitInstrument->instrument_name);\n    viids.push_back(viid);\n    options.SetVenueInstrumentIdentifiers(viids);\n<fim-suffix><fim-middle>    std::vector<InstrumentGroup> instrumentGroups;"}
{"content":"<fim-prefix>#include \"..\/..\/my_custom_pricing\/tbricks_definitions.h\" constexpr VolatilityModel VolatilityModelMyCustom = VolatilityModel(custom::pricing::extended_enums::VolatilityModelMyCustom);<fim-suffix><fim-middle>#endif \/\/ TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \"<fim-suffix>} void DeribitMdp::HandleSubscribe(MarketDataItem<fim-middle><< GetVenueIdentifier());"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)\n    {\n        HandleTickerUpdate(ticker, \"{}\");\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n<fim-suffix><fim-middle>    {\n        TBWARNING(\"Received unknown instrument ticker: \" << ticker);\n        return;\n    }"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n<fim-suffix><fim-middle>JsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n<fim-suffix><fim-middle>{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>(); case VolatilityModelSVI: return std::make_unique<SVIPreferencesStorage>(); case custom::pricing::extended_enums::VolatilityModelMyCustom: return<fim-suffix><fim-middle>std::make_unique<MyCustomPreferencesStorage>(); default: return std::make_unique<CommonPreferencesStorage>();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } \/\/ TimerController::IHandler void HandleTimerEventHit() final; void HandleTimerControllerUpdate(const tbricks::String& update, bool<fim-suffix><fim-middle>error) final;"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double<fim-suffix>double GetIndexPrice(); double GetCurrentFunding(); double GetBid(); double<fim-middle>GetLastPrice();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem<fim-suffix>bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid)<fim-middle>& item) override;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\" using namespace tbricks; InstrumentManager::InstrumentManager(IHandler& handler) : m_handler(handler) , m_instrumentStream(*this) , m_iapStream(*this) { TBDEBUG(__func__ << \" ctor\"); } InstrumentManager::~InstrumentManager() { TBDEBUG(__func__ << \" dtor\"); Stop(); } void InstrumentManager::Stop() { TBDEBUG(__func__); m_instrumentCache.clear(); m_underlyingCache.clear(); m_instrumentStream.Close(); } void InstrumentManager::Start() { TBDEBUG(__func__); Stop(); OpenInstrumentStream(); } void InstrumentManager::OpenInstrumentStream() { TBDEBUG(__func__); InstrumentStream::Options options; options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup())); m_instrumentStream.Open(Stream::SNAPSHOT, options); TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter()); } void InstrumentManager::OpenIAPStream() { TBDEBUG(__func__); tbricks::InstrumentAggregateParameters::Stream::Options options; for (const auto& [instId, _] : m_instrumentCache) { options.AddInstrument(instId); } options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()}); m_iapStream.Close(); m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options); TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options); } void InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); }<fim-suffix><fim-middle>void InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID)"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <third_party\/include\/rapidjson\/document.h>\n#include <deribit\/DeribitInstrument.h>\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler,\n                          public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0;\n        virtual void HandleInstrumentManagerReady() = 0;\n        virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0;\n        virtual void HandleInstrumentError(const tbricks::String & error) = 0;\n    };\n\n    explicit InstrumentManager(IHandler & handler);\n    ~InstrumentManager() override;\n<fim-suffix><fim-middle>    void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument);"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\<fim-suffix>auto& msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } \\ EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetIndexPrice, index_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetCurrentFunding, current_funding,<fim-middle>{ \\"}
{"content":"<fim-prefix>#pragma once #include <strategy\/EventProcessor.h> #include <future> namespace misc { class AsyncProcessor { private: const tbricks::EventProcessor& m_proc; tbricks::StrategyIdentifier m_id; std::string m_result; public: AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc), m_id(appId) {}; void DoAsync() { std::thread([this]{ std::this_thread::sleep_for(std::chrono::seconds(3)); m_result = \"ASYNC SUCCESS\"; tbricks::UserData payload; payload.Set(&m_result, 0); \/\/ we can do shallow copy because the string is a member variable m_proc.ScheduleStrategyEvent(m_id, payload); }).detach(); } bool HasResult() const { return not<fim-suffix><fim-middle>m_result.empty(); }"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear(); m_wasStreamStale = false; TBDEBUG(__func__); if (m_positionStream.IsOpen()) { m_positionStream.Close(); } m_positionStream.Open( Stream::SNAPSHOT, portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, AnyPositionFilter()); } void PositionRetriever::Stop() { m_positionStream.Close(); m_positions.clear();<fim-suffix><fim-middle>}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is<fim-suffix><fim-middle>empty\"; TBWARNING(m_plugInStatusDescription.GetString());"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType) { return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType)); } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ {<fim-suffix>return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return<fim-middle>\\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\"}
{"content":"<fim-prefix>#include \"..\/shared_config.h\" #include \"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/tbricks_definitions.h\" #include <tests\/shared\/test_utils\/TestUtils.h> \/** This test is designed for the version of GoFlatPlugin using TbOrderManager (no TbOrderMinion). Please set the hardcoded flag of the app m_useMinions = false *\/ void Test(TestEngine& te) { \/* Test variables *\/ VenueInstrumentIdentifier viidOne; Instrument instrumentOne; StrategyIdentifier appId; PortfolioIdentifier portfolioId{go_flat::GetPortfolioId()}; TBSTATUS(\"Initialize instruments\"); { VenueIdentifier venueId = go_flat::GetTestVenueId(); viidOne.SetMIC(\"XXXX\"); viidOne.SetVenueIdentifier(venueId); viidOne.Add(\"symbol\", \"ONE\"); std::vector<VenueInstrumentIdentifier> viids = {viidOne}; Instrument::Options options; options.SetShortName(\"ONE\"); options.SetVenueInstrumentIdentifiers(viids); instrumentOne = te.GetIS().CreateInstrument(options); } TBSTATUS(\"Prepare calculated properties\"); { CalculatedPropertiesTableUpdate cpUpdate; auto rowId = Uuid::Create(); cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Instrument(), instrumentOne.GetIdentifier()); cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Venue(), go_flat::GetTestVenueId()); cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::MIC(), MIC{\"XXXX\"}); cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS(), Volume{100}); CalculatedPropertiesTable::Stream::Options options; options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {}); cpUpdate.SetFilter(options.GetFilter()); cpUpdate.SetRowDataType(static_cast<CalculatedPropertiesTable::RowDataType>(5)); te.GetXE().UpdateCalculatedProperties(cpUpdate); } TBSTATUS(\"Prepare market data\"); { BestPrice best; best.SetBidPrice(38.0); best.SetBidVolume(100); best.SetAskPrice(39.0); best.SetAskVolume(100);<fim-suffix>{ tbricks::test::InstrumentTradingInformation iti; iti.SetCurrency(\"USD\"); iti.SetDefaultTick(Price(0.1)); iti.SetLotVolume(Volume(10)); iti.SetMinimumVolume(Volume(10)); TestEngine::Get().GetTRD(viidOne.GetVenueIdentifier()).CreateInstrumentTradingInformation(viidOne, iti); } TBSTATUS(\"Setup the app\"); { StrategyOptions options(go_flat::plug_ins::GoFlat()); appId = te.CreatePlugin(options, {}, true); StrategyModifier modifier; StrategyParameters params; params.SetParameter(go_flat::strategy_parameters::Portfolio(), portfolioId); modifier.SetParameters(params); te.ModifyPlugin(appId, modifier, true); } TBSTATUS(\"Run the app\"); { te.FlushAllQueues(); te.FlushAllQueues(); te.FlushAllQueues(); te.FlushAllQueues(); te.FlushAllQueues(); te.FlushAllQueues(); te.RunPlugin(appId, true); } TBSTATUS(\"Wait order creation\"); { auto orderReq = te.GetTR(go_flat::GetTestVenueId()).WaitOrderCreate(); ASSERT_TRUE(orderReq.GetSide() == Side::SELL, \"Wrong side of the order. Expected SELL\"); ASSERT_TRUE(orderReq.GetActiveVolume() == Volume{100}, \"Wrong volume of the order. Expected 100\");<fim-middle>te.GetMD(go_flat::GetTestVenueId()).UpdateBestPrice(viidOne, best); } TBSTATUS(\"Prepare trading information\");"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT, PUBLIC_GetInstruments, }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; case DeribitMethod::PUBLIC_GetInstruments: return \"public\/get_instruments\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return<fim-suffix>} enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string> Method; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods() { return { {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)}, {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)}, {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)}, {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)}, {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)}, {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)}, {DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)}, {DeribitMethod::PUBLIC_GetInstruments, Resolve(DeribitMethod::PUBLIC_GetInstruments)}, {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)}, {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}}; } }<fim-middle>{}; }"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n<fim-suffix><fim-middle>{\n    switch (e)\n    {\n    case DeribitKind::ALL:"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void<fim-suffix><fim-middle>HandleRunRequest() final;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem<fim-suffix>: m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status,<fim-middle>& item, DistributedValues::Stream::IHandler & handler)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler interface void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId, const tbricks::CalculatedInstrumentValues::Update & update) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id,<fim-suffix><fim-middle>tbricks::Status status, const tbricks::String& status_text) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n<fim-suffix><fim-middle>class public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void<fim-suffix>\/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const<fim-middle>HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return<fim-suffix>} Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) {<fim-middle>ostm;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason &<fim-suffix>: m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" <<<fim-middle>reason, const StrategyParameters & parameters)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);<fim-suffix><fim-middle>protected:"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\" #include <third_party\/include\/rapidjson\/pointer.h> #include <algorithm> #define SET_STRING_VIEW(key, string) \\ auto & params = msg[\"params\"]; \\ Value v; \\ v.SetString(string.data(), string.size(), msg.GetAllocator()); \\ params.AddMember(#key, v, msg.GetAllocator()); #define SET_INTEGER(key, number) \\ auto & params = msg[\"params\"]; \\ Value v; \\ v.SetInt(number); \\ params.AddMember(#key, v, msg.GetAllocator()); namespace deribit { using<fim-suffix>{ msg.SetObject(); auto & allocator = msg.GetAllocator(); Value v; v.SetString(\"2.0\"); msg.AddMember(\"jsonrpc\", v, allocator); } Json::Json(Json && o) : msg(std::move(o.msg)) { } std::string_view Json::ToString() { buffer.Clear(); Writer<StringBuffer> writer(buffer); msg.Accept(writer); return {buffer.GetString()}; } std::string_view Json::GetId() { assert(msg[\"id\"].IsString()); return {msg[\"id\"].GetString()}; } void Json::Parse(std::string_view str) { msg.Clear(); StringStream s(str.data()); msg.ParseStream(s); } DeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods) { Parse(str); if (msg.HasMember(\"method\")) { std::string_view m(msg[\"method\"].GetString()); for (auto & method : methods) { if (method.second == m) { return method.first; } } } return DeribitMethod::NONE; } JsonCall::JsonCall(const std::string_view id, DeribitMethod method) : Json() { auto & allocator = msg.GetAllocator(); Value v; v.SetString(id.data(), id.size(), msg.GetAllocator()); msg.AddMember(\"id\", v, allocator); auto m = Resolve(method); v.SetString(m.data(), m.size(), msg.GetAllocator()); msg.AddMember(\"method\", v, allocator); v.Clear(); v.SetObject(); msg.AddMember(\"params\", v, allocator); } JsonReply::JsonReply(std::string_view json) : Json() { msg.Clear(); Parse(json); if (msg.HasMember(\"error\")) { isError = true; auto errp = Pointer(\"\/error\").Get(msg); if (errp->HasMember(\"code\")) { err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt(); } if (errp->HasMember(\"message\")) { err.message = Pointer(\"\/error\/message\").Get(msg)->GetString(); } if (errp->HasMember(\"data\")) { err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject()); } } auto test = msg.FindMember(\"testnet\"); if (test != msg.MemberEnd()) { isTest = test->value.GetBool(); } } JsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods) : JsonReply(json) { if (msg.HasMember(\"method\")) { std::string_view m(msg[\"method\"].GetString()); for (auto & method : methods) { if (method.second == m) { jrpcMethod = method.first; break; } } } } JsonReply::JsonReply(JsonReply && o) : Json(std::move(o)) , err(std::move(o.err)) , isTest(o.isTest) , isError(o.isError) , jrpcMethod(o.jrpcMethod) { } bool JsonReply::IsError() const { return isError; } const JsonReply::Error & JsonReply::GetError() const { return err; } bool JsonReply::IsTest() const { return<fim-middle>namespace rapidjson; Json::Json()"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short<fim-suffix>public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);<fim-middle>default_port = 80; };"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin2 : public tbricks::Pricing { public: ExampleCalcAppPlugin2(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; bool HandlePartialPricingModifyRequest(const tbricks::CalculatedValuesRequestUpdate &update) override; private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override<fim-suffix>void HandlePauseRequest() override {}; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override {}; void HandleValidateRequest(tbricks::ValidationContext<fim-middle>{}; void HandleRunRequest() override {};"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view<fim-suffix><fim-middle>id); }; class heartbeat : public JsonReply"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n<fim-suffix><fim-middle>TbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double GetBid(); double<fim-suffix><fim-middle>GetAsk();"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n<fim-suffix><fim-middle>UpdateData::~UpdateData()\n{\n    delete (m_doc);\n}"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindPreferencesStorageByScopeDefinition(const ScopeDefinition & scope) const\n{\n    switch (scope.type)\n    {\n    case enumerations::VolatilityManagerPersistentPreferencesScopeUser:\n        return (scope.id == m_provider.GetUserIdentifier().GetUuid()) ? m_pUserScopePreferencesStorage.get() : nullptr;\n    case enumerations::VolatilityManagerPersistentPreferencesScopeProduct:\n        return FindProductScopePreferencesStorage(scope.id);\n    case enumerations::VolatilityManagerPersistentPreferencesScopeMaturity:\n        return FindMaturityScopePreferencesStorage(scope.id);\n    default:\n        return nullptr;\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductGroupIdsWithExistingPersistentPreferences(SparseSet<InstrumentGroupIdentifier> & productGroupIds) const\n{\n    productGroupIds.clear();\n    productGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & pair: m_productScopePreferencesStorages) {\n        TB_UNUSED(productGroupIds.insert(pair.first));\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductAndMaturityGroupIdsWithExistingPersistentPreferences(SparseHash<InstrumentGroupIdentifier, SparseSet<InstrumentGroupIdentifier>> & productAndMaturityGroupIds) const\n{\n    productAndMaturityGroupIds.clear();\n    productAndMaturityGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & [productGroupId, _]: m_productScopePreferencesStorages) {\n        TB_UNUSED(productAndMaturityGroupIds[productGroupId]);\n    }\n\n    for(const auto & pair: m_maturityScopePreferencesStoragesByProductGroupId) {\n        const InstrumentGroupIdentifier & productGroupId = pair.first;\n        SparseSet<InstrumentGroupIdentifier> & maturityGroupIds = productAndMaturityGroupIds[productGroupId];\n        maturityGroupIds.insert(pair.second.first);\n    }\n}\n<fim-suffix><fim-middle>void PersistentPreferencesManagerCore::GetMaturityGroupIdsWithExistingPersistentPreferences(const InstrumentGroupIdentifier & productGroupId,\n                                                                                            SparseSet<InstrumentGroupIdentifier> & maturityGroupIds) const\n{\n    if (TB_UNLIKELY(productGroupId.Empty())) {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const<fim-suffix>\/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup()<fim-middle>tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include \"..\/shared_config.h\"\n\n#include \"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/tbricks_definitions.h\"\n#include <tests\/shared\/test_utils\/TestUtils.h>\n\n\/**\nThis test is designed for the version of GoFlatPlugin using TbOrderManager (no TbOrderMinion).\nPlease set the hardcoded flag of the app m_useMinions = false\n*\/\n\nvoid Test(TestEngine& te)\n{\n    \/* Test variables *\/\n    VenueInstrumentIdentifier viidOne;\n    Instrument instrumentOne;\n    StrategyIdentifier appId;\n    PortfolioIdentifier portfolioId{go_flat::GetPortfolioId()};\n\n    TBSTATUS(\"Initialize instruments\");\n    {\n        VenueIdentifier venueId = go_flat::GetTestVenueId();\n        viidOne.SetMIC(\"XXXX\");\n        viidOne.SetVenueIdentifier(venueId);\n        viidOne.Add(\"symbol\", \"ONE\");\n        std::vector<VenueInstrumentIdentifier> viids = {viidOne};\n\n        Instrument::Options options;\n        options.SetShortName(\"ONE\");\n        options.SetVenueInstrumentIdentifiers(viids);\n        instrumentOne = te.GetIS().CreateInstrument(options);\n    }\n\n    TBSTATUS(\"Prepare calculated properties\");\n    {\n        CalculatedPropertiesTableUpdate cpUpdate;\n        auto rowId = Uuid::Create();\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Instrument(), instrumentOne.GetIdentifier());\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Venue(), go_flat::GetTestVenueId());\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::MIC(), MIC{\"XXXX\"});\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS(), Volume{100});\n\n        CalculatedPropertiesTable::Stream::Options options;\n        options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {});\n        cpUpdate.SetFilter(options.GetFilter());\n        cpUpdate.SetRowDataType(static_cast<CalculatedPropertiesTable::RowDataType>(5));\n        te.GetXE().UpdateCalculatedProperties(cpUpdate);\n    }\n\n    TBSTATUS(\"Prepare market data\");\n    {\n        BestPrice best;\n        best.SetBidPrice(38.0);\n        best.SetBidVolume(100);\n        best.SetAskPrice(39.0);\n        best.SetAskVolume(100);\n        te.GetMD(go_flat::GetTestVenueId()).UpdateBestPrice(viidOne, best);\n    }\n\n    TBSTATUS(\"Prepare trading information\");\n    {\n        tbricks::test::InstrumentTradingInformation iti;\n        iti.SetCurrency(\"USD\");\n        iti.SetDefaultTick(Price(0.1));\n        iti.SetLotVolume(Volume(10));\n        iti.SetMinimumVolume(Volume(10));\n        TestEngine::Get().GetTRD(viidOne.GetVenueIdentifier()).CreateInstrumentTradingInformation(viidOne, iti);\n    }\n\n    TBSTATUS(\"Setup the app\");\n    {\n        StrategyOptions options(go_flat::plug_ins::GoFlat());\n        appId = te.CreatePlugin(options, {}, true);\n\n        StrategyModifier modifier;\n        StrategyParameters params;\n        params.SetParameter(go_flat::strategy_parameters::Portfolio(), portfolioId);\n        modifier.SetParameters(params);\n        te.ModifyPlugin(appId, modifier, true);\n    }\n<fim-suffix><fim-middle>    TBSTATUS(\"Run the app\");\n    {\n        te.FlushAllQueues();\n        te.FlushAllQueues();"}
{"content":"<fim-prefix>#pragma once #include \"IExecutionHandler.h\" #include \"shared\/API.h\" namespace execution { class OrderExecutor { public: virtual ~OrderExecutor() = default; OrderExecutor(IExecutionHandler& handler)<fim-suffix><fim-middle>: m_handler(handler)"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using<fim-suffix>{ TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void<fim-middle>namespace tbricks; DeribitMdp::DeribitMdp()"}
{"content":"<fim-prefix>#pragma once #include<fim-suffix><fim-middle>\"OrderExecutor.h\" #include \"shared\/MDTracker.h\""}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return<fim-suffix><fim-middle>std::make_unique<WingPreferencesStorage>();"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i<fim-suffix>{ ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; }<fim-middle>= update.begin(); i != update.end(); ++i)"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely picked up by another calc app \/\/ the engine was just checking if we responded to it } } Send(); } \/\/ Note<fim-suffix><fim-middle>that here we use DEFINE_PRICING_ENTRY instead of the normal DEFINE_STRATEGY_ENTRY DEFINE_PRICING_ENTRY(ExampleCalcAppPlugin)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public:<fim-suffix>virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient<fim-middle>virtual ~IWebsocketHandler() = default;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h>\n#include <cstddef>\nusing std::size_t;\nnamespace volatility_model_constants {\n\nconst size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5;\nconst double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5;\nconst double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0;\n\nconst double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4;\nconst double VM_MINIMAL_FORWARD_VALUE = 1.0e-4;\nconst double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4;\nconst double VM_COMPARISON_TOLERANCE = 1.0e-9;\nconst double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1;\nconst double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005;\nconst double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1;\t\/\/ This translates to 10%\nconst double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005;\t\t\/\/ This translates to .5%\nconst double VM_MINIMAL_VOLATILITY_TIME = 0.0;\nconst double VM_DEFAULT_SWIM_CORRELATION = 1.0;\nconst double VM_MAXIMAL_PERCENTAGE = 1.0;\nconst double VM_MINIMAL_PERCENTAGE = 0.0;\nconst double VM_DEFAULT_ATM_VOLATILITY = 0.2;\nconst double VM_DEFAULT_FORWARD_PRICE = 100.0;\nconst double VM_DEFAULT_VOLATILITY_TIME = 1.0;\nconst double VM_MINIMAL_FORWARD_PRICE = 0.0;\nconst double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE;\nconst double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0;\n\nconst size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5;\n\nconst size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4;\n\nconst size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9;\nconst double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01;\nconst double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE;\nconst double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5;\nconst double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE;\nconst double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5;\nconst double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE;\nconst double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE;\nconst double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001;\nconst double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01;\nconst double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2;\nconst double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995;\nconst double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0;\nconst double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0;\nconst double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0;\nconst double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0;\nconst double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0;\nconst double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95;\nconst int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally;\nconst double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0;\nconst double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0;\nconst double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1;\n\nconst double CCS_MODEL_MINIMAL_STRIKE = 1.0e-6;\nconst double CCS_MODEL_MINIMAL_SMOOTHNESS = 0.0;\nconst double CCS_MODEL_DEFAULT_SMOOTHNESS = 1.0;\nconst int CCS_MODEL_MINIMAL_NUMBER_OF_CCS_POINTS = 2;\nconst int CCS_MODEL_MAXIMAL_NUMBER_OF_CCS_POINTS = 30;\nconst double CCS_MODEL_DEFAULT_SLOPE_LEFT = -0.05;\nconst double CCS_MODEL_DEFAULT_SLOPE_RIGHT = 0.05;\nconst double CCS_MODEL_DEFAULT_BREAKPOINT_SCALE_FACTOR = 1.0;\nconst double CCS_MODEL_MINIMAL_BREAKPOINT_SCALE_FACTOR = 0.0;\nconst int CCS_MODEL_DEFAULT_ABSCISSA = 0;\nconst double CCS_MODEL_DEFAULT_SLOPE_MULT = 1;\nconst double CCS_MODEL_DEFAULT_CCS_MULTIPLIER = 1.0;\nconst double CCS_MODEL_DEFAULT_CCS_BASE_SMILE_WEIGHT = 1.0;\nconst double CCS_MODEL_DEFAULT_CCS_MULTIPLIER_SMILE_WEIGHT = 0.0;\nconst double CCS_MODEL_DEFAULT_MULTIPLIER_RATIO = 0.0;\n\nconst double SVI_MODEL_DEFAULT_A = 0.04;\nconst double SVI_MODEL_DEFAULT_B = 0.4;\nconst double SVI_MODEL_DEFAULT_RHO = -0.4;\nconst double SVI_MODEL_DEFAULT_M = 0.05;\nconst double SVI_MODEL_DEFAULT_SIGMA = 0.1;\n\n\/*\n * Volatility managers need Forward price to fit volatility model parameters\n * so when there is empty volatility model initially, Pricing cannot calculate\n * Forward price for underlyings paying capped dividends because the reference volatility is required\n * for its calculation thus giving us so called chicken-and-egg problem.\n * 20% volatility is assumed to be a good starting point taking into account\n * that it does not influence significantly in most of the cases on the resulting Forward price.\n *\/\nconstexpr double EMPTY_MODEL_DEFAULT_REFERENCE_VOLATILITY = 0.2;\n\n\n\nconst size_t MY_CUSTOM_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 2;\nconst double MY_CUSTOM_MODEL_DEFAULT_PARAM_1 = 0.0;\nconst double MY_CUSTOM_MODEL_DEFAULT_PARAM_2 = 0.0;\n\n} \/\/ namespace volatility_model_constants\n<fim-suffix><fim-middle>#endif \/\/ __TBRICKS__APPS__SHARED__VOLATILITY__VOLATILITY_MODEL_CONSTANTS__H"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <deribit\/DeribitInstrument.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0; virtual void HandleInstrumentManagerReady() = 0; virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0; virtual void HandleInstrumentError(const tbricks::String & error) = 0; }; explicit InstrumentManager(IHandler & handler); ~InstrumentManager() override; \/\/ Add instruments from Deribit void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Core functionality void Start(); void SyncInstruments(); void Clear(); bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); } protected: \/\/ Common stream callbacks void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ Instrument::Stream callbacks void HandleInstrument(const tbricks::StreamIdentifier & stream, const tbricks::Instrument & instrument) override; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::InstrumentIdentifier & id) override; \/\/ IRequestReplyHandler callback void HandleRequestReply(const tbricks::Identifier & request_id, tbricks::Status status, const tbricks::String & status_text) override; private: \/\/ Helper functions void OpenInstrumentStream(); static tbricks::String GetInstrumentKey(const tbricks::Instrument & instrument); static tbricks::String GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument); void CreateInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); void ModifyInstrument(const tbricks::Instrument& instrument, const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/<fim-suffix>std::map<tbricks::String, std::shared_ptr<DeribitInstrument>> m_deribitInstruments;<fim-middle>Data storage std::map<tbricks::String, tbricks::Instrument> m_tbricksInstruments;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return false;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n<fim-suffix><fim-middle>    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n<fim-suffix><fim-middle>    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); }<fim-suffix>private: IHandler& m_handler; tbricks::Timer m_startTimerEvent; tbricks::DateTime m_startTime;<fim-middle>const tbricks::DateTime& GetTimerLastFired() const { return m_timerLastFired; }"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume {0}; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume);<fim-suffix><fim-middle>bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n\ntemplate <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);\n}\n\ntemplate <>\nBinary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)\n{\n    if (val.size() <= 0)\n        return ostm;\n\n    ostm.write(val.c_str(), val.size());\n<fim-suffix><fim-middle>    return ostm;\n}"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary &&<fim-suffix><fim-middle>src) : m_data(std::move(src)) , m_index(0)"}
{"content":"<fim-prefix>#ifndef TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H #define TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H \/** * This file is intended to introduce definitions of the customized<fim-suffix>* items like instrument parameters or calculated values that<fim-middle>metadata"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\" using namespace tbricks; InstrumentManager::InstrumentManager(IHandler& handler) : m_handler(handler) , m_instrumentStream(*this) , m_iapStream(*this) , m_failed(0) { TBDEBUG(__func__ << \" ctor\"); } InstrumentManager::~InstrumentManager() { TBDEBUG(__func__ << \" dtor\"); Stop(); } void InstrumentManager::Stop() { TBDEBUG(__func__); m_instrumentCache.clear(); m_underlyingCache.clear(); m_instrumentModifyRequests.clear(); m_instrumentStream.Close(); } void InstrumentManager::Start() { TBDEBUG(__func__); m_failed = 0; Stop(); OpenInstrumentStream(); } void InstrumentManager::OpenInstrumentStream() { TBDEBUG(__func__); InstrumentStream::Options options; options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup())); m_instrumentStream.Open(Stream::SNAPSHOT, options); TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter()); } void InstrumentManager::OpenIAPStream() { TBDEBUG(__func__); tbricks::InstrumentAggregateParameters::Stream::Options options; for (const auto& [instId, _] : m_instrumentCache) { options.AddInstrument(instId); } options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()}); m_iapStream.Close(); m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options); TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options); } void InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID) { TBDEBUG(__func__ << \" : \" << streamID); } void InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID) { TBWARNING(\"Instrument cache stream staled = \" << streamID); } void InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID) { m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\"); } void InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID) { TBDEBUG(__func__ << \" : \" << streamID); if (streamID == m_instrumentStream.GetIdentifier()) { TBDEBUG(\"Instruments snapshot done, opening parameters stream...\"); OpenIAPStream(); } else if (streamID == m_iapStream.GetIdentifier()) { \/\/ all data is collected, now perform the next steps EnrichInstruments(); } } void InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument) { TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier()); TBDUMP(instrument); if (streamID == m_instrumentStream.GetIdentifier()) { m_instrumentCache[instrument.GetIdentifier()] = instrument; } else { TBWARNING(\"Instrument update received from unknown stream = \" << streamID); } } void InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID, const InstrumentIdentifier& instrumentID, const InstrumentAggregateParameters::Update& update) { TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update); InstrumentIdentifier underlyingId; if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId)) { m_underlyingCache[instrumentID] = underlyingId; } } void InstrumentManager::CheckModificationStatus() { if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty()) { const int total = m_instrumentCache.size(); std::stringstream result; result << \"Total instruments = \" << total << \", successful = \" << total - m_failed << \", failed = \" << m_failed; m_handler.HandleImportComplete(result.str()); } } void InstrumentManager::EnrichInstruments() { TBDEBUG(__func__); for (const auto& [instID, instrument] : m_instrumentCache) { InstrumentModifier instrumentModifier(instID); DateTime tbMaturityDate; instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate); if (tbMaturityDate != m_handler.GetMaturityDate()) { InstrumentAttributes attributes; attributes.SetAttribute(instrument_attributes::MaturityDate(), m_handler.GetMaturityDate()); instrumentModifier.SetAttributes(attributes); Instrument::RequestResult result = Instrument::SendModifyRequest(instrumentModifier, *this); m_instrumentModifyRequests.emplace(result.GetRequestIdentifier(), instID); } } ModifyGroup(); CheckModificationStatus(); } void InstrumentManager::ModifyGroup() { TBDEBUG(__func__); InstrumentGroupIdentifier groupID = m_handler.GetInstrumentGroup().GetIdentifier(); std::vector<InstrumentParameterDefinition> defs; defs.push_back(instrument_parameters::UnderlyingInstrument()); InstrumentGroupParameters groupParams(groupID, defs); InstrumentIdentifier underlyingInstrument; groupParams.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingInstrument); InstrumentGroupParameters::Modifier modifier; if (underlyingInstrument.Empty()) { modifier.SetParameter(instrument_parameters::UnderlyingInstrument(), m_handler.GetUnderlyingInstrument()); } else { TBNOTICE(\"Not changing existing underlying instrument for group\"); } if (not modifier.Empty()) { Identifier id = InstrumentGroupParameters::SendModifyRequest(groupID, modifier, *this); m_groupModifyRequests.emplace(id, groupID); }<fim-suffix>{ TBDEBUG(__func__ << \" : \" << id); if (const auto it = m_instrumentModifyRequests.find(id); it not_eq m_instrumentModifyRequests.end()) { if (status not_eq Status::OK) { m_failed++; TBWARNING(\"Instrument modification failed for = \" << it->second << \", reason = \" << status_text); } else { TBDUMP(\"Instrument modified succesfully = \" << it->second); } m_instrumentModifyRequests.erase(it); } if (const auto it = m_groupModifyRequests.find(id); it not_eq m_groupModifyRequests.end()) { if (status not_eq Status::OK) { TBWARNING(\"Group modification failed<fim-middle>} void InstrumentManager::HandleRequestReply(const Identifier& id, class Status status, const String& status_text)"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n\nprotected:\n    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;\n    void HandleStreamClose(tbricks::TCPStream & stream) final;\n\n    void UpgradeWs();\n\nprivate:\n    std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept;\n\n    void ParseHttpReply(const tbricks::Binary & data);\n    std::size_t ReadWsReply(std::istream & data);\n    void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length);\n\nprivate:\n    IWebsocketHandler & m_handler;\n    tbricks::TCPStream m_tcp;\n    std::random_device m_rd;\n    std::shared_ptr<std::string> nonce_base64;\n<fim-suffix><fim-middle>    Config m_config;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)\n    {\n        strm << \"  subscription : \" << Resolve(subscription) << \"\\n\";\n    }\n    if (interval != DeribitInterval::NONE)\n    {\n        strm << \"  interval : \" << Resolve(interval) << \"\\n\";\n    }\n    strm << \"  channel : \" << channel << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nDeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type)\n    : m_handler(handler)\n    , m_timer(*this, \"deribit_refresh\")\n{\n    TBDEBUG(__func__ << \" : \" << endpoint);\n\n    std::string url(endpoint.GetCString());\n    auto found = url.find(\":\/\/\");\n    if (found != std::string::npos)\n    {\n        url = url.substr(found + 3);\n    }\n    m_session.host_port_path = url;\n\n    std::vector<String> slices;\n    m_session.host_port_path.Split(':', slices);\n    TBDUMP(slices);\n    switch (type)\n    {\n    case DeribitHost::NONE:\n        m_conf.header.insert({\"Host\", slices[0].GetCString()});\n        break;\n    default:\n        m_conf.header.insert({\"Host\", Resolve(type)});\n        break;\n    }\n}\n\nDeribitClient::~DeribitClient()\n{\n    TBDEBUG(__func__);\n    Disconnect();\n}\n\nvoid DeribitClient::Connect(const String & userId, const String & secret)\n{\n    TBDEBUG(__func__ << \" : userId=\" << userId << \" secret=\" << secret);\n    m_session.userId = userId;\n    m_session.secret = secret;\n<fim-suffix><fim-middle>    m_ws = std::make_unique<TbWebsocketClient>(*this, m_session.host_port_path, m_conf);\n    m_ws->Connect();\n}"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update &<fim-suffix><fim-middle>update) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <optional> struct DeribitInstrument { tbricks::String instrument_name; tbricks::String instrument_type; tbricks::String kind; tbricks::String settlement_currency; tbricks::String settlement_period; tbricks::String quote_currency; tbricks::String counter_currency; tbricks::String option_type; \/\/ \"call\" or \"put\" for options std::optional<tbricks::Double> strike; \/\/ Only for options tbricks::DateTime expiration_timestamp; tbricks::Double tick_size; tbricks::Double contract_size; tbricks::Boolean is_active; \/\/ Constructor that safely extracts data from rapidjson Value static std::optional<DeribitInstrument> FromJson(const rapidjson::Value& value) { DeribitInstrument data; \/\/ Required fields - if any of these are missing, return nullopt if (!value.HasMember(\"instrument_name\") || !value[\"instrument_name\"].IsString() || !value.HasMember(\"kind\") || !value[\"kind\"].IsString() || !value.HasMember(\"settlement_currency\") || !value[\"settlement_currency\"].IsString() || !value.HasMember(\"counter_currency\") || !value[\"counter_currency\"].IsString() || !value.HasMember(\"is_active\") || !value[\"is_active\"].IsBool()) { return std::nullopt; } data.instrument_name = value[\"instrument_name\"].GetString(); data.kind = value[\"kind\"].GetString(); data.settlement_currency = value[\"settlement_currency\"].GetString(); data.counter_currency = value[\"counter_currency\"].GetString(); data.is_active = value[\"is_active\"].GetBool(); \/\/ Optional fields - use safe accessors data.instrument_type = value.HasMember(\"instrument_type\") && value[\"instrument_type\"].IsString() ? value[\"instrument_type\"].GetString() : \"\"; data.quote_currency = value.HasMember(\"quote_currency\") && value[\"quote_currency\"].IsString() ? value[\"quote_currency\"].GetString() : \"\"; data.option_type = value.HasMember(\"option_type\") && value[\"option_type\"].IsString() ? value[\"option_type\"].GetString() : \"\"; data.settlement_period = value.HasMember(\"settlement_period\") && value[\"settlement_period\"].IsString() ? value[\"settlement_period\"].GetString() : \"\"; if (value.HasMember(\"strike\") && value[\"strike\"].IsNumber()) { data.strike = value[\"strike\"].GetDouble(); } \/\/ Convert timestamp to DateTime if (value.HasMember(\"expiration_timestamp\") && value[\"expiration_timestamp\"].IsUint64()) {<fim-suffix>} data.tick_size = value.HasMember(\"tick_size\") && value[\"tick_size\"].IsNumber() ? value[\"tick_size\"].GetDouble() : 0.0; data.contract_size = value.HasMember(\"contract_size\") && value[\"contract_size\"].IsNumber() ? value[\"contract_size\"].GetDouble() : 0.0; return data;<fim-middle>"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override;<fim-suffix>bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const<fim-middle>void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters:<fim-suffix><fim-middle>\" << parameters);"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\" #include \"shared\/order_minion\/OrderMinionCancelRequest.h\" #include \"shared\/order_minion\/tbricks_definitions.h\" #include \"shared\/sdk_definitions.h\" using namespace tbricks; namespace execution { TbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters) : OrderExecutor(handler) , m_controller( reason, app) { TBDEBUG(__func__); } TbOrderMinion::~TbOrderMinion() { TBDEBUG(__func__); DeleteOrders(); } void TbOrderMinion::CreateOrder( const InstrumentVenueIdentification& ivid, const Volume& volume, \/\/ negative for sell const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ <<<fim-suffix><fim-middle>\" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/VisualizationApp.h>\n#include <strategy\/visualization\/ViewModelUpdate.h>\n#include <strategy\/visualization\/ICellValue.h>\n#include <strategy\/visualization\/Grid.h>\n#include \"InstrumentManager.h\"\n#include \"TimerController.h\"\n\nclass InstrumentEnricherPlugin : public tbricks::VisualizationApp\n                               , public InstrumentManager::IHandler\n                               , public TimerController::IHandler\n\n{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n\n    void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel,\n                                  const tbricks::visualization::ViewModelUpdate & update) final;\n    void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel,\n                                  const tbricks::visualization::ViewModelUpdate & update) final;\n    void HandleStrategyViewDelete(tbricks::visualization::models::AppViewModel & viewModel) final { }\n    void HandleGridViewCreate(tbricks::visualization::models::GridViewModel & viewModel,\n                              const tbricks::visualization::ViewModelUpdate & update) final { }\n    void HandleGridViewUpdate(tbricks::visualization::models::GridViewModel & viewModel,\n                              const tbricks::visualization::ViewModelUpdate & update) final { }\n    void HandleImportComplete(const tbricks::String& status) final;\n    void HandleInstrumentManagerFailed(const tbricks::String& reason) final;\n    const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); }\n    const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); }\n<fim-suffix><fim-middle>    const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); }"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n<fim-suffix><fim-middle>    template <typename T>\n    void read(T & t)\n    {\n        if (eof())"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\"\n#include \"WingPreferencesStorage.h\"\n#include \"CCSPreferencesStorage.h\"\n#include \"SVIPreferencesStorage.h\"\n#include \"MyCustomPreferencesStorage.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n<fim-suffix><fim-middle>std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType)\n{\n    switch(volModelType)\n    {"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity)<fim-suffix><fim-middle>GREEK(asian_average_fix, Double, AsianAverageFix)"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\" #include \"shared\/order_minion\/OrderMinionCancelRequest.h\" #include \"shared\/order_minion\/tbricks_definitions.h\" #include \"shared\/sdk_definitions.h\" using namespace tbricks; namespace execution { TbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters) : OrderExecutor(handler) , m_controller( reason, app) { TBDEBUG(__func__); } TbOrderMinion::~TbOrderMinion() { TBDEBUG(__func__); DeleteOrders(); } void TbOrderMinion::CreateOrder( const InstrumentVenueIdentification& ivid, const Volume& volume, \/\/ negative for sell const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio); OrderMinionRequest req(this); req.SetExecution(enumerations::OrderMinionExecutionHitRepeatedly); req.SetIVID(ivid); req.SetMarketDataIVID(ivid); req.SetPortfolio(portfolio); req.SetSide((volume > 0.0 ? Side::BUY : Side::SELL)); req.SetVolume(volume.Abs()); req.SetPriceMode(enumerations::OrderMinionPrice::OrderMinionPriceBestPossible); auto result = m_controller.Request(req); if (result == OrderMinionController::FAILURE) { m_handler.PanicStop(result.GetError()); return; } m_requests[ivid]<fim-suffix>} void TbOrderMinion::DeleteOrders() { TBDEBUG(__func__); m_controller.Stop(); } void TbOrderMinion::MonitorInstrument(const InstrumentVenueIdentification &ivid) { m_controller.Prepare(ivid); } void TbOrderMinion::HandleOrderMinionUpdate( const OrderMinionUpdate& update ) { TBDEBUG(__func__ << \" : \" << update); if (update.DidFail()) { m_handler.PanicStop(update.GetError()); } else if (update.IsFinished()) { const auto& reqId = update.GetRequestID(); auto it = std::find_if(m_requests.begin(), m_requests.end(), [&reqId](const auto& req){ return req.second.GetRequestID() == reqId; }); if (it == m_requests.end()) { TBWARNING(\"Received update for unknown request\"); return; } TBDEBUG(\"Completed order for \" << it->second.GetIVID()); UpdateStats(update, it->second); m_requests.erase(it); } if (m_requests.empty()) { m_handler.AllDone(m_stats); } } void TbOrderMinion::UpdateStats(const OrderMinionUpdate& update, const OrderMinionRequest& request) { if (request.GetSide().IsBuy()) { m_stats.bought += update.GetFilledVolume();<fim-middle>= req;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h><fim-suffix>, public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;<fim-middle>class InstrumentManager : public tbricks::InstrumentStream::IHandler"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return false;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n<fim-suffix><fim-middle>    diagnostics.GetDebugStream() << std::endl;\n}"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n\n    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;\n\n    bool ParallelVerticalShift() const;\n\n    const InstrumentGroup & GetCurrentProductGroup() const { return m_instrumentGroup.GetInstrumentGroup(); }\n    const InstrumentGroup & GetReferenceInstrumentGroup() const { return m_refInstrumentGroup.GetInstrumentGroup(); }\n\n    const InstrumentIdentifier & GetFocusInstrumentIdentifier() const { return m_followedInstrumentId.GetInstrumentIdentifier(); }\n    const Integer & GetFocusInstrumentGroupType() const { return m_instrumentGroupType.GetInteger(); }\n\n    bool NoLayoutInterfaceMode() const { return !m_noLayoutInterfaceMode.Empty() && m_noLayoutInterfaceMode.GetBoolean(); }\n\n    bool GlobalAutoApplyManualFit() const { return !m_globalAutoApplyManualFit.Empty() && m_globalAutoApplyManualFit.GetBoolean(); }\n\n    bool GlobalAutoSuggest() const { return !m_globalAutoSuggest.Empty() && m_globalAutoSuggest.GetBoolean(); }\n\n    int CurveShiftUnits() const;\n\n    bool UseExoticOptions() const { return m_currentProductCommonValuesHandler.UseExoticOptions(); }\n    const CalculatedPropertyFilter & GetInstrumentFilter() const { return m_currentProductCommonValuesHandler.GetInstrumentFilter(); }\n\n    bool IsLiveFeedDisabled() const { return !m_disableLiveFeed.Empty() && m_disableLiveFeed.GetBoolean(); }\n\n    const Integer & GetForegroundCalculationThrottlingMilliseconds() { return m_calculationStreamThrottlingMilliseconds.GetInteger(); }\n\n    bool PreserveZooming() const { return !m_preserveZooming.Empty() && m_preserveZooming.GetBoolean(); }\n\n<fim-suffix><fim-middle>    bool SafetyCheckEnabled() const { return !m_volatilityCurveSafetyCheckEnabled.Empty() && m_volatilityCurveSafetyCheckEnabled.GetBoolean(); }"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\" #include \"ConstantVolatility.h\"<fim-suffix>#include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include<fim-middle>#include \"StochasticVolatilityInspired.h\""}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String&<fim-suffix><fim-middle>error);"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n<fim-suffix><fim-middle>void TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason<fim-suffix>\/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier();<fim-middle>& reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n<fim-suffix><fim-middle>public_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n{\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n\nprivate:\n    std::string_view type;\n};\n<fim-suffix><fim-middle>} \/\/ namespace deribit"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n<fim-suffix><fim-middle>    void SetHeartbeat(int seconds);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <deribit\/DeribitInstrument.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0; virtual void HandleInstrumentManagerReady() = 0; virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0; virtual void HandleInstrumentError(const tbricks::String & error) = 0; }; explicit InstrumentManager(IHandler & handler); ~InstrumentManager() override; \/\/ Add instruments from Deribit void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Core functionality void Start(); void SyncInstruments(); void Clear(); bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); } protected: \/\/ Common stream callbacks void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const<fim-suffix>void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ Instrument::Stream callbacks void HandleInstrument(const tbricks::StreamIdentifier & stream, const tbricks::Instrument & instrument) override; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier &<fim-middle>tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler {<fim-suffix><fim-middle>public: class IHandler"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\nprotected:\n    void HandleRunRequest() override;\n    void HandlePauseRequest() override;\n    void HandleDeleteRequest() override;\n    void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override;\n    void HandleValidateRequest(tbricks::ValidationContext & context) override;\n    void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override;\n    void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override;\n<fim-suffix><fim-middle>    void HandleDeribitConnected() override;\n    void HandleDeribitDisconnected() override;\n    void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel<fim-suffix><fim-middle>*> GetModel(const tbricks::InstrumentIdentifier & instrument);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n\npublic_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n{\n}\n\nheartbeat::heartbeat(JsonReply && base)\n    : JsonReply(std::move(base))\n    , type {Pointer(\"\/params\/type\").Get(msg)->GetString()}\n{\n}\n\nstd::string_view heartbeat::GetType() const\n{\n    return type;\n}\n\nbool heartbeat::IsTestRequest() const\n{\n    return type == \"test_request\" ? true : false;\n}\n\nsubscriptions::subscriptions(const std::string_view id, DeribitMethod method)\n    : JsonCall(id, method)\n{\n    auto & params = msg[\"params\"];\n    Value v(rapidjson::kArrayType);\n    params.AddMember(\"channels\", v, msg.GetAllocator());\n}\n\nvoid subscriptions::AddChannel(const std::string & channel)\n{\n    auto ptr = Pointer(\"\/params\/channels\");\n    if (ptr.IsValid())\n    {\n        Value ch;\n        ch.SetString(StringRef(channel.c_str(), channel.length()));\n        ptr.Get(msg)->PushBack(ch, msg.GetAllocator());\n    }\n}\n\nsubscriptions_reply::subscriptions_reply(JsonReply && base)\n    : JsonReply(std::move(base))\n{\n}\n\nstd::vector<std::string_view> subscriptions_reply::GetChannels() const\n<fim-suffix><fim-middle>{\n    auto array = msg[\"result\"].GetArray();\n    std::vector<std::string_view> out;\n    out.reserve(array.Size());"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const<fim-suffix>bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions<fim-middle>Error & GetError() const;"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h>\n#include <shared\/volatility\/ClampedCubicSpline.h>\n#include <shared\/volatility\/StochasticVolatilityInspired.h>\n#include <shared\/volatility\/WingVolatilityModel.h>\n\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypeRef>\nModelTypeRef vol_model_cast(volatility::IVolatilityModel & model);\n\ntemplate <class ModelTypeRef>\nModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model);\n\n#define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\\n    template <> \\\n    inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\\n    { \\\n        if (TB_UNLIKELY(!pModel)) { \\\n            return nullptr; \\\n        } \\\n        \\\n        if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\\n            TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\\n            throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\\n        } \\\n        \\\n        return reinterpret_cast<specifier volatility::model*>(pModel); \\\n    }\n\n#define VOL_MODEL_REF_CAST_IMPL(specifier, model, type) \\\n    template <> \\\n    inline specifier volatility::model & vol_model_cast(specifier volatility::IVolatilityModel & rModel) \\\n    { \\\n        if (TB_UNLIKELY(rModel.GetVolatilityModelType() != type)) { \\\n            TBWARNING(\"Detected attempt to cast volatility model of type \" << rModel.GetVolatilityModelType() << \" to type \" << type); \\\n            throw volatility::VolatilityModelTypeMismatchException(rModel.GetVolatilityModelType(), type); \\\n        } \\\n        \\\n        return reinterpret_cast<specifier volatility::model&>(rModel); \\\n    }\n\n#define VOL_MODEL_CAST_IMPL(specifier, model, type) \\\n    VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\\n    VOL_MODEL_REF_CAST_IMPL(specifier, model, type)\n\nVOL_MODEL_CAST_IMPL(const, ClampedCubicSpline, VolatilityModelCCS)\nVOL_MODEL_CAST_IMPL(, ClampedCubicSpline, VolatilityModelCCS)\nVOL_MODEL_CAST_IMPL(const, StochasticVolatilityInspired, VolatilityModelSVI)\nVOL_MODEL_CAST_IMPL(, StochasticVolatilityInspired, VolatilityModelSVI)\nVOL_MODEL_CAST_IMPL(const, WingVolatilityModel, VolatilityModelWing)\nVOL_MODEL_CAST_IMPL(, WingVolatilityModel, VolatilityModelWing)\n\n#undef VOL_MODEL_CAST_IMPL\n#undef VOL_MODEL_REF_CAST_IMPL\n#undef VOL_MODEL_PTR_CAST_IMPL\n<fim-suffix><fim-middle>#endif \/\/ TBRICKS_APPS_VOLATILITY_MANAGER_SHARED_TOOLS_VOLATILITY_MODEL_CAST_H"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <optional> struct DeribitInstrument { tbricks::String instrument_name; tbricks::String instrument_type; tbricks::String kind; tbricks::String settlement_currency; tbricks::String settlement_period; tbricks::String quote_currency; tbricks::String counter_currency; tbricks::String option_type; \/\/ \"call\" or \"put\" for options std::optional<tbricks::Double> strike; \/\/ Only for options tbricks::DateTime expiration_timestamp; tbricks::Double tick_size; tbricks::Double contract_size; tbricks::Boolean is_active; \/\/ Constructor that safely extracts data from rapidjson Value static std::optional<DeribitInstrument> FromJson(const rapidjson::Value& value) {<fim-suffix><fim-middle>DeribitInstrument data; \/\/ Required fields - if any of these are missing, return nullopt         if (!value.HasMember(\"instrument_name\") || !value[\"instrument_name\"].IsString() ||"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n<fim-suffix><fim-middle>using namespace tbricks;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n<fim-suffix><fim-middle>    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n\ntemplate <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);\n}\n\ntemplate <>\nBinary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)\n{\n    if (val.size() <= 0)\n        return ostm;\n\n    ostm.write(val.c_str(), val.size());\n\n    return ostm;\n}\n<fim-suffix><fim-middle>Binary_ostream & operator<<(Binary_ostream & ostm, const char * val)\n{\n    int size = std::strlen(val);\n    if (size <= 0)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2<fim-suffix>void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string,<fim-middle>for more information.     void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);"}
{"content":"<fim-prefix>#pragma once #include<fim-suffix>{ public: ExampleCalcAppPlugin(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; private: using<fim-middle>\"shared\/API.h\" class ExampleCalcAppPlugin : public tbricks::Pricing"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const<fim-suffix>const<fim-middle>double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE;"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) {<fim-suffix>TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status<fim-middle>TBDEBUG(__func__);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\" #include <third_party\/include\/rapidjson\/pointer.h> #include <algorithm> #define SET_STRING_VIEW(key, string) \\ auto & params = msg[\"params\"]; \\ Value v; \\ v.SetString(string.data(), string.size(), msg.GetAllocator()); \\ params.AddMember(#key, v, msg.GetAllocator()); #define SET_INTEGER(key, number) \\ auto & params = msg[\"params\"]; \\ Value v; \\ v.SetInt(number); \\ params.AddMember(#key, v, msg.GetAllocator()); namespace deribit { using namespace rapidjson; Json::Json() { msg.SetObject(); auto & allocator = msg.GetAllocator(); Value v; v.SetString(\"2.0\"); msg.AddMember(\"jsonrpc\", v, allocator); } Json::Json(Json && o) : msg(std::move(o.msg)) { } std::string_view Json::ToString() { buffer.Clear(); Writer<StringBuffer> writer(buffer); msg.Accept(writer); return {buffer.GetString()}; } std::string_view Json::GetId() { assert(msg[\"id\"].IsString()); return {msg[\"id\"].GetString()}; } void Json::Parse(std::string_view str) { msg.Clear(); StringStream s(str.data()); msg.ParseStream(s); } DeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods) { Parse(str); if (msg.HasMember(\"method\")) { std::string_view m(msg[\"method\"].GetString()); for (auto & method : methods) { if (method.second == m) { return method.first; } } } return DeribitMethod::NONE; } JsonCall::JsonCall(const std::string_view id, DeribitMethod method) : Json() { auto & allocator = msg.GetAllocator(); Value v; v.SetString(id.data(), id.size(), msg.GetAllocator()); msg.AddMember(\"id\", v, allocator); auto m = Resolve(method); v.SetString(m.data(), m.size(), msg.GetAllocator()); msg.AddMember(\"method\", v, allocator); v.Clear(); v.SetObject(); msg.AddMember(\"params\", v, allocator); } JsonReply::JsonReply(std::string_view json) : Json() { msg.Clear(); Parse(json); if (msg.HasMember(\"error\")) { isError = true; auto errp = Pointer(\"\/error\").Get(msg); if (errp->HasMember(\"code\")) { err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt(); } if (errp->HasMember(\"message\")) { err.message = Pointer(\"\/error\/message\").Get(msg)->GetString(); } if (errp->HasMember(\"data\")) { err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject()); } } auto test = msg.FindMember(\"testnet\"); if (test != msg.MemberEnd()) { isTest = test->value.GetBool(); } } JsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods) : JsonReply(json)<fim-suffix>{ std::string_view m(msg[\"method\"].GetString()); for (auto & method : methods) { if (method.second == m) { jrpcMethod =<fim-middle>{ if (msg.HasMember(\"method\"))"}
{"content":"<fim-prefix>#pragma once #include <third_party\/include\/rapidjson\/document.h> #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t); void OnHeartbeat(deribit::JsonReply && incoming); void OnTestReply(SingleTransaction & t); void OnSubscribeReply(SingleTransaction & t); void OnSubscriptionUpdate(deribit::JsonReply && incoming); void OnInstrumentDownload(SingleTransaction & t); private: SingleTransaction & NewTransaction(const tbricks::Identifier & uuid = tbricks::Uuid::Create()); protected: void PerformTransaction(SingleTransaction & t); private: IHandler & m_handler; std::unique_ptr<TbWebsocketClient> m_ws; TbWebsocketClient::Config m_conf; Session m_session; tbricks::Timer m_timer; std::vector<deribit::Method> m_availableMethods = deribit::GetAvailableMethods(); std::unordered_map<tbricks::Identifier, SingleTransaction, TbricksHash> m_transactions; std::unordered_map<Channel, Subscription> m_subscriptions;<fim-suffix><fim-middle>};"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution<fim-suffix>public tbricks::StrategyStream::IHandler, public tbricks::IRequestReplyHandler { public: TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app); ~TbChildOrder(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification&<fim-middle>{ class TbChildOrder : public OrderExecutor,"}
{"content":"<fim-prefix>#include \"TbOrderManager.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbOrderManager::TbOrderManager(IExecutionHandler& handler)\n: OrderExecutor(handler)\n{\n    TBDEBUG(__func__);\n}\n\nTbOrderManager::~TbOrderManager()\n{\n    TBDEBUG(__func__);\n    if (!m_orderData.empty())\n    {\n        DeleteOrders();\n    }\n}\n\nvoid TbOrderManager::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume, \/\/ negative for sell\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n\n    if (BestPrice bbo; m_md.GetBBO(ivid, bbo))\n    {\n        if (volume < 0.0 and bbo.HasBidPrice())\n        {\n            CreateSingleOrder(ivid, volume.Abs(), bbo.GetBidPrice(), Side::SELL, portfolio);\n        }\n        else if (volume > 0.0 and bbo.HasAskPrice())\n        {\n            CreateSingleOrder(ivid, volume.Abs(), bbo.GetAskPrice(), Side::BUY, portfolio);\n        }\n        else\n        {\n            TBWARNING(\"Missing price for \" << ivid);\n        }\n    }\n    else\n    {\n        m_md.Subscribe(ivid, this, TRACK_BBO);\n        m_orderQueue[ivid] = {ivid, volume, portfolio};\n        TBDEBUG(\"Waiting bbo for \" << ivid);\n    }\n}\n\nvoid TbOrderManager::DeleteOrders()\n{\n    TBDEBUG(__func__);\n    if (m_orderData.empty())\n    {\n        return;\n    }\n\n    for (Hash<OrderIdentifier, Order>::const_iterator it = m_orderData.begin(); it != m_orderData.end(); ++it)\n    {\n        DeleteSingleOrder(it->first);\n    }\n}\n\nvoid TbOrderManager::CreateSingleOrder(const InstrumentVenueIdentification& ivid, const Volume& volume, const Price& price, const Side& side, const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__);\n    TBDUMP(\"IVID=\" << ivid << \", vol=\" << volume << \", price=\" << price << \", side=\" << side << \", portfolio=\" << portfolio);\n    Order::Options orderOptions;\n    orderOptions.SetPortfolioIdentifier(portfolio);\n    orderOptions.SetValidity(Validity::VALID_IMMEDIATE);\n    orderOptions.SetInstrumentVenueIdentification(ivid);\n    orderOptions.SetActiveVolume(volume);\n    orderOptions.SetSide(side);\n    if (not price.Empty())\n    {\n        orderOptions.SetPrice(RoundPriceToTicks(price, side, ivid));\n    }\n    OrderCreateRequestResult req = OrderManager::SendCreateRequest(orderOptions, *this);\n    TBDUMP(\"Send order: \" << orderOptions);\n    m_requests[req.GetRequestIdentifier()] = req.GetOrderIdentifier();\n    m_activeOrders[ivid] = req.GetOrderIdentifier();\n}\n\nPrice TbOrderManager::RoundPriceToTicks(const Price& price, const Side& side, const InstrumentVenueIdentification& ivid)\n{\n    TBDEBUG(__func__ << \": price=\" << price << \", side=\" << side << \", ivid=\" << ivid);\n    InstrumentTradingInformation tick_rules(ivid);\n    if (tick_rules.Empty())\n    {\n        TBERROR(\"Unable to resolve Instrument trading information for instrument \"\n                << ivid.GetInstrumentIdentifier());\n        EmergencyStop();\n        return {};\n    }\n    return tick_rules.RoundPrice(side, price);\n}\n\nvoid TbOrderManager::HandleRequestReply(const Identifier& id, Status status, const String& status_text)\n{\n    TBDEBUG(\"Request status: \" << status << \". Reply from system: \" << status_text);\n    TBSTATUS(\"Request for order \" << m_requests[id]);\n\n    if (status == Status::FAIL)\n    {\n        TBERROR(\"HandleRequestReply error: \" << status_text);\n        DeleteSingleOrder(m_requests[id]);\n    }\n    m_requests.erase(id);\n}\n\nvoid TbOrderManager::HandleOrderUpdate(const Order::Update& update)\n{\n    TBDEBUG(__func__ << \" : \" << update);\n    auto& currentOrder = m_orderData[update.GetIdentifier()];\n    TBDUMP(\"m_orderData size: \" << m_orderData.size());\n\n    UpdateStats(update, currentOrder);\n\n    currentOrder.Merge(update);\n\n    Boolean deleted;\n    currentOrder.GetDeleted(deleted);\n    if (deleted.GetBool())\n    {\n        TBDEBUG(\"Order \" << currentOrder.GetIdentifier() << \" has been deleted\");\n        DeleteSingleOrder(currentOrder.GetIdentifier());\n    }\n\n    if (m_activeOrders.empty())\n    {\n        m_handler.AllDone(m_stats);\n    }\n}\n\nvoid TbOrderManager::HandleRecoveryCompleted()\n{\n    TBDEBUG(__func__);\n}\n\nvoid TbOrderManager::HandleBBOUpdate( const InstrumentVenueIdentification& ivid, const BestPrice& before, const BestPrice& change )\n{\n    TBDUMP(__func__ << \" : ivid=\" << ivid << \", before=\" << before << \", change=\" << change);\n\n    if (auto it = m_orderQueue.find(ivid); it != m_orderQueue.end())\n    {\n        auto& order = it->second;\n        bool sent = false;\n        if (order.volume > 0.0 and change.HasAskPrice())\n        {\n            CreateSingleOrder(ivid, order.volume.Abs(), change.GetAskPrice(), Side::BUY, order.portfolio);\n            sent = true;\n        }\n        else if (order.volume < 0.0 and change.HasBidPrice())\n        {\n            CreateSingleOrder(ivid, order.volume.Abs(), change.GetBidPrice(), Side::SELL, order.portfolio);\n            sent = true;\n        }\n        if (sent)\n        {\n            m_orderQueue.erase(it);\n        }\n    }\n}\n\nvoid TbOrderManager::HandleSnapshotEnd( const InstrumentVenueIdentification& ivid)\n{\n    TBDUMP(__func__ << \" : ivid=\" << ivid);\n<fim-suffix><fim-middle>    if (auto it = m_orderQueue.find(ivid); it != m_orderQueue.end())\n    {\n        auto& order = it->second;\n        bool sent = false;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String&<fim-suffix>}; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/<fim-middle>update, bool error) = 0;"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double<fim-suffix>double GetAskVolume(); }; } \/\/ deribit<fim-middle>GetBid(); double GetAsk(); double GetBidVolume();"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewUpdate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    auto it = update.begin();\n    while (it != update.end())\n    {\n        TBDUMP(it.GetCell().GetCalculatedProperty() << \" \" << it.GetCell().GetCellValue());\n\n        auto & calcProp = it.GetCell().GetCalculatedProperty().GetDefinition();\n        auto & cellValue = it.GetCell().GetCellValue();\n\n        if (calcProp == instrument_enricher::calculated_properties::strategy::ImportFrequency())\n        {\n            m_importFrequency = cellValue.GetDuration();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::InstrumentGroup())\n        {\n            m_instrumentGroup = cellValue.GetInstrumentGroupIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::UnderlyingInstrument())\n        {\n            m_underlyingInstrument = cellValue.GetInstrumentIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::StartTime())\n        {\n            m_startTime = cellValue.GetDateTime();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::MaturityDate())\n        {\n            m_maturityDate = cellValue.GetDateTime();\n        }\n\n        ++it;\n    }\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       m_importOnce = true;\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_instrumentsGrid.RemoveAllRows();\n        m_plugInStatusDescription.Clear();\n        m_timerController.Start();\n    }\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::Stop()\n{\n    TBDEBUG(__func__);\n<fim-suffix><fim-middle>    if (m_timerController.IsActive())\n    {\n        m_timerController.Stop();\n    }"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream)<fim-suffix><fim-middle>override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\nprotected:\n    void HandleRunRequest() override;\n    void HandlePauseRequest() override;\n    void HandleDeleteRequest() override;\n    void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override;\n    void HandleValidateRequest(tbricks::ValidationContext & context) override;\n    void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override;\n    void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override;\n\n<fim-suffix><fim-middle>    void HandleDeribitConnected() override;\n    void HandleDeribitDisconnected() override;\n    void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; explicit InstrumentManager(IHandler& handler); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler interface void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId, const tbricks::CalculatedInstrumentValues::Update & update) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final; private: void OpenInstrumentStream(); void OpenIAPStream(); void OpenCIVStream(); void EnrichInstruments(); void ModifyGroup(); void CheckResolutionStatus(); void CheckModificationStatus(); struct InstrumentDetails { tbricks::Instrument instrument; tbricks::DateTime maturityDate; tbricks::InstrumentIdentifier underlyingInstrument;<fim-suffix>}; using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier,<fim-middle>tbricks::Price underlyingPrice;"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing<fim-suffix>result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely<fim-middle>X parameter\"); else"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n<fim-suffix><fim-middle>const Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired) VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(None,ConstantVolatility)"}
{"content":"<fim-prefix>#pragma once\n#include <shared\/API.h>\n#include \"tbricks_definitions.h\"\n\nclass TimerController : public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual void HandleTimerEventHit() = 0;\n        virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0;\n    };\n<fim-suffix><fim-middle>    explicit TimerController(IHandler& handler);"}
{"content":"<fim-prefix>#include \"..\/..\/my_custom_pricing\/tbricks_definitions.h\" constexpr VolatilityModel<fim-suffix><fim-middle>VolatilityModelMyCustom = VolatilityModel(custom::pricing::extended_enums::VolatilityModelMyCustom);"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const<fim-suffix>protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String<fim-middle>std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n\npublic_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n{\n}\n\nheartbeat::heartbeat(JsonReply && base)\n    : JsonReply(std::move(base))\n    , type {Pointer(\"\/params\/type\").Get(msg)->GetString()}\n{\n}\n\nstd::string_view heartbeat::GetType() const\n{\n    return type;\n}\n\nbool heartbeat::IsTestRequest() const\n{\n    return type == \"test_request\" ? true : false;\n}\n\nsubscriptions::subscriptions(const std::string_view id, DeribitMethod method)\n    : JsonCall(id, method)\n<fim-suffix><fim-middle>{\n    auto & params = msg[\"params\"];\n    Value v(rapidjson::kArrayType);\n    params.AddMember(\"channels\", v, msg.GetAllocator());"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n<fim-suffix><fim-middle>{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char<fim-suffix><fim-middle>val) { ostm.write(&val, sizeof(char));"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto& msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } \\ EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price,<fim-suffix><fim-middle>0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0)"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>InstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())"}
{"content":"<fim-prefix>#include \"PositionReverser.h\" #include \"tbricks_definitions.h\" #include <cmath> using namespace tbricks; void PositionReverser::ReversePosition( const Position& position, const Price& atPrice) { Trade reversedTrade; Volume netPosition = position.GetNetPosition(); if (netPosition > 0) { reversedTrade.SetSide(Side::SELL); } else { reversedTrade.SetSide(Side::BUY); } reversedTrade.SetPrice(atPrice); reversedTrade.SetType(TradeType::POSITION_ADJUSTMENT); reversedTrade.SetCurrency(position.GetCurrency()); reversedTrade.SetClient(position.GetClient()); reversedTrade.SetVolume(std::fabs(position.GetNetPosition())); reversedTrade.SetCounterpart(position.GetCounterpart()); Trade::RequestResult reqCreate = Trade::SendCreateRequest(reversedTrade, *this); m_reversedPositions[reqCreate.GetRequestIdentifier()] = position.GetIdentifier(); TBDEBUG(\"Requested to reverse position: \" << position.GetIdentifier() << \" with trade: \" << reqCreate.GetTradeIdentifier()); } void PositionReverser::HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) { TBDEBUG(__func__ << \" \" << id << \" with status \" << status << \" \" << status_text); auto iterCreate = m_reversedPositions.find(id); bool isCreateRequest = (iterCreate != m_reversedPositions.end()); if (not isCreateRequest) { TBDEBUG(\"Received unknow request reply.\"); return; } if (status == Status::FAIL) { TBWARNING(\"Could not reverse position: \" << iterCreate->second << \" reason: \" << status_text); } else { TBDEBUG(\"Successfully reversed position: \" <<<fim-suffix>}<fim-middle>iterCreate->second); m_reversedPositions.erase(iterCreate);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitModel.h\"\n#include <shared\/API.h>\n\nclass DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler\n{\npublic:\n    DeribitMdp();\n    ~DeribitMdp() noexcept override = default;\n\nprotected:\n    void HandleSubscribe(tbricks::MarketDataItem & item) override;\n    void HandleUnsubscribe(tbricks::MarketDataItem & item) override;\n    void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override;\n    void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override;\n    bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override;\n    void GetDiagnostics(tbricks::Diagnostics & diagnostics) override;\n\n<fim-suffix><fim-middle>    void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamStale(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\"\n#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include \"execution\/TbOrderManager.h\"\n#include \"execution\/TbOrderMinion.h\"\n#include \"execution\/TbChildOrder.h\"\n\n#include <AsyncTask.h>\n#include <memory>\n\nusing namespace tbricks;\n\nnamespace sp = go_flat::strategy_parameters;\n\nGoFlatPlugin::GoFlatPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_portfolio(sp::Portfolio())\n    , m_statusText(sp::PlugInStatusDescription())\n    , m_executorType(execution::OrderExecutorType::ORDER_MANAGER)\n{\n    TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered());\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    switch (m_executorType)\n    {\n        case execution::OrderExecutorType::ORDER_MANAGER:\n            m_orders = std::make_unique<execution::TbOrderManager>(*this);\n            break;\n        case execution::OrderExecutorType::CHILD_ORDER:\n            m_orders = std::make_unique<execution::TbChildOrder>(*this, *this);\n            break;\n        case execution::OrderExecutorType::ORDER_MINION:\n            m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters);\n            break;\n    }\n\n    m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier());\n}\n\nvoid GoFlatPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n\n    if (not m_positions or m_positions->GetData().empty())\n    {\n        SetTransactionFail(\"No positions\", StrategyState::PAUSED);\n        return;\n    }\n    if (m_orders)\n    {\n        if (not m_positions->GetData().empty())\n        {\n            for (const auto& [ivid, pos] : m_positions->GetData())\n            {\n                if (m_executorType == execution::OrderExecutorType::ORDER_MINION)\n                {\n                    execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get());\n                    minion->MonitorInstrument(ivid);\n                }\n                TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos);\n                if (not pos.Empty() and pos != 0.0)\n<fim-suffix><fim-middle>                {\n                    m_orders->CreateOrder(ivid, -pos, m_portfolio.GetPortfolioIdentifier());\n                }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a<fim-suffix><fim-middle>message_size error code and the connection will be closed.         std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream {<fim-suffix><fim-middle>public: Binary_ostream() { }"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_importOnce(false)\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n<fim-suffix><fim-middle>    {\n        HandleRunRequest();\n    }\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nusing InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>;\nusing UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>;\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n\n    InstrumentManager(IHandler& handler);\n    ~InstrumentManager();\n    void Start();\n    void Stop();\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;\n\n    void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {};\n<fim-suffix><fim-middle>    void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID,\n                                             const tbricks::InstrumentIdentifier & instrumentID,\n                                             const tbricks::InstrumentAggregateParameters::Update & update) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public<fim-suffix><fim-middle>DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\"\n#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include \"execution\/TbOrderManager.h\"\n#include \"execution\/TbOrderMinion.h\"\n#include \"execution\/TbChildOrder.h\"\n\n#include <AsyncTask.h>\n#include <memory>\n\nusing namespace tbricks;\n\nnamespace sp = go_flat::strategy_parameters;\n\nGoFlatPlugin::GoFlatPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_portfolio(sp::Portfolio())\n    , m_statusText(sp::PlugInStatusDescription())\n    , m_executorType(execution::OrderExecutorType::ORDER_MANAGER)\n{\n    TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered());\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    switch (m_executorType)\n    {\n        case execution::OrderExecutorType::ORDER_MANAGER:\n            m_orders = std::make_unique<execution::TbOrderManager>(*this);\n            break;\n        case execution::OrderExecutorType::CHILD_ORDER:\n            m_orders = std::make_unique<execution::TbChildOrder>(*this, *this);\n            break;\n        case execution::OrderExecutorType::ORDER_MINION:\n            m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters);\n            break;\n    }\n\n    m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier());\n}\n\nvoid GoFlatPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n\n    if (not m_positions or m_positions->GetData().empty())\n    {\n        SetTransactionFail(\"No positions\", StrategyState::PAUSED);\n        return;\n    }\n    if (m_orders)\n    {\n        if (not m_positions->GetData().empty())\n        {\n            for (const auto& [ivid, pos] : m_positions->GetData())\n            {\n                if (m_executorType == execution::OrderExecutorType::ORDER_MINION)\n                {\n                    execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get());\n                    minion->MonitorInstrument(ivid);\n                }\n                TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos);\n                if (not pos.Empty() and pos != 0.0)\n                {\n                    m_orders->CreateOrder(ivid, -pos, m_portfolio.GetPortfolioIdentifier());\n                }\n            }\n            m_positions->Stop();\n            SetState(StrategyState::RUNNING);\n            return;\n        }\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid GoFlatPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_orders)\n    {\n        m_orders->DeleteOrders();\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid GoFlatPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_DELETE);\n    if (m_orders)\n    {\n        m_orders->DeleteOrders();\n    }\n    SetState(StrategyState::DELETED);\n}\n\nvoid GoFlatPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n<fim-suffix><fim-middle>{\n    TBSTATUS(\"Modify request: \" << modifier);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n<fim-suffix><fim-middle>{\n    SET_STRING_VIEW(client_secret, val);\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this)<fim-suffix><fim-middle>{ TBSTATUS(\"Constructor: \" << reason);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n<fim-suffix><fim-middle>        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> #include <shared\/volatility\/MyCustomVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility model types template <class ModelTypePtr> ModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel); template <class ModelTypePtr> ModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel); template <class ModelTypeRef> ModelTypeRef vol_model_cast(volatility::IVolatilityModel & model); template <class ModelTypeRef> ModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model); #define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\ { \\ if (TB_UNLIKELY(!pModel)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\ }<fim-suffix><fim-middle>\\ \\"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument); \/\/ app parameters tbricks::StringParameter m_clientID; tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint; std::unique_ptr<DeribitClient> m_client; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::DistributedValuesRequest> m_requestMap; tbricks::Set<tbricks::Identifier> m_supported_values; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::VenueInstrumentIdentifier> m_viidMap;<fim-suffix>};<fim-middle>tbricks::SparseHash<tbricks::String, tbricks::InstrumentIdentifier> m_symbolMap; tbricks::VenueIdentifier m_venueId {\"329eb436-9c38-11eb-b940-67d0e3a03b89\"};"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility model types template <class ModelTypePtr> ModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel); template <class ModelTypePtr> ModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel); template <class ModelTypeRef> ModelTypeRef vol_model_cast(volatility::IVolatilityModel & model); template <class ModelTypeRef> ModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model); #define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\ { \\ if (TB_UNLIKELY(!pModel)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model*>(pModel); \\ } #define VOL_MODEL_REF_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model & vol_model_cast(specifier volatility::IVolatilityModel & rModel) \\ { \\ if (TB_UNLIKELY(rModel.GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << rModel.GetVolatilityModelType()<fim-suffix>throw volatility::VolatilityModelTypeMismatchException(rModel.GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model&>(rModel); \\ } #define VOL_MODEL_CAST_IMPL(specifier, model, type) \\ VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ VOL_MODEL_REF_CAST_IMPL(specifier, model, type) VOL_MODEL_CAST_IMPL(const, ClampedCubicSpline, VolatilityModelCCS) VOL_MODEL_CAST_IMPL(, ClampedCubicSpline, VolatilityModelCCS) VOL_MODEL_CAST_IMPL(const, StochasticVolatilityInspired,<fim-middle><< \" to type \" << type); \\"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n<fim-suffix><fim-middle>private:\n    void OnLoginReply(SingleTransaction & t);\n    void OnSetHeartbeatReply(SingleTransaction & t);\n    void OnHeartbeat(deribit::JsonReply && incoming);"}
{"content":"<fim-prefix>#include \"Values.h\"\n#include \"ValuesRequest.h\"\n\nvoid ImpliedValue::Clear()\n{\n    implied_volatility.Clear();\n}\n\nstd::ostream & ImpliedValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"] \" << implied_volatility;\n    return strm;\n}\n\nFairPriceValue & FairPriceValue::operator += (const FairPriceValue & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.fair_price.Empty()) {\n        fair_price += fair_price_value.fair_price;\n    } else if (fair_price_value.fair_price.HasError()) {\n        fair_price.SetError(fair_price_value.fair_price.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue & FairPriceValue::operator += (const Double & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.Empty()) {\n        fair_price += fair_price_value;\n    } else if (fair_price_value.HasError()) {\n        fair_price.SetError(fair_price_value.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue FairPriceValue::operator * (const Double & mult) const\n{\n    FairPriceValue fair_price_value = *this;\n<fim-suffix><fim-middle>    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price_value.fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price_value.fair_price.SetError(mult.GetError());"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason &<fim-suffix>~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy<fim-middle>reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; }<fim-suffix>{ int size = std::strlen(val); if (size<fim-middle>Binary_ostream & operator<<(Binary_ostream & ostm, const char * val)"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);\n\n     if (id.second != m_tickerId)\n    {\n        TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);\n        return;\n    }\n\n<fim-suffix><fim-middle>    if (value.Empty() or (value == \"{}\") or value.HasError())\n    {\n        Price emptyPrice;\n        Volume emptyVolume {0};"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n\nUpdateData::~UpdateData()\n{\n    delete(m_doc);\n}\n\nstd::string_view UpdateData::ToString()\n{\n    m_doc->buffer.Clear();\n    Writer<StringBuffer> writer(m_doc->buffer);\n    m_doc->msg.Accept(writer);\n    return {m_doc->buffer.GetString()};\n}\n\nvoid UpdateData::Parse(const tbricks::String& str)\n{\n    m_doc->msg.Clear();\n    StringStream s(str.GetCString());\n    m_doc->msg.ParseStream(s);\n}\n\nticker_update::ticker_update(const tbricks::String& str)\n: UpdateData()\n{\n    Parse(str);\n}\n\nstd::string_view ticker_update::GetInstrumentName()\n{\n    auto& msg = m_doc->msg;\n    auto i = msg.FindMember(\"instrument_name\");\n    if (i != msg.MemberEnd())\n    {\n        return i->value.GetString();\n    }\n    return {};\n}\n<fim-suffix><fim-middle>int64_t ticker_update::GetTimestamp()\n{\n    auto& msg = m_doc->msg;\n    auto t = msg.FindMember(\"timestamp\");"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <deribit\/DeribitInstrument.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0; virtual void HandleInstrumentManagerReady() = 0; virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0; virtual void HandleInstrumentError(const tbricks::String & error) = 0; }; explicit InstrumentManager(IHandler & handler); ~InstrumentManager() override; \/\/ Add instruments from Deribit void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Core functionality void Start(); void SyncInstruments(); void Clear(); bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); } protected: \/\/ Common stream callbacks void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ Instrument::Stream callbacks void HandleInstrument(const tbricks::StreamIdentifier & stream, const tbricks::Instrument & instrument) override; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::InstrumentIdentifier & id) override; \/\/ IRequestReplyHandler callback void HandleRequestReply(const tbricks::Identifier & request_id,<fim-suffix>const tbricks::String & status_text) override; private: \/\/ Helper functions void OpenInstrumentStream(); static tbricks::String GetInstrumentKey(const tbricks::Instrument & instrument); static tbricks::String GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument); void CreateInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); void ModifyInstrument(const tbricks::Instrument& instrument, const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Data storage std::map<tbricks::String, tbricks::Instrument> m_tbricksInstruments;<fim-middle>tbricks::Status status,"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \", item = \" << item);\n}"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)\n    {\n        HandleTickerUpdate(ticker, \"{}\");\n    }\n    SetState(StrategyState::PAUSED);\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp>\n#include <shared\/SuppressSfApiClangWarnings.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/Price.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/Boolean.h>\n#include <strategy\/calculated_property\/CalculatedPropertyFilter.h>\n#include <strategy\/TreeNodeParameters.h>\n#include <strategy\/parameter\/StrategyParameters.h>\n#include <strategy\/parameter\/StrategyInstanceParameters.h>\nCLANG_RESTORE_WARNINGS\n#include <set>\n\nusing namespace tbricks;\n\nenum class PreferencesStorageKind\n{\n    Common = 0,\n    Wing,\n    CCS,\n    SVI\n};\n\nstd::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind);\n\n\/**\n * Struct representing the various settings common to all VMs; it is subclassed by structs\n * containing additional parameters relevant for particular VMs\n *\/\nclass PreferencesStorage: public Printable\n{\npublic:\n    PreferencesStorage();\n\nprotected:\n    PreferencesStorage(const PreferencesStorage & storage) = default;\n    PreferencesStorage & operator=(const PreferencesStorage & storage) = default;\n\npublic:\n    virtual ~PreferencesStorage();\n<fim-suffix><fim-middle>    virtual PreferencesStorageKind GetKind() const = 0;"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor)<fim-suffix>GREEK(opening_skew_charm, Double, OpeningSkewCharm)<fim-middle>GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm)"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n<fim-suffix><fim-middle>    ret.reset(m_volatility_model->Clone());"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n<fim-suffix><fim-middle>#define MAX_INSTRUMENTS 10"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\"\n#include \"tbricks_definitions.h\"\n#include <cstdlib>\n#include <set>\n\nusing namespace tbricks;\n\nExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request)\n: Pricing(request)\n{\n    srand (time(NULL)); \/\/ Initialize random seed.\n<fim-suffix><fim-middle>    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n    SnapshotDone();"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    TBSTATUS(\"Subscribing to ticker: \" << id);\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n    {\n        TBWARNING(\"Received unknown instrument ticker: \" << ticker);\n        return;\n    }\n    auto request = m_requestMap.find(id);\n    if (request != m_requestMap.end())\n    {\n        for (const auto & object : request->second.GetObjects())\n        {\n            InstrumentIdentifier instrument;\n            object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrument);\n            if (instrument == id)\n            {\n                for (const auto & value : request->second.GetValues())\n<fim-suffix><fim-middle>                {\n                    if (value.GetDefinition() == dv::DeribitTicker())\n                    {\n                        String data(json.data(), json.size());"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) NAMESPACE_PATH_GREEK(param_1, Double, Param1, custom::pricing::calculated_values) NAMESPACE_PATH_GREEK(param_2, Double, Param2, custom::pricing::calculated_values) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate) HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight) HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight) HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price, Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed) VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double, NextDividend) VALUE(next_dividend_date, Date, NextDividendDate) VALUE(underlying_settlement_date, Date, UnderlyingSettlementDateUsed) VALUE(final_settlement_date, Date, FinalSettlementDateUsed) VALUE(next_call_put_date, DateTime, NextCall_DIV_PutDate) VALUE(days_to_next_dividend, Integer, DaysToNextDividend) VALUE(trading_days_to_next_dividend, Integer, TradingDaysToNextDividend) VALUE(days_to_maturity, Integer, DaysToMaturity) VALUE(time_to_next_dividend, Double, TimeToNextDividend) VALUE(months_to_maturity, Double, MonthsToMaturity) VALUE(years_to_maturity, Double, YearsToMaturity) VALUE(longest_days_to_maturity, Integer, LongestDaysToMaturity)<fim-suffix>VALUE(longest_years_to_maturity, Double, LongestYearsToMaturity) VALUE(vol_days_to_maturity, Integer, VolatilityDaysToMaturity) VALUE(rate_days_to_maturity, Integer, RateDaysToMaturity) VALUE(expiration_time, Double, ExpirationTime) VALUE(rate_time, Double, RateTime) VALUE(volatility_time, Double, VolatilityTime) VALUE(rate, Double, FinancingRate) VALUE(rate_discount, Double, DiscountingRate) VALUE(present_value_adjustment_factor, Double, PresentValueAdjustmentFactor) VALUE(overnight_financing_factor, Double, OvernightFinancingFactor) VALUE(single_underlying, Boolean, SingleUnderlying) VALUE(version, Integer, ParameterVersion) VALUE(volatility_settings_changeset_used_1, Integer, VolatilitySettingsChangesetUsed1) VALUE(volatility_settings_changeset_used_2,<fim-middle>VALUE(longest_months_to_maturity, Double, LongestMonthsToMaturity)"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\" #include \"tbricks_definitions.h\" #include <cstdlib> #include <set> using namespace tbricks; ExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest&<fim-suffix><fim-middle>request) : Pricing(request) {"}
{"content":"<fim-prefix>#ifndef TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H #define TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H \/** * This file is intended to introduce definitions of the customized metadata * items like instrument parameters or calculated values that are not supported * in the original version of the Pricing app. * *<fim-suffix><fim-middle>The following inclusion statement assumes tbricks_definitions.h was generated"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include<fim-suffix>using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\<fim-middle>\"ConstantVolatility.h\" using namespace tbricks;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit {<fim-suffix>virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply<fim-middle>class Json { public:"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \": \" << context);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) {<fim-suffix>return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume {0}; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail() { InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo);<fim-middle>iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\");"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble();<fim-suffix>return default; \\ } EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest,<fim-middle>\\ } \\"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); }<fim-suffix>{ if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename T> void write(const T & t) { tbricks::Binary vec; vec.Set(reinterpret_cast<const void *>(&t), sizeof(T)); write(vec);<fim-middle>void read(char * p, size_t size)"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out)<fim-suffix><fim-middle>{ out = m_data;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string<fim-suffix>}; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void<fim-middle>proxy_auth; unsigned short default_port = 80;"}
{"content":"<fim-prefix>#pragma once #include<fim-suffix>#include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case<fim-middle><string> #include <string_view>"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n<fim-suffix><fim-middle>    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename T> void write(const T<fim-suffix>vec.Set(reinterpret_cast<const void *>(&t), sizeof(T)); write(vec); } void write(const std::string & s) { write(s.c_str(), s.size()); } void write(const char * p, size_t<fim-middle>& t) { tbricks::Binary vec;"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n<fim-suffix><fim-middle>enum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { \/\/ Here is where we would open the DistributedValues::Stream<fim-suffix><fim-middle>} void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler, public InstrumentManager::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override;<fim-suffix><fim-middle>void HandleInstrumentDownload(const rapidjson::Value & instruments) override;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply()<fim-suffix>JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id);<fim-middle>= default;"}
{"content":"<fim-prefix>#include \"Values.h\"\n#include \"ValuesRequest.h\"\n\nvoid ImpliedValue::Clear()\n{\n    implied_volatility.Clear();\n}\n\nstd::ostream & ImpliedValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"] \" << implied_volatility;\n    return strm;\n}\n\nFairPriceValue & FairPriceValue::operator += (const FairPriceValue & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.fair_price.Empty()) {\n        fair_price += fair_price_value.fair_price;\n    } else if (fair_price_value.fair_price.HasError()) {\n        fair_price.SetError(fair_price_value.fair_price.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue & FairPriceValue::operator += (const Double & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.Empty()) {\n        fair_price += fair_price_value;\n    } else if (fair_price_value.HasError()) {\n        fair_price.SetError(fair_price_value.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue FairPriceValue::operator * (const Double & mult) const\n{\n    FairPriceValue fair_price_value = *this;\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price_value.fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price_value.fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price_value.fair_price.Clear();\n    }\n    return fair_price_value;\n}\n\nFairPriceValue & FairPriceValue::operator *= (const Double & mult)\n{\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nvoid FairPriceValue::Clear()\n{\n    fair_price.Clear();\n}\n\nbool FairPriceValue::SetError(const String & error)\n{\n    if (error == fair_price.GetError()) {\n        return false;\n    }\n\n    fair_price.SetError(error);\n    return true;\n}\n\nstd::ostream & FairPriceValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"]\" << fair_price;\n    return strm;\n}\n\nGreeks & Greeks::operator += (const Greeks & greeks)\n{\n#define TB_GREEKS_ADD(value) \\\n    if (!value.Empty() && !greeks.value.Empty()) { \\\n        value += greeks.value; \\\n    } else if (greeks.value.HasError()) { \\\n        value.SetError(greeks.value.GetError()); \\\n    } else if (!value.HasError()) { \\\n        value.Clear(); \\\n    }\n\n    TB_GREEKS_ADD(delta)\n    TB_GREEKS_ADD(gamma)\n    TB_GREEKS_ADD(option_equivalent_gamma)\n    TB_GREEKS_ADD(vega)\n    TB_GREEKS_ADD(option_equivalent_vega)\n    TB_GREEKS_ADD(rho)\n    TB_GREEKS_ADD(rho_discounting)\n    TB_GREEKS_ADD(vanna)\n    TB_GREEKS_ADD(vomma)\n    TB_GREEKS_ADD(skew_delta)\n    TB_GREEKS_ADD(skew_gamma)\n    TB_GREEKS_ADD(calendar_theta)\n    TB_GREEKS_ADD(volatility_theta)\n    TB_GREEKS_ADD(rate_theta)\n    TB_GREEKS_ADD(calendar_charm)\n    TB_GREEKS_ADD(calendar_skew_charm)\n    TB_GREEKS_ADD(calendar_color)\n    TB_GREEKS_ADD(opening_theta)\n    TB_GREEKS_ADD(opening_charm)\n    TB_GREEKS_ADD(opening_skew_charm)\n    TB_GREEKS_ADD(opening_color)\n    TB_GREEKS_ADD(overnight_theta)\n    TB_GREEKS_ADD(overnight_charm)\n    TB_GREEKS_ADD(overnight_skew_charm)\n    TB_GREEKS_ADD(overnight_color)\n    TB_GREEKS_ADD(delta_ytm)\n    TB_GREEKS_ADD(gamma_ytm)\n    TB_GREEKS_ADD(fair_ytm)\n    TB_GREEKS_ADD(divit)\n    TB_GREEKS_ADD(speed)\n    TB_GREEKS_ADD(skew_speed)\n    TB_GREEKS_ADD(zomma)\n    TB_GREEKS_ADD(wing_slope_sensitivity)\n    TB_GREEKS_ADD(wing_call_curvature_sensitivity)\n    TB_GREEKS_ADD(wing_put_curvature_sensitivity)\n    TB_GREEKS_ADD(ccs_left_slope_sensitivity)\n    TB_GREEKS_ADD(ccs_right_slope_sensitivity)\n    TB_GREEKS_ADD(equity_leg_override_price)\n    TB_GREEKS_ADD(dividend_equivalent_yield)\n    TB_GREEKS_ADD(tenor_rate_sensitivity)\n    TB_GREEKS_ADD(bond_duration)\n    TB_GREEKS_ADD(bond_dv01)\n    TB_GREEKS_ADD(cash_delta_base)\n    TB_GREEKS_ADD(cash_gamma_base)\n    TB_GREEKS_ADD(cash_vega_base)\n\n#undef TB_GREEKS_ADD\n\n    return *this;\n}\n\nGreeks Greeks::operator * (const Double & mult) const\n{\n    Greeks greeks = *this;\n    greeks *= mult;\n    return greeks;\n}\n\nGreeks & Greeks::operator *= (const Double & mult)\n{\n#define TB_GREEKS_MULT(value) \\\n    if (!value.Empty() && !mult.Empty()) { \\\n        value *= mult; \\\n<fim-suffix><fim-middle>    } else if (mult.HasError()) { \\\n        value.SetError(mult.GetError()); \\\n    } else if (!value.HasError()) { \\\n        value.Clear(); \\"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n<fim-suffix><fim-middle>void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from = \" <<<fim-suffix>return std::move(sstrm).str(); } public: BadPreferencesStorageCast(const PreferencesStorageKind from, const PreferencesStorageKind to) : Exception(PreferenceKindsToString(from, to)) {} }; template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage); template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage); #define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\ { \\ if (TB_UNLIKELY(!pPreferencesStorage)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY((pPreferencesStorage->GetKind()<fim-middle>from << \", to = \" << to;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nDeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type)\n    : m_handler(handler)\n    , m_timer(*this, \"deribit_refresh\")\n{\n    TBDEBUG(__func__ << \" : \" << endpoint);\n\n    std::string url(endpoint.GetCString());\n    auto found = url.find(\":\/\/\");\n    if (found != std::string::npos)\n    {\n        url = url.substr(found + 3);\n    }\n    m_session.host_port_path = url;\n\n    std::vector<String> slices;\n    m_session.host_port_path.Split(':', slices);\n    TBDUMP(slices);\n    switch (type)\n    {\n    case DeribitHost::NONE:\n        m_conf.header.insert({\"Host\", slices[0].GetCString()});\n        break;\n    default:\n        m_conf.header.insert({\"Host\", Resolve(type)});\n        break;\n    }\n}\n\nDeribitClient::~DeribitClient()\n{\n    TBDEBUG(__func__);\n    Disconnect();\n}\n<fim-suffix><fim-middle>void DeribitClient::Connect(const String & userId, const String & secret)\n{\n    TBDEBUG(__func__ << \" : userId=\" << userId << \" secret=\" << secret);\n    m_session.userId = userId;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionRetriever : public tbricks::PositionStream::IHandler { public: class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId); void Stop(); \/\/ Common Stream methods void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final; void HandleStreamStale(const tbricks::StreamIdentifier &stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier &stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier &stream) final; \/** * PositionStream::IHandler *\/ void HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) final; void HandlePositionInvalidate( const tbricks::StreamIdentifier & stream_id,<fim-suffix>private: IHandler& m_callback; tbricks::PositionStream m_positionStream; bool m_wasStreamStale{false}; std::map<tbricks::Identifier, tbricks::Position> m_positions; }; class PositionRetriever::IHandler { public: virtual void HandleError(const tbricks::String& error) = 0; virtual void HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions) = 0; };<fim-middle>const tbricks::Identifier & id) final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final {} void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup; } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument; } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate; } private: bool CheckRunningRequirement();<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model =<fim-suffix>} } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \"<fim-middle>*model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitModel.h\"\n#include <shared\/API.h>\n\nclass DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler\n{\npublic:\n    DeribitMdp();\n    ~DeribitMdp() noexcept override = default;\n\nprotected:\n<fim-suffix><fim-middle>    void HandleSubscribe(tbricks::MarketDataItem & item) override;\n    void HandleUnsubscribe(tbricks::MarketDataItem & item) override;\n    void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override;"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return<fim-suffix>} } enum class DeribitInterval { NONE, SUB_100, SUB_RAW<fim-middle>\"ticker\"; default: return {};"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield,<fim-suffix><fim-middle>Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity)"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n<fim-suffix><fim-middle>        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->Reset();\n    }\n    else\n<fim-suffix><fim-middle>    {\n        TBDEBUG(\"Unknown stream\");\n    }\n}"}
{"content":"<fim-prefix>#pragma once #include <strategy\/EventProcessor.h> #include <future> namespace misc { class AsyncProcessor { private: const tbricks::EventProcessor& m_proc; tbricks::StrategyIdentifier m_id; std::string m_result; public: AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc), m_id(appId) {}; void DoAsync() { std::thread([this]{ std::this_thread::sleep_for(std::chrono::seconds(3)); m_result = \"ASYNC SUCCESS\"; tbricks::UserData payload; payload.Set(&m_result, 0); \/\/ we can do shallow copy because the string is a member variable m_proc.ScheduleStrategyEvent(m_id, payload); }).detach(); } bool HasResult() const {<fim-suffix>const<fim-middle>return not m_result.empty(); }"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double,<fim-suffix>GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double,<fim-middle>Vomma) GREEK(skew_delta, Double, SkewDelta)"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status =<fim-suffix>} m_handler.HandleTimerControllerUpdate(status, \/*error =*\/ false); } void<fim-middle>\"Timer started, starts \" + m_startTime.ToString() + \", repeats \" + m_frequency.ToString();"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) NAMESPACE_PATH_GREEK(param_1, Double, Param1, custom::pricing::calculated_values) NAMESPACE_PATH_GREEK(param_2, Double, Param2, custom::pricing::calculated_values) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate) HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight) HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight) HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price, Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed) VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double, NextDividend) VALUE(next_dividend_date, Date, NextDividendDate) VALUE(underlying_settlement_date, Date, UnderlyingSettlementDateUsed) VALUE(final_settlement_date, Date, FinalSettlementDateUsed) VALUE(next_call_put_date, DateTime, NextCall_DIV_PutDate) VALUE(days_to_next_dividend, Integer, DaysToNextDividend) VALUE(trading_days_to_next_dividend, Integer, TradingDaysToNextDividend) VALUE(days_to_maturity, Integer, DaysToMaturity) VALUE(time_to_next_dividend, Double, TimeToNextDividend) VALUE(months_to_maturity, Double, MonthsToMaturity) VALUE(years_to_maturity, Double, YearsToMaturity) VALUE(longest_days_to_maturity, Integer, LongestDaysToMaturity) VALUE(longest_months_to_maturity, Double, LongestMonthsToMaturity) VALUE(longest_years_to_maturity, Double, LongestYearsToMaturity) VALUE(vol_days_to_maturity, Integer, VolatilityDaysToMaturity) VALUE(rate_days_to_maturity, Integer, RateDaysToMaturity) VALUE(expiration_time, Double, ExpirationTime) VALUE(rate_time, Double, RateTime) VALUE(volatility_time, Double, VolatilityTime) VALUE(rate, Double, FinancingRate) VALUE(rate_discount, Double, DiscountingRate) VALUE(present_value_adjustment_factor, Double, PresentValueAdjustmentFactor) VALUE(overnight_financing_factor, Double, OvernightFinancingFactor) VALUE(single_underlying, Boolean, SingleUnderlying) VALUE(version, Integer, ParameterVersion) VALUE(volatility_settings_changeset_used_1, Integer, VolatilitySettingsChangesetUsed1) VALUE(volatility_settings_changeset_used_2, Integer, VolatilitySettingsChangesetUsed2) VALUE(pricing_model_used, Integer, PricingModelUsed) VALUE(valuation_price_source_used, Integer, ValuationPriceSourceUsed) VALUE(accrued_interest, Price, AccruedInterest) VALUE(sink_factor, Double, SinkFactor) VALUE(rate_amount, Double, RateAmount) VALUE(ytm, Double, YTM) VALUE(volatility_model_used, Integer, VolatilityModelUsed) VALUE(solver_precision_setting_used, Integer, SolverPrecisionSettingUsed) VALUE(intrinsic_value, Double, IntrinsicValue) VALUE(valid_until, DateTime, ExternalValidUntil) VALUE(last_update_timestamp, DateTime, ExternalLastUpdated)<fim-suffix><fim-middle>VALUE(external_value_highlight, Integer, ExternalPricingHighlighting)"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\ntypedef std::pair<DeribitMethod, std::string> Method;\n\nstatic std::vector<Method> GetAvailableMethods()\n{\n    return {\n            {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)},\n            {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)},\n            {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)},\n            {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)},\n            {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)},\n            {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)},\n            {DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)},\n<fim-suffix><fim-middle>            {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)},\n            {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}};\n}"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class InstrumentEnricherPlugin : public tbricks::Strategy { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason,<fim-suffix>\/\/<fim-middle>const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n<fim-suffix><fim-middle>    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n<fim-suffix><fim-middle>using namespace tbricks;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept<fim-suffix><fim-middle>override = default; protected:"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const<fim-suffix>void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct<fim-middle>tbricks::String & error) final;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit<fim-suffix><fim-middle>{ struct RapidDocument;"}
{"content":"<fim-prefix>#include <strategy\/type\/InstrumentIdentifier.h>\n#include <strategy\/type\/InstrumentGroupIdentifier.h>\n#include <strategy\/instrument\/InstrumentGroupAggregateParameters.h>\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/stream\/PositionStream.h>\n#include <shared\/Macros.h>\n#include <shared\/VersionTracker.hpp>\n#include <shared\/volatility\/InterpolatedVolatilityModel.h>\n#include <shared\/Comparators.h>\n#include <shared\/smart_pointers\/SharedPointer.hpp>\n#include <shared\/smart_pointers\/WeakPointer.hpp>\n#include <shared\/sdk_definitions.h>\n#include <shared\/metaprogramming\/Badge.hpp>\n#include <bitset>\n#include \"UnderlyingTickRules.h\"\n#include \"..\/VolatilitySurfaceSubscriptionManager.h\"\n#include \"..\/plotting\/ZoomingSettings.h\"\n#include \"..\/historical_data_analysis\/ICalculationStreamWrapper.h\"\n#include \"..\/VolatilityPointsCollector.h\"\n\nTB_FORWARD_DECLARE_CLASS(InstrumentVolatilityData);\nclass ProductGroupCache;\n\nclass MaturityData\n{\npublic:\n    class IProvider\n    {\n    public:\n        virtual const InstrumentGroupIdentifier & GetProductGroupId() const = 0;\n        virtual void GetInstrumentVolatilityDataForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 std::vector<const InstrumentVolatilityData*> & data) const = 0;\n        virtual bool GetStrikeRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId, Price & minStrike,\n                                                    Price & maxStrike, const Price & strikeThreshold) const = 0;\n        virtual bool GetStrikesWithImpliedsRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 Price & minStrike, Price & maxStrike,\n                                                                 const Price & strikeThreshold) const = 0;\n        virtual const VolatilityModel GetVolatilityModelType() const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const InstrumentGroupIdentifier & groupId) const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const DateTime & maturityDate) const = 0;\n        virtual const TickRule * GetUnderlyingInstrumentTickRule(const InstrumentIdentifier & underlyingId) const = 0;\n        virtual std::pair<const MaturityData*,const MaturityData*> GetNeighboringMaturityData(const DateTime & maturityDate) const = 0;\n        virtual const MaturityData * FindMaturityData(const DateTime & maturityDate) const = 0;\n\n        virtual std::vector<InstrumentParameterDefinition> & GetVolatilitySurfaceTableDefinitionsMemCache() const = 0;\n\n        virtual const std::pair<DateTime, DateTime> & GetSampleDateTimePair() const = 0;\n\n        virtual const DateTime & GetValuationDate() const = 0;\n\n        virtual const Identifier & GetTargetContextId() const = 0;\n\n        virtual ~IProvider() {}\n    };\n\n    typedef VolatilitySurfaceSubscriptionManager::VolatilitySurfaceData     VolatilitySurfaceData;\n    typedef VolatilitySurfaceSubscriptionManager::VolatilitySurfaceDataPtr  VolatilitySurfaceDataPtr;\n\n    typedef smart_pointers::SharedPointer<volatility::IVolatilityModel> VolatilityModelPtr;\n    typedef smart_pointers::WeakPointer<const volatility::IVolatilityModel> VolatilityModelConstWeakPtr;\n\n    typedef smart_pointers::SharedPointer<InstrumentGroupAggregateParametersStream> InstrumentGroupParametersStreamPtr;\n    typedef smart_pointers::SharedPointer<ICalculationStreamWrapper> CalculationStreamWrapperPtr;\n    typedef smart_pointers::SharedPointer<PositionStream> PositionStreamPtr;\n\npublic:\n    MaturityData(const IProvider & manager,\n                 const InstrumentGroupIdentifier & groupId = InstrumentGroupIdentifier(),\n                 const DateTime & maturityDate = DateTime(),\n                 const String & groupName = String());\n    MaturityData(MaturityData && maturityData) = default;\n    ~MaturityData();\n\n    String GetName() const;\n\n    const String & GetGroupName() const { return m_groupName; }\n    void SetGroupName(const String & groupName) { m_groupName = groupName; }\n\n    const InstrumentGroupIdentifier & GetGroupIdentifier() const { return m_groupId; }\n    void SetGroupIdentifier(const InstrumentGroupIdentifier & groupId) { m_groupId = groupId; }\n<fim-suffix><fim-middle>    const InstrumentGroupIdentifier & GetProductGroupIdentifier() const { return m_provider.GetProductGroupId(); }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor :<fim-suffix><fim-middle>public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler"}
{"content":"<fim-prefix>#include \"..\/..\/my_custom_pricing\/tbricks_definitions.h\" constexpr VolatilityModel VolatilityModelMyCustom =<fim-suffix><fim-middle>VolatilityModel(custom::pricing::extended_enums::VolatilityModelMyCustom); #endif \/\/ TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class<fim-suffix><fim-middle>DeribitMdp : public tbricks::MarketDataProvider"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n<fim-suffix><fim-middle>{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return<fim-suffix>const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } private: bool CheckRunningRequirement(); \/\/ app parameters tbricks::InstrumentGroupParameter m_instrumentGroup;<fim-middle>m_instrumentGroup.GetInstrumentGroup(); }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status,<fim-suffix><fim-middle>const std::string & reason = \"\");"}
{"content":"<fim-prefix>#pragma once #include <strategy\/EventProcessor.h> #include <future> namespace misc { class AsyncProcessor { private: const tbricks::EventProcessor& m_proc;<fim-suffix>std::string m_result; public: AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc), m_id(appId) {}; void DoAsync() { std::thread([this]{ std::this_thread::sleep_for(std::chrono::seconds(3)); m_result =<fim-middle>tbricks::StrategyIdentifier m_id;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n<fim-suffix><fim-middle>    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n<fim-suffix><fim-middle>    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n<fim-suffix><fim-middle>    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include \"shared\/app\/app.h\"\nCLANG_RESTORE_WARNINGS\n\n#include <limits>\n\nusing namespace tbricks;\n\nclass ValuesRequest;\n\nstruct ImpliedValue\n{\n    void Clear();\n\n    friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value)\n    { return value.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    Double implied_volatility;\n};\n\nstruct FairPriceValue\n<fim-suffix><fim-middle>{\n    FairPriceValue & operator += (const FairPriceValue & fair_price_value);\n    FairPriceValue & operator += (const Double & value);\n    FairPriceValue   operator *  (const Double & mult) const;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument); private: std::map<tbricks::StreamIdentifier, tbricks::InstrumentIdentifier> m_streams; std::map<tbricks::InstrumentIdentifier,<fim-middle>tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return false; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } }<fim-suffix>DEFINE_STRATEGY_ENTRY(DeribitMdp)<fim-middle>diagnostics.GetDebugStream() << std::endl; }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler<fim-suffix>virtual void HandleTimerEventHit() = 0; virtual<fim-middle>{ public: virtual ~IHandler() = default;"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\" SUPPRESS_SF_API_CLANG_WARNINGS #include \"shared\/app\/app.h\" CLANG_RESTORE_WARNINGS #include <limits> using namespace tbricks; class ValuesRequest; struct ImpliedValue { void Clear(); friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value) { return value.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double implied_volatility; }; struct FairPriceValue { FairPriceValue & operator += (const FairPriceValue & fair_price_value); FairPriceValue & operator += (const Double & value); FairPriceValue operator * (const Double & mult) const; FairPriceValue & operator *= (const Double & mult); void Clear(); bool SetError(const String & error); friend std::ostream & operator << (std::ostream & strm, const FairPriceValue & price) { return price.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double fair_price; }; struct Greeks { Greeks & operator += (const Greeks & greeks); Greeks operator * (const Double & mult) const; Greeks & operator *= (const Double & mult); void Clear(); void ClearNoncombinationValues(); void Set(const Greeks & greeks); bool SetError(const String & error); void SetErrorToCCSVolatilityModelGreeks(const String & error); void SetErrorToWingVolatilityModelGreeks(const String & error); void ZeroFill(); friend std::ostream & operator << (std::ostream & strm, const Greeks & greeks) { return greeks.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double forward_price; Double quanto_forward_price; Double spot_price; Double strike_price; Double delta; Double gamma; Double option_equivalent_gamma; Double vega; Double option_equivalent_vega; Double rho; Double rho_discounting; Double vanna; Double vomma; Double skew_delta; Double skew_gamma; Double calendar_theta; Double volatility_theta; Double rate_theta; Double calendar_charm; Double calendar_skew_charm; Double calendar_color; Double opening_theta; Double opening_charm; Double<fim-suffix>Double overnight_charm; Double overnight_skew_charm; Double overnight_color; Double divit; Double speed; Double skew_speed; Double zomma; Double volatility; Double at_the_money_volatility; Double at_the_money_straddle_price; Double straddle_price; Boolean exercise_boundary_reached; Boolean exercise_boundary_div_reached; Integer moneyness; Double simple_put_moneyness; Double wing_slope_sensitivity; Double wing_call_curvature_sensitivity; Double wing_put_curvature_sensitivity; Double ccs_left_slope_sensitivity; Double ccs_right_slope_sensitivity; Double asian_average_fix; Double delta_ytm; Double gamma_ytm; Double fair_ytm; Double implicit_atm_forward; Double implicit_atm_volatility; Double implicit_wing_atm_slope; Double equity_leg_override_price; Double yield; Double synthetic_yield; Double dividend_equivalent_yield; Double tenor_rate_sensitivity; Double bond_duration; Double bond_dv01; Double cash_delta_base; Double cash_gamma_base; Double cash_vega_base; }; struct GreeksCompact { enum class Items { forward_price = 0, spot_price, delta, gamma, option_equivalent_gamma, vega, option_equivalent_vega, rho, rho_discounting, vanna, vomma, skew_delta, skew_gamma, calendar_theta, volatility_theta, rate_theta, calendar_charm, calendar_skew_charm, calendar_color, opening_theta, opening_charm, opening_skew_charm, opening_color, overnight_theta, overnight_charm, overnight_skew_charm, overnight_color, divit, speed, skew_speed, zomma, volatility, at_the_money_volatility, at_the_money_straddle_price, straddle_price, wing_slope_sensitivity, wing_call_curvature_sensitivity, wing_put_curvature_sensitivity, ccs_left_slope_sensitivity, ccs_right_slope_sensitivity, asian_average_fix, delta_ytm, gamma_ytm, fair_ytm, implicit_atm_forward, implicit_atm_volatility, implicit_wing_atm_slope, equity_leg_override_price, quanto_forward_price, strike_price, yield, synthetic_yield, dividend_equivalent_yield, tenor_rate_sensitivity, bond_duration, bond_dv01, cash_delta_base, cash_gamma_base, cash_vega_base }; void Clear(); void Decode(const ValuesRequest & request, Greeks & greeks) const; void Encode(const ValuesRequest & request, const Greeks &<fim-middle>opening_skew_charm; Double opening_color; Double overnight_theta;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification<fim-suffix>{ TBDEBUG(__func__ << \", ivid = \" << ivid);<fim-middle>& ivid)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; private:<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if<fim-suffix><fim-middle>(!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n<fim-suffix><fim-middle>const JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n<fim-suffix><fim-middle>    if (length >= 126)\n    {\n        std::size_t num_bytes;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n<fim-suffix><fim-middle>    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } }<fim-suffix><fim-middle>void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;\n        tbricks::DateTime expires_datetime;\n\n        tbricks::String userId;\n        tbricks::String secret;\n        tbricks::String host_port_path;\n        bool connected = false;\n        bool logged_in = false;\n        int hb = 0;\n\n        void SetExpires(int seconds);\n        bool IsExpired() const;\n        void Reset();\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\n    typedef tbricks::String Ticker;\n    typedef std::string Channel;\n    struct Subscription : public tbricks::Printable\n    {\n        Ticker ticker;\n        DeribitSubscription subscription = DeribitSubscription::NONE;\n        DeribitInterval interval = DeribitInterval::NONE;\n        Channel channel; \/\/ should be always sorted\n\n        std::ostream & Print(std::ostream & strm) const final;\n    };\n\nprivate:\n    void OnLoginReply(SingleTransaction & t);\n    void OnSetHeartbeatReply(SingleTransaction & t);\n    void OnHeartbeat(deribit::JsonReply && incoming);\n    void OnTestReply(SingleTransaction & t);\n\n    void OnSubscribeReply(SingleTransaction & t);\n    void OnSubscriptionUpdate(deribit::JsonReply && incoming);\n    void OnInstrumentDownload(SingleTransaction & t);\n<fim-suffix><fim-middle>private:\n    SingleTransaction & NewTransaction(const tbricks::Identifier & uuid = tbricks::Uuid::Create());"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; private: \/\/ App parameters<fim-suffix><fim-middle>};"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n<fim-suffix><fim-middle>class public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\"<fim-suffix><fim-middle>#include \"MyCustomPreferencesStorage.h\""}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n<fim-suffix><fim-middle>bool JsonReply::IsError() const\n{\n    return isError;\n}"}
{"content":"<fim-prefix>#pragma once #include<fim-suffix>namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override;<fim-middle>\"OrderExecutor.h\" #include \"shared\/MDTracker.h\""}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) {<fim-suffix>} template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; }<fim-middle>m_data.Append(in);"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n<fim-suffix><fim-middle>void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string> Method; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods() { return { {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)}, {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)}, {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)}, {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)},<fim-suffix>{DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)}, {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)}, {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}}; }<fim-middle>{DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)}, {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)},"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionReverser : public tbricks::IRequestReplyHandler { public: PositionReverser() = default; ~PositionReverser() = default; void ReversePosition( const tbricks::Position& position, const tbricks::Price& atPrice); \/\/ IRequestReplyHandler method void HandleRequestReply(const tbricks::Identifier &<fim-suffix>private:<fim-middle>id, tbricks::Status status, const tbricks::String & status_text) final;"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Reset(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Fail(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update) { TBDEBUG(__func__ << \": \" << stream); TBDUMP(update); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->HandleDistributedValuesUpdate(update); }<fim-suffix>TBDEBUG(\"No Deribit model associated with stream: \" << stream); } } std::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream) { auto it_streams = m_streams.find(stream); if (it_streams == m_streams.end()) { return std::nullopt; } return GetModel(it_streams->second); } std::optional<DeribitModel *> DeribitMdp::GetModel(const InstrumentIdentifier & instrument) { auto it_models = m_models.find(instrument); if (it_models == m_models.end()) { return std::nullopt; }<fim-middle>else {"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n<fim-suffix><fim-middle>    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_plugInStatusDescription.Clear();\n        m_instrumentManager.Start();\n\n        SetState(StrategyState::RUNNING);\n    }\n}\n<fim-suffix><fim-middle>void InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n<fim-suffix><fim-middle>static std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n<fim-suffix><fim-middle>#define BUFFER_MIN_SIZE 4"}
{"content":"<fim-prefix>#pragma once\n#include <shared\/API.h>\n#include \"tbricks_definitions.h\"\n\nclass TimerController : public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual void HandleTimerEventHit() = 0;\n        virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0;\n    };\n\n    explicit TimerController(IHandler& handler);\n\n    ~TimerController() noexcept override = default;\n<fim-suffix><fim-middle>    void HandleTimerEvent(tbricks::Timer& timer) override;\n    void Update(const tbricks::StrategyParameters& strategyParameters);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item,<fim-suffix>: m_stream(handler)<fim-middle>DistributedValues::Stream::IHandler & handler)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n<fim-suffix><fim-middle>} \/\/ namespace deribit"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h> #include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; namespace dv = deribit_contributor::distributed_values; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); m_supported_values.insert(dv::DeribitTicker().GetIdentifier()); m_supported_values.insert(dv::DeribitInstruments().GetIdentifier()); \/\/ Run if we were asked to if (GetTransactionOperation().IsRun()) { SetState(GetState()); HandleRunRequest(); } } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } else { SetState(StrategyState::PAUSED); } } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::FailWithReason(const String & reason) {<fim-suffix>} void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); DistributedValuesReply reply(request.GetIdentifier(), false); \/\/ Check that all objects are supported by the app InstrumentIdentifier instrumentId; for (const auto & object : request.GetObjects()) { auto & objParams = object.GetParameters(); if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency())) { \/\/ if instrument is not defined in the request TBDEBUG(\"Object missing required parameters:\\n\" << object << \"Rejecting request.\"); IDistributionApp::SendDistributedValuesReply(reply); return; } \/\/ Check instrument listed on venue Instrument i(instrumentId); auto [compatible, viid] = ExtractVIID(i); if (not compatible) { TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\"); IDistributionApp::SendDistributedValuesReply(reply); return; } } for (const auto & value : request.GetValues()) { if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end()) { TBDEBUG(\"Unsupported value:\\n\" << value << \"Rejecting<fim-middle>SetTransactionFail(reason, StrategyState::PAUSED);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n<fim-suffix><fim-middle>public:\n    public_auth(const std::string_view id);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } \/\/ TimerController::IHandler void HandleTimerEventHit() final;<fim-suffix>private: bool CheckRunningRequirement(); void HandleAction(const tbricks::Integer & action); void Start(); void Stop(); void ImportNow();<fim-middle>void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final;"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT, PUBLIC_GetInstruments, }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; case DeribitMethod::PUBLIC_GetInstruments: return \"public\/get_instruments\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE,<fim-suffix>}; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string> Method; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods() { return { {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)}, {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)}, {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)}, {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)}, {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)}, {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)}, {DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)}, {DeribitMethod::PUBLIC_GetInstruments,<fim-middle>OPTION, ALL"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\" #include \"tbricks_definitions.h\" #include <cstdlib> #include <set> using namespace tbricks; ExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin2::HandlePricingModifyRequest(const PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin2::Calculate(const RequestAndIVIDs & values, const CalculatedValuesRequestFull & request) { m_rows = values; for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, civ_it.GetColumnId(), x); } } else { TBERROR(\"System asked for calculation which the plugin does not support!\"); } } Send(); } void ExampleCalcAppPlugin2::Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x) { CalculatedValueIdentifier calc_id(rowId, columnId); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } bool ExampleCalcAppPlugin2::HandlePartialPricingModifyRequest(const CalculatedValuesRequestUpdate &update) { if (update.GetRowsBegin() != update.GetRowsEnd()) { return false; } for(auto it = update.GetColumnsBegin(), end = update.GetColumnsEnd(); it != end; ++it) { if (it.GetColumnInfo().GetState() ==<fim-suffix>{ Double x; StrategyParameters parameters; it.GetColumnInfo().GetStrategyParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto<fim-middle>CalculatedValuesRequestUpdate::State::UPDATE) { if( it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2())"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler &<fim-suffix><fim-middle>handler); ~DeribitModel() noexcept = default;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n<fim-suffix><fim-middle>{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);"}
{"content":"<fim-prefix>#include \"PositionReverser.h\" #include \"tbricks_definitions.h\" #include <cmath> using namespace tbricks; void PositionReverser::ReversePosition( const Position& position, const Price& atPrice) { Trade reversedTrade; Volume netPosition = position.GetNetPosition(); if (netPosition > 0) { reversedTrade.SetSide(Side::SELL); } else { reversedTrade.SetSide(Side::BUY); } reversedTrade.SetPrice(atPrice); reversedTrade.SetType(TradeType::POSITION_ADJUSTMENT); reversedTrade.SetCurrency(position.GetCurrency()); reversedTrade.SetClient(position.GetClient()); reversedTrade.SetVolume(std::fabs(position.GetNetPosition())); reversedTrade.SetCounterpart(position.GetCounterpart()); Trade::RequestResult reqCreate = Trade::SendCreateRequest(reversedTrade, *this); m_reversedPositions[reqCreate.GetRequestIdentifier()] = position.GetIdentifier(); TBDEBUG(\"Requested to reverse position: \" << position.GetIdentifier() << \" with trade: \" << reqCreate.GetTradeIdentifier()); } void PositionReverser::HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) { TBDEBUG(__func__ << \" \" << id << \" with status \" << status << \" \" << status_text); auto iterCreate = m_reversedPositions.find(id); bool isCreateRequest =<fim-suffix><fim-middle>(iterCreate != m_reversedPositions.end());"}
{"content":"<fim-prefix>#include \"Values.h\"\n#include \"ValuesRequest.h\"\n\nvoid ImpliedValue::Clear()\n{\n    implied_volatility.Clear();\n}\n\nstd::ostream & ImpliedValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"] \" << implied_volatility;\n    return strm;\n}\n\nFairPriceValue & FairPriceValue::operator += (const FairPriceValue & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.fair_price.Empty()) {\n        fair_price += fair_price_value.fair_price;\n    } else if (fair_price_value.fair_price.HasError()) {\n        fair_price.SetError(fair_price_value.fair_price.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue & FairPriceValue::operator += (const Double & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.Empty()) {\n        fair_price += fair_price_value;\n    } else if (fair_price_value.HasError()) {\n        fair_price.SetError(fair_price_value.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue FairPriceValue::operator * (const Double & mult) const\n{\n    FairPriceValue fair_price_value = *this;\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price_value.fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price_value.fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price_value.fair_price.Clear();\n    }\n    return fair_price_value;\n}\n\nFairPriceValue & FairPriceValue::operator *= (const Double & mult)\n{\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nvoid FairPriceValue::Clear()\n{\n    fair_price.Clear();\n}\n\nbool FairPriceValue::SetError(const String & error)\n{\n    if (error == fair_price.GetError()) {\n        return false;\n    }\n\n    fair_price.SetError(error);\n    return true;\n}\n<fim-suffix><fim-middle>std::ostream & FairPriceValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"]\" << fair_price;\n    return strm;"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem<fim-suffix>{ TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)<fim-middle>& item)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/VisualizationApp.h> #include <strategy\/visualization\/ViewModelUpdate.h> #include <strategy\/visualization\/ICellValue.h> #include <strategy\/visualization\/Grid.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::VisualizationApp , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VisualizationApp methods void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final; void HandleStrategyViewDelete(tbricks::visualization::models::AppViewModel & viewModel) final { } void HandleGridViewCreate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } void HandleGridViewUpdate(tbricks::visualization::models::GridViewModel & viewModel, const tbricks::visualization::ViewModelUpdate & update) final { } \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final;<fim-suffix><fim-middle>void HandleInstrumentManagerFailed(const tbricks::String& reason) final;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE =<fim-suffix>const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE<fim-middle>VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type);<fim-suffix>void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply<fim-middle>void SetClientId(const std::string_view val);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char val) { ostm.write(&val, sizeof(char)); return<fim-suffix><fim-middle>ostm; }"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t<fim-suffix>bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double GetBid(); double GetAsk(); double GetBidVolume(); double GetAskVolume(); }; } \/\/ deribit<fim-middle>GetTimestamp();"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view<fim-suffix><fim-middle>GetInstrumentName(); int64_t GetTimestamp();"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and<fim-suffix>void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } Strategy::SetState(StrategyState::RUNNING); return true; } void InstrumentEnricherPlugin::HandleImportComplete(const String& status) { TBDEBUG(__func__ << \" : \" << status); m_plugInStatusDescription = status; HandlePauseRequest(); } void<fim-middle>attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); }"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n<fim-suffix><fim-middle>    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String& str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String& str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto& msg =<fim-suffix>if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto& msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto& msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto& msg = m_doc->msg; \\ auto v = msg.FindMember(#key);<fim-middle>m_doc->msg; auto i = msg.FindMember(\"instrument_name\");"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view<fim-suffix>protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool<fim-middle>ToString(); void Parse(const tbricks::String & str);"}
{"content":"<fim-prefix>#include <strategy\/type\/InstrumentIdentifier.h>\n#include <strategy\/type\/InstrumentGroupIdentifier.h>\n#include <strategy\/instrument\/InstrumentGroupAggregateParameters.h>\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/stream\/PositionStream.h>\n#include <shared\/Macros.h>\n#include <shared\/VersionTracker.hpp>\n#include <shared\/volatility\/InterpolatedVolatilityModel.h>\n#include <shared\/Comparators.h>\n#include <shared\/smart_pointers\/SharedPointer.hpp>\n#include <shared\/smart_pointers\/WeakPointer.hpp>\n#include <shared\/sdk_definitions.h>\n#include <shared\/metaprogramming\/Badge.hpp>\n#include <bitset>\n#include \"UnderlyingTickRules.h\"\n#include \"VolTuningData.h\"\n#include \"..\/VolatilitySurfaceSubscriptionManager.h\"\n#include \"..\/plotting\/ZoomingSettings.h\"\n#include \"..\/historical_data_analysis\/ICalculationStreamWrapper.h\"\n#include \"..\/VolatilityPointsCollector.h\"\n\nTB_FORWARD_DECLARE_CLASS(InstrumentVolatilityData);\nclass ProductGroupCache;\n\nclass MaturityData\n{\npublic:\n    class IProvider\n    {\n    public:\n        virtual const InstrumentGroupIdentifier & GetProductGroupId() const = 0;\n        virtual void GetInstrumentVolatilityDataForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 std::vector<const InstrumentVolatilityData*> & data) const = 0;\n        virtual bool GetStrikeRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId, Price & minStrike,\n                                                    Price & maxStrike, const Price & strikeThreshold) const = 0;\n        virtual bool GetStrikesWithImpliedsRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 Price & minStrike, Price & maxStrike,\n                                                                 const Price & strikeThreshold) const = 0;\n        virtual const VolatilityModel GetVolatilityModelType() const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const InstrumentGroupIdentifier & groupId) const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const DateTime & maturityDate) const = 0;\n        virtual const TickRule * GetUnderlyingInstrumentTickRule(const InstrumentIdentifier & underlyingId) const = 0;\n        virtual std::pair<const MaturityData*,const MaturityData*> GetNeighboringMaturityData(const DateTime & maturityDate) const = 0;\n        virtual const MaturityData * FindMaturityData(const DateTime & maturityDate) const = 0;\n\n        virtual std::vector<InstrumentParameterDefinition> & GetVolatilitySurfaceTableDefinitionsMemCache() const = 0;\n\n        virtual const std::pair<DateTime, DateTime> & GetSampleDateTimePair() const = 0;\n\n        virtual const DateTime & GetValuationDate() const = 0;\n\n        virtual const Identifier & GetTargetContextId() const = 0;\n\n        virtual ~IProvider() {}\n    };\n\n    typedef VolatilitySurfaceSubscriptionManager::VolatilitySurfaceData     VolatilitySurfaceData;\n    typedef VolatilitySurfaceSubscriptionManager::VolatilitySurfaceDataPtr  VolatilitySurfaceDataPtr;\n\n    typedef smart_pointers::SharedPointer<volatility::IVolatilityModel> VolatilityModelPtr;\n    typedef smart_pointers::WeakPointer<const volatility::IVolatilityModel> VolatilityModelConstWeakPtr;\n\n    typedef smart_pointers::SharedPointer<InstrumentGroupAggregateParametersStream> InstrumentGroupParametersStreamPtr;\n    typedef smart_pointers::SharedPointer<ICalculationStreamWrapper> CalculationStreamWrapperPtr;\n    typedef smart_pointers::SharedPointer<PositionStream> PositionStreamPtr;\n\npublic:\n    MaturityData(const IProvider & manager,\n                 const InstrumentGroupIdentifier & groupId = InstrumentGroupIdentifier(),\n                 const DateTime & maturityDate = DateTime(),\n                 const String & groupName = String());\n    MaturityData(MaturityData && maturityData) = default;\n    ~MaturityData();\n\n    String GetName() const;\n\n    const String & GetGroupName() const { return m_groupName; }\n    void SetGroupName(const String & groupName) { m_groupName = groupName; }\n<fim-suffix><fim-middle>    const InstrumentGroupIdentifier & GetGroupIdentifier() const { return m_groupId; }\n    void SetGroupIdentifier(const InstrumentGroupIdentifier & groupId) { m_groupId = groupId; }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/test\/TestEngine.h> using namespace tbricks; using namespace tbricks::test; #ifndef TIMEOUT #define TIMEOUT tbricks::Duration::Seconds(5) #endif void Test(TestEngine &te); tbricks::String get_current_root(); tbricks::String get_apps_relative(); int main(int \/*argc*\/, char * \/*argv*\/[]) { TestEngine te(\"..\/system.xml\", \"..\/engine.xml\"); te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\"); te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString()); te.RunTest(Test, TIMEOUT); return 0; } namespace go_flat { tbricks::VenueIdentifier GetTestVenueId() { return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"}; } tbricks::PortfolioIdentifier GetPortfolioId() { return {\"2eb2249c-bc89-11ee-a950-d946a31b499d\"}; } } \/\/ namespace go_flat #include <filesystem> namespace fs = std::filesystem; tbricks::String get_current_root() { fs::path current(fs::current_path()); fs::path apps; if (std::getenv(\"TB_APPS\") == nullptr) { apps = fs::path(\"\/opt\/tbricks\/apps\"); } else { apps<fim-suffix>} current = fs::relative(current, apps); return tbricks::String(current.c_str()); } tbricks::String get_apps_relative() { fs::path apps; if (std::getenv(\"TB_APPS\") == nullptr) { apps<fim-middle>= fs::path(std::getenv(\"TB_APPS\"));"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset;<fim-suffix>m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data;<fim-middle>else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n<fim-suffix><fim-middle>        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"..\/VolatilityManagerSettings.h\"\n#include \"..\/ImpliedVolatilitySourcesManagerCore.h\"\n#include \"..\/..\/preferences_editor\/tbricks_definitions.h\" \/\/ FIXME: Remove when cp definitions are generated for shared\/system meta (TB-103467)\n#include <shared\/Macros.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/String.h>\n#include <strategy\/Instrument.h>\n#include <strategy\/Definitions.h>\n#include <strategy\/Logger.h>\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n#include <iostream>\n#include <cmath>\n\nconst CalculatedPropertyFilter PreferencesStorage::dummyFilter = CalculatedPropertyFilter::Condition(\n    vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::NE, Integer());\n\nPreferencesStorage::PreferencesStorage() :\n    autoFit(false),\n    autoApplyAutoFit(false),\n    globalAvoidExtraFits(true),\n    globalUnderlyingTradingStatusTracking(true),\n    optionTradingStatusTracking(volatility_manager_settings::DEFAULT_AUTO_FIT_OPTION_TRADING_STATUS_TRACKING),\n    loggingMode(enumerations::VolatilityManagerLoggingModeVerbose),\n    maxAllowedFitRejects(),\n    maturityExcludedFromGlobalActions(false),\n    sendQuotingRecommendations(false),\n    quotingRecommendations(),\n    parallelShift(true),\n    curveShiftUnits(enumerations::VolatilityManagerCurveShiftUnitsVolatility),\n    ATMVolatilityShiftMode(ATM_VolatilityShiftModeShiftSingleATM_Point),\n    includeExoticOptions(volatility_manager_settings::DEFAULT_USE_EXOTIC_OPTIONS_OPTION),\n    autoFetchATMVolatilityPath(false),\n    globalAutoFetchATMVolatilityPath(volatility_manager_settings::DEFAULT_ATM_VOL_PATH_AUTO_FETCH_OPTION),\n    instrumentGroupType(VolatilityManagerInstrumentGroupTypeDerivative),\n    suggestContext(parameter_contexts::VM_Suggest()),\n    trackingAreaType(enumerations::VolatilityManagerTrackingAreaTypeBasedOnAllStrikes),\n    volatilityCurveSafetyCheckEnabled(false),\n    safetyParameterChange(volatility_manager_settings::DEFAULT_SAFETY_PARAMETERS_CHANGES),\n    safetyModelChange(volatility_manager_settings::DEFAULT_SAFETY_MODEL_CHANGES),\n    checkForStaticArbitrage(false),\n    calendarSpreadArbitrageTolerance(volatility_manager_settings::DEFAULT_CALENDAR_SPREAD_ARBITRAGE_TOLERANCE),\n    butterflyArbitrageTolerance(volatility_manager_settings::DEFAULT_BUTTERFLY_ARBITRAGE_TOLERANCE),\n    enableCurveQualityMetrics(false),\n    fitWeighting(FitWeightingInvertedSpread),\n    autocorrectFitWeights(true),\n    fitOnlyATMVol(false),\n    addVirtualBids(volatility_manager_settings::DEFAULT_ADD_VIRTUAL_BIDS),\n    virtualBidRatio(volatility_manager_settings::DEFAULT_VIRTUAL_BID_MULTIPLIER),\n    robustFittingOnWings(false),\n    robustFittingOnWingsStrength(volatility_manager_settings::DEFAULT_ROBUST_FITTING_ON_WINGS_STRENGTH),\n    autoResetSwimRefPriceToATM(false),\n    crossingProcessing(tbricks::enumerations::VolatilityManagerCrossingProcessingSkip),\n    anomalyDetection(false),\n    anomalyDetectionSensitivity(volatility_manager_settings::DEFAULT_ANOMALY_DETECTION_SENSITIVITY),\n    enableAmerican(true),\n    enableATM(true),\n    enableDeepITM(true),\n    enableDeepOTM(true),\n    enableEuropean(true),\n    enableITM(true),\n    enableCashDelivery(true),\n    enableCrossings(true),\n    enableLowBids(true),\n    enablePhysicalDelivery(true),\n    enableSmallDelta(true),\n    enableWideSpreads(true),\n    enableNoSpreads(true),\n    enableOTM(true),\n    enableLowVolumes(true),\n    minimumBidPrice(),\n    minimumVolume(),\n    manuallyToggledPoints(),\n    impliedVolatilitySources(),\n    tradingPhaseProcessing(enumerations::VolatilityManagerTradingPhaseProcessingAllTradingPhases),\n    showExcludedPoints(volatility_manager_settings::DEFAULT_SHOW_EXCLUDED_VOL_POINTS),\n    autocorrectVolatilityChartZooming(true),\n    deltaValueForVerticalLines(volatility_manager_settings::DEFAULT_DELTA_VALUE_FOR_VERTICAL_LINES),\n    showVerticalLinesAtGivenDelta(volatility_manager_settings::DEFAULT_SHOW_VERTICAL_LINES_AT_DELTA),\n    volatilityCurveChartAutoRangePadding(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_PADDING),\n    portfolio(),\n    preserveZooming(volatility_manager_settings::DEFAULT_PRESERVE_ZOOMING_OPTION),\n    distanceBetweenCurvePoints(volatility_manager_settings::CHART_DEFAULT_CURVE_DISTANCE_BETWEEN_DRAWN_POINTS),\n    autoRangeMode(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_MODE),\n    showReferenceVols(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_VOLS),\n    showReferenceCurve(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_CURVE),\n    showBidAskRange(volatility_manager_settings::DEFAULT_SHOW_BID_ASK_RANGE),\n    putCallColors(enumerations::VolatilityManagerPut_DIV_CallColorsDefault),\n    colorScheme(enumerations::VolatilityManagerChartColorSchemePale)\n{\n    Table impliedVolSources;\n    ImpliedVolatilitySourcesManagerCore::SetupTable(impliedVolSources, \/* useTreeNodes = *\/ true);\n    impliedVolatilitySources.SetDefault(impliedVolSources);\n\n    m_scopeLevelAnchoredPreferences = {\n        tree_node_parameters::VolatilityManagerAutomaticFit(),\n        tree_node_parameters::VolatilityManagerAutoApplyAutoFit(),\n        tree_node_parameters::VolatilityManagerAutoResetSwimReferencePrice(),\n        tree_node_parameters::VolatilityManagerMaturityExcluded(),\n        tree_node_parameters::VolatilityManagerManuallyToggledVolatilityPoints()\n    };\n\n    CalculatedPropertyFilter defaultInstrumentFilter = CalculatedPropertyFilter::Condition(\n        vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::EQ, Enumeration(Instrument::CFI_Variant::Undefined));\n\n    instrumentFilter.SetDefault(defaultInstrumentFilter);\n}\n\nPreferencesStorage::~PreferencesStorage()\n{}\n\nvoid PreferencesStorage::Clear()\n{\n    autoFit.ClearValue();\n    autoApplyAutoFit.ClearValue();\n    globalAvoidExtraFits.ClearValue();\n    globalUnderlyingTradingStatusTracking.ClearValue();\n    optionTradingStatusTracking.ClearValue();\n    loggingMode.ClearValue();\n    maxAllowedFitRejects.ClearValue();\n    maturityExcludedFromGlobalActions.ClearValue();\n    sendQuotingRecommendations.ClearValue();\n    quotingRecommendations.ClearValue();\n\n    parallelShift.ClearValue();\n    curveShiftUnits.ClearValue();\n    ATMVolatilityShiftMode.ClearValue();\n    includeExoticOptions.ClearValue();\n    autoFetchATMVolatilityPath.ClearValue();\n    globalAutoFetchATMVolatilityPath.ClearValue();\n    instrumentGroupType.ClearValue();\n    suggestContext.ClearValue();\n    trackingAreaType.ClearValue();\n    volatilityCurveSafetyCheckEnabled.ClearValue();\n    safetyParameterChange.ClearValue();\n    safetyModelChange.ClearValue();\n    checkForStaticArbitrage.ClearValue();\n    calendarSpreadArbitrageTolerance.ClearValue();\n    butterflyArbitrageTolerance.ClearValue();\n    enableCurveQualityMetrics.ClearValue();\n\n    fitWeighting.ClearValue();\n    autocorrectFitWeights.ClearValue();\n    fitOnlyATMVol.ClearValue();\n    addVirtualBids.ClearValue();\n    virtualBidRatio.ClearValue();\n    robustFittingOnWings.ClearValue();\n    robustFittingOnWingsStrength.ClearValue();\n    autoResetSwimRefPriceToATM.ClearValue();\n    crossingProcessing.ClearValue();\n    anomalyDetection.ClearValue();\n    anomalyDetectionSensitivity.ClearValue();\n\n    enableAmerican.ClearValue();\n    enableATM.ClearValue();\n    enableDeepITM.ClearValue();\n    enableDeepOTM.ClearValue();\n    enableEuropean.ClearValue();\n    enableITM.ClearValue();\n    enableCashDelivery.ClearValue();\n    enableCrossings.ClearValue();\n    enableLowBids.ClearValue();\n    enablePhysicalDelivery.ClearValue();\n    enableSmallDelta.ClearValue();\n    enableWideSpreads.ClearValue();\n    enableNoSpreads.ClearValue();\n    enableOTM.ClearValue();\n    enableLowVolumes.ClearValue();\n    minimumBidPrice.ClearValue();\n    minimumVolume.ClearValue();\n    manuallyToggledPoints.ClearValue();\n    impliedVolatilitySources.ClearValue();\n    instrumentFilter.ClearValue();\n    tradingPhaseProcessing.ClearValue();\n\n    showExcludedPoints.ClearValue();\n    autocorrectVolatilityChartZooming.ClearValue();\n    deltaValueForVerticalLines.ClearValue();\n    showVerticalLinesAtGivenDelta.ClearValue();\n    volatilityCurveChartAutoRangePadding.ClearValue();\n    autoRangeMode.ClearValue();\n    portfolio.ClearValue();\n    preserveZooming.ClearValue();\n    distanceBetweenCurvePoints.ClearValue();\n    showReferenceCurve.ClearValue();\n    showReferenceVols.ClearValue();\n    showBidAskRange.ClearValue();\n    putCallColors.ClearValue();\n    colorScheme.ClearValue();\n}\n\nvoid PreferencesStorage::Copy(const PreferencesStorage & preferencesStorage)\n{\n    autoFit = preferencesStorage.autoFit;\n    autoApplyAutoFit = preferencesStorage.autoApplyAutoFit;\n    globalAvoidExtraFits = preferencesStorage.globalAvoidExtraFits;\n    globalUnderlyingTradingStatusTracking = preferencesStorage.globalUnderlyingTradingStatusTracking;\n    optionTradingStatusTracking = preferencesStorage.optionTradingStatusTracking;\n    loggingMode = preferencesStorage.loggingMode;\n    maxAllowedFitRejects = preferencesStorage.maxAllowedFitRejects;\n    maturityExcludedFromGlobalActions = preferencesStorage.maturityExcludedFromGlobalActions;\n    sendQuotingRecommendations = preferencesStorage.sendQuotingRecommendations;\n    quotingRecommendations = preferencesStorage.quotingRecommendations;\n\n    parallelShift = preferencesStorage.parallelShift;\n    curveShiftUnits = preferencesStorage.curveShiftUnits;\n    ATMVolatilityShiftMode = preferencesStorage.ATMVolatilityShiftMode;\n    includeExoticOptions = preferencesStorage.includeExoticOptions;\n    autoFetchATMVolatilityPath = preferencesStorage.autoFetchATMVolatilityPath;\n    globalAutoFetchATMVolatilityPath = preferencesStorage.globalAutoFetchATMVolatilityPath;\n    instrumentGroupType = preferencesStorage.instrumentGroupType;\n    suggestContext = preferencesStorage.suggestContext;\n    trackingAreaType = preferencesStorage.trackingAreaType;\n    volatilityCurveSafetyCheckEnabled = preferencesStorage.volatilityCurveSafetyCheckEnabled;\n    safetyParameterChange = preferencesStorage.safetyParameterChange;\n    safetyModelChange = preferencesStorage.safetyModelChange;\n    checkForStaticArbitrage = preferencesStorage.checkForStaticArbitrage;\n    calendarSpreadArbitrageTolerance = preferencesStorage.calendarSpreadArbitrageTolerance;\n    butterflyArbitrageTolerance = preferencesStorage.butterflyArbitrageTolerance;\n    enableCurveQualityMetrics = preferencesStorage.enableCurveQualityMetrics;\n\n    fitWeighting = preferencesStorage.fitWeighting;\n    autocorrectFitWeights = preferencesStorage.autocorrectFitWeights;\n    fitOnlyATMVol = preferencesStorage.fitOnlyATMVol;\n    addVirtualBids = preferencesStorage.addVirtualBids;\n    virtualBidRatio = preferencesStorage.virtualBidRatio;\n    robustFittingOnWings = preferencesStorage.robustFittingOnWings;\n    robustFittingOnWingsStrength = preferencesStorage.robustFittingOnWingsStrength;\n    autoResetSwimRefPriceToATM = preferencesStorage.autoResetSwimRefPriceToATM;\n    crossingProcessing = preferencesStorage.crossingProcessing;\n    anomalyDetection = preferencesStorage.anomalyDetection;\n    anomalyDetectionSensitivity = preferencesStorage.anomalyDetectionSensitivity;\n\n    enableAmerican = preferencesStorage.enableAmerican;\n    enableATM = preferencesStorage.enableATM;\n    enableDeepITM = preferencesStorage.enableDeepITM;\n    enableDeepOTM = preferencesStorage.enableDeepOTM;\n    enableEuropean = preferencesStorage.enableEuropean;\n    enableITM = preferencesStorage.enableITM;\n    enableCashDelivery = preferencesStorage.enableCashDelivery;\n    enableCrossings = preferencesStorage.enableCrossings;\n    enableLowBids = preferencesStorage.enableLowBids;\n    enablePhysicalDelivery = preferencesStorage.enablePhysicalDelivery;\n    enableSmallDelta = preferencesStorage.enableSmallDelta;\n    enableWideSpreads = preferencesStorage.enableWideSpreads;\n    enableNoSpreads = preferencesStorage.enableNoSpreads;\n    enableOTM = preferencesStorage.enableOTM;\n    enableLowVolumes = preferencesStorage.enableLowVolumes;\n    minimumBidPrice = preferencesStorage.minimumBidPrice;\n    minimumVolume = preferencesStorage.minimumVolume;\n    manuallyToggledPoints = preferencesStorage.manuallyToggledPoints;\n    impliedVolatilitySources = preferencesStorage.impliedVolatilitySources;\n    instrumentFilter = preferencesStorage.instrumentFilter;\n    tradingPhaseProcessing = preferencesStorage.tradingPhaseProcessing;\n\n    showExcludedPoints = preferencesStorage.showExcludedPoints;\n    autocorrectVolatilityChartZooming = preferencesStorage.autocorrectVolatilityChartZooming;\n    deltaValueForVerticalLines = preferencesStorage.deltaValueForVerticalLines;\n    showVerticalLinesAtGivenDelta = preferencesStorage.showVerticalLinesAtGivenDelta;\n    volatilityCurveChartAutoRangePadding = preferencesStorage.volatilityCurveChartAutoRangePadding;\n    autoRangeMode = preferencesStorage.autoRangeMode;\n    portfolio = preferencesStorage.portfolio;\n    preserveZooming = preferencesStorage.preserveZooming;\n    distanceBetweenCurvePoints = preferencesStorage.distanceBetweenCurvePoints;\n    showReferenceCurve = preferencesStorage.showReferenceCurve;\n    showReferenceVols = preferencesStorage.showReferenceVols;\n    showBidAskRange = preferencesStorage.showBidAskRange;\n    putCallColors = preferencesStorage.putCallColors;\n    colorScheme = preferencesStorage.colorScheme;\n}\n\n#define CHECK_AND_UPDATE_PARAMETER(def, param) \\\n    typename decltype(param)::value_type param##Val; \\\n    if (parameters.GetParameter(def, param##Val) && \\\n        ( (param##Val.Empty() != param.EmptyValue()) || (!param##Val.Empty() && !param.EmptyValue() && (param##Val != param.GetValue())) )) \\\n<fim-suffix><fim-middle>    { \\\n        param.Set(param##Val); \\\n        changed = true; \\\n    }"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { \/\/ Here is where we would open the DistributedValues::Stream } void<fim-suffix><fim-middle>DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\" #include \"ConstantVolatility.h\"<fim-suffix>#include \"ClampedCubicSpline.h\" #include<fim-middle>#include \"StochasticVolatilityInspired.h\""}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n<fim-suffix><fim-middle>    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/type\/Price.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/Boolean.h> #include <strategy\/calculated_property\/CalculatedPropertyFilter.h> #include <strategy\/TreeNodeParameters.h> #include <strategy\/parameter\/StrategyParameters.h> #include <strategy\/parameter\/StrategyInstanceParameters.h> CLANG_RESTORE_WARNINGS #include <set> using namespace tbricks; enum class PreferencesStorageKind { Common = 0, Wing, CCS, SVI }; std::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind); \/** * Struct representing the various settings common to all VMs; it is subclassed by structs * containing additional parameters relevant for particular VMs *\/ class PreferencesStorage: public Printable { public: PreferencesStorage(); protected: PreferencesStorage(const PreferencesStorage & storage) = default; PreferencesStorage & operator=(const PreferencesStorage & storage) = default; public: virtual ~PreferencesStorage(); virtual PreferencesStorageKind GetKind() const = 0; virtual void Clear(); virtual void Copy(const PreferencesStorage & preferencesStorage); virtual bool FillFromTreeNodeParameters(const TreeNodeParameters & parameters); virtual bool FillFromStrategyParameters(const StrategyParameters & parameters); virtual bool FillFromStrategyInstanceParameters(const StrategyInstanceParameters & parameters); virtual bool GetParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetParameters(TreeNodeParameters & parameters) const; virtual void GetParameters(StrategyParameters & parameters) const; virtual void GetParameters(StrategyInstanceParameters & parameters) const; virtual bool GetNonDefaultParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetNonDefaultParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetNonDefaultParameters(TreeNodeParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyInstanceParameters & parameters) const; \/\/ Update local values with non-empty values from the passed in preferences storage; \/\/ return true if something got changed as a result, false otherwise virtual bool Merge(const PreferencesStorage & preferencesStorage); virtual std::ostream & Print(std::ostream & strm) const override; \/\/ List of preferences that shouldn't be copied to other scope levels virtual const std::set<TreeNodeParameterDefinition> & GetLevelAnchoredParameters() const { return m_scopeLevelAnchoredPreferences; } \/\/ In case it is necessary to include all the exotic instruments, \/\/ we can't persist empty filter since it would be aggregated. \/\/ Hence, this dummy non-empty filter needs to be used for clear operations. static const CalculatedPropertyFilter dummyFilter; \/\/ Autofit settings ValueWithDefault<Boolean> autoFit; ValueWithDefault<Boolean> autoApplyAutoFit; ValueWithDefault<Boolean> globalAvoidExtraFits; ValueWithDefault<Boolean> globalUnderlyingTradingStatusTracking; ValueWithDefault<Boolean> optionTradingStatusTracking; ValueWithDefault<Integer> loggingMode; ValueWithDefault<Integer> maxAllowedFitRejects; ValueWithDefault<Boolean> maturityExcludedFromGlobalActions; ValueWithDefault<Boolean> sendQuotingRecommendations; ValueWithDefault<Table> quotingRecommendations; \/\/ General settings ValueWithDefault<Boolean> parallelShift; ValueWithDefault<Enumeration> curveShiftUnits; ValueWithDefault<Integer> ATMVolatilityShiftMode; ValueWithDefault<Boolean> includeExoticOptions; ValueWithDefault<Boolean> autoFetchATMVolatilityPath; ValueWithDefault<Boolean> globalAutoFetchATMVolatilityPath; ValueWithDefault<Integer> instrumentGroupType; ValueWithDefault<Identifier> suggestContext; ValueWithDefault<Integer> trackingAreaType; ValueWithDefault<Boolean> volatilityCurveSafetyCheckEnabled; ValueWithDefault<Double> safetyParameterChange; ValueWithDefault<Double> safetyModelChange; ValueWithDefault<Boolean> checkForStaticArbitrage; ValueWithDefault<Double> calendarSpreadArbitrageTolerance; ValueWithDefault<Double> butterflyArbitrageTolerance; ValueWithDefault<Boolean> enableCurveQualityMetrics; \/\/ Fit settings ValueWithDefault<Integer> fitWeighting; ValueWithDefault<Boolean> autocorrectFitWeights; ValueWithDefault<Boolean> fitOnlyATMVol; ValueWithDefault<Boolean> addVirtualBids; ValueWithDefault<Double> virtualBidRatio; ValueWithDefault<Boolean> robustFittingOnWings; ValueWithDefault<Double> robustFittingOnWingsStrength; ValueWithDefault<Boolean> autoResetSwimRefPriceToATM; ValueWithDefault<Integer> crossingProcessing; ValueWithDefault<Boolean> anomalyDetection; ValueWithDefault<Double> anomalyDetectionSensitivity; \/\/ Implied vol filtering ValueWithDefault<Boolean> enableAmerican; ValueWithDefault<Boolean> enableATM; ValueWithDefault<Boolean> enableDeepITM; ValueWithDefault<Boolean> enableDeepOTM; ValueWithDefault<Boolean> enableEuropean; ValueWithDefault<Boolean> enableITM; ValueWithDefault<Boolean> enableCashDelivery; ValueWithDefault<Boolean> enableCrossings; ValueWithDefault<Boolean> enableLowBids; ValueWithDefault<Boolean> enablePhysicalDelivery; ValueWithDefault<Boolean> enableSmallDelta; ValueWithDefault<Boolean> enableWideSpreads; ValueWithDefault<Boolean> enableNoSpreads; ValueWithDefault<Boolean> enableOTM; ValueWithDefault<Boolean> enableLowVolumes; ValueWithDefault<Price> minimumBidPrice; ValueWithDefault<Volume> minimumVolume; ValueWithDefault<Table> manuallyToggledPoints; ValueWithDefault<Table> impliedVolatilitySources; ValueWithDefault<CalculatedPropertyFilter> instrumentFilter; ValueWithDefault<Integer> tradingPhaseProcessing; \/\/ Visualization settings ValueWithDefault<Boolean> showExcludedPoints; ValueWithDefault<Boolean> autocorrectVolatilityChartZooming; ValueWithDefault<Double> deltaValueForVerticalLines; ValueWithDefault<Boolean> showVerticalLinesAtGivenDelta; ValueWithDefault<Double> volatilityCurveChartAutoRangePadding; ValueWithDefault<Identifier> portfolio; ValueWithDefault<Boolean> preserveZooming; ValueWithDefault<Double> distanceBetweenCurvePoints; ValueWithDefault<Integer> autoRangeMode; ValueWithDefault<Boolean> showReferenceVols; ValueWithDefault<Boolean> showReferenceCurve; ValueWithDefault<Boolean> showBidAskRange; ValueWithDefault<Integer> putCallColors; ValueWithDefault<Integer> colorScheme; protected: std::set<TreeNodeParameterDefinition> m_scopeLevelAnchoredPreferences; }; class CommonPreferencesStorage: public PreferencesStorage { public: CommonPreferencesStorage() = default; CommonPreferencesStorage(const CommonPreferencesStorage & storage) = default; CommonPreferencesStorage & operator=(const CommonPreferencesStorage & storage)<fim-suffix>public:<fim-middle>= default;"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n<fim-suffix><fim-middle>        return {};\n    }\n}"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x<fim-suffix>Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely picked up by another calc app \/\/ the engine was just checking if we responded to it<fim-middle>+ (double)std::rand() \/ (double)RAND_MAX - 0.5;"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n<fim-suffix><fim-middle>    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\"\n#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include \"execution\/TbOrderManager.h\"\n#include \"execution\/TbOrderMinion.h\"\n#include \"execution\/TbChildOrder.h\"\n\n#include <AsyncTask.h>\n#include <memory>\n\nusing namespace tbricks;\n\nnamespace sp = go_flat::strategy_parameters;\n\nGoFlatPlugin::GoFlatPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_portfolio(sp::Portfolio())\n    , m_statusText(sp::PlugInStatusDescription())\n    , m_executorType(execution::OrderExecutorType::ORDER_MANAGER)\n{\n    TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered());\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    switch (m_executorType)\n    {\n        case execution::OrderExecutorType::ORDER_MANAGER:\n            m_orders = std::make_unique<execution::TbOrderManager>(*this);\n            break;\n        case execution::OrderExecutorType::CHILD_ORDER:\n            m_orders = std::make_unique<execution::TbChildOrder>(*this, *this);\n            break;\n        case execution::OrderExecutorType::ORDER_MINION:\n            m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters);\n            break;\n    }\n\n    m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier());\n}\n\nvoid GoFlatPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n\n    if (not m_positions or m_positions->GetData().empty())\n    {\n        SetTransactionFail(\"No positions\", StrategyState::PAUSED);\n        return;\n    }\n    if (m_orders)\n    {\n        if (not m_positions->GetData().empty())\n        {\n            for (const auto& [ivid, pos] : m_positions->GetData())\n            {\n                if (m_executorType == execution::OrderExecutorType::ORDER_MINION)\n                {\n                    execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get());\n                    minion->MonitorInstrument(ivid);\n<fim-suffix><fim-middle>                }\n                TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos);\n                if (not pos.Empty() and pos != 0.0)"}
{"content":"<fim-prefix>VOLATILITY(ccs,<fim-suffix><fim-middle>CCS) VOLATILITY(svi, SVI)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"OrderExecutor.h\"\n#include \"shared\/MDTracker.h\"\n\nnamespace execution {\n\nclass TbOrderManager : public OrderExecutor,\n                       public tbricks::OrderManager,\n                       public tbricks::IRequestReplyHandler,\n                       public MDTracker::IHandler\n{\npublic:\n    TbOrderManager(IExecutionHandler& handler);\n    ~TbOrderManager();\n\n    void DeleteOrders() override;\n    void CreateOrder(\n        const tbricks::InstrumentVenueIdentification& ivid,\n        const tbricks::Volume& volume, \/\/ negative for sell\n        const tbricks::PortfolioIdentifier& portfolio) override;\n\nprotected:\n    void HandleOrderUpdate(const tbricks::Order::Update& update) override;\n    void HandleRecoveryCompleted() override;\n\n<fim-suffix><fim-middle>    void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n<fim-suffix><fim-middle>{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\" using namespace tbricks; InstrumentManager::InstrumentManager(IHandler& handler) : m_handler(handler) , m_instrumentStream(*this) , m_iapStream(*this) { TBDEBUG(__func__ << \" ctor\"); } InstrumentManager::~InstrumentManager() { TBDEBUG(__func__ << \" dtor\"); Stop(); } void InstrumentManager::Stop() { TBDEBUG(__func__); m_instrumentCache.clear(); m_underlyingCache.clear(); m_instrumentStream.Close(); } void InstrumentManager::Start() { TBDEBUG(__func__); Stop(); OpenInstrumentStream(); } void InstrumentManager::OpenInstrumentStream() { TBDEBUG(__func__); InstrumentStream::Options options; options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup())); m_instrumentStream.Open(Stream::SNAPSHOT, options); TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter()); } void InstrumentManager::OpenIAPStream() { TBDEBUG(__func__); tbricks::InstrumentAggregateParameters::Stream::Options options; for (const auto& [instId, _] : m_instrumentCache) { options.AddInstrument(instId); } options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()}); m_iapStream.Close(); m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options); TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options); } void InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); } void InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID) { TBWARNING(\"Instrument cache stream staled = \" << streamID); } void InstrumentManager::HandleStreamFailed(const StreamIdentifier& streamID) { m_handler.HandleInstrumentManagerFailed(\"Instrument stream failed\"); } void InstrumentManager::HandleSnapshotEnd(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); if (streamID == m_instrumentStream.GetIdentifier()) { TBDEBUG(\"Instruments snapshot done, enriching...\"); OpenIAPStream(); } else if (streamID == m_iapStream.GetIdentifier()) { \/\/ All data is collected, now perform the next steps EnrichInstruments(); } } void InstrumentManager::HandleInstrument(const StreamIdentifier& streamID, const Instrument& instrument) { TBDEBUG(__func__ << \" : stream = \" << streamID << \", instrument ID<fim-suffix>TBDUMP(instrument); if (streamID == m_instrumentStream.GetIdentifier()) { m_instrumentCache[instrument.GetIdentifier()] = instrument; } else { TBWARNING(\"Instrument update received from unknown stream = \"<fim-middle>= \" << instrument.GetIdentifier());"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4;<fim-suffix><fim-middle>const double VM_COMPARISON_TOLERANCE = 1.0e-9;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE<fim-suffix>const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2;<fim-middle>= 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n<fim-suffix><fim-middle>    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier<fim-suffix>void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler<fim-middle>&modifier) final;"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString()<fim-suffix>} m_handler.HandleTimerControllerUpdate(status, \/*error =*\/ false); } void TimerController::Stop() { TBDEBUG(__func__);<fim-middle>+ \", repeats \" + m_frequency.ToString();"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>(); case<fim-suffix>return std::make_unique<SVIPreferencesStorage>();<fim-middle>VolatilityModelSVI:"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n\nUpdateData::~UpdateData()\n{\n    delete (m_doc);\n}\n\nstd::string_view UpdateData::ToString()\n{\n    m_doc->buffer.Clear();\n    Writer<StringBuffer> writer(m_doc->buffer);\n    m_doc->msg.Accept(writer);\n    return {m_doc->buffer.GetString()};\n}\n\nvoid UpdateData::Parse(const tbricks::String & str)\n<fim-suffix><fim-middle>{\n    m_doc->msg.Clear();\n    StringStream s(str.GetCString());\n    m_doc->msg.ParseStream(s);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters);<fim-suffix>void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); } const tbricks::DateTime& GetTimerLastFired() const<fim-middle>void Start();"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream)<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel<fim-middle>override; \/\/ DistributedValues Stream IHandler     void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier& streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier& streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, enriching...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier& streamID, const Instrument& instrument)\n{\n    TBDEBUG(__func__ << \" : stream = \" << streamID << \", instrument ID = \" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n<fim-suffix><fim-middle>    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n<fim-suffix><fim-middle>    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler interface void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId, const tbricks::CalculatedInstrumentValues::Update & update) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final; private: void OpenInstrumentStream(); void OpenIAPStream(); void OpenCIVStream(); void EnrichInstruments(); void ModifyGroup(); void CheckResolutionStatus(); void CheckModificationStatus(); void PopulateGrid(); struct InstrumentDetails { tbricks::Instrument instrument; tbricks::DateTime maturityDate; tbricks::InstrumentIdentifier underlyingInstrument; tbricks::Price underlyingPrice; tbricks::RowEntityIdentifier gridRowIdentifier; }; using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, InstrumentDetails>; IHandler& m_handler; tbricks::InstrumentStream m_instrumentStream; tbricks::InstrumentAggregateParameters::Stream<fim-suffix><fim-middle>m_iapStream; tbricks::CalculatedInstrumentValues::Stream m_calculatedValuesStream;"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired) VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(None,ConstantVolatility)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private:<fim-suffix>class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index],<fim-middle>MemBuf _buffer; };"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \"<fim-suffix>} void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item);<fim-middle><< item);"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n\nUpdateData::~UpdateData()\n{\n    delete(m_doc);\n}\n\nstd::string_view UpdateData::ToString()\n{\n    m_doc->buffer.Clear();\n    Writer<StringBuffer> writer(m_doc->buffer);\n    m_doc->msg.Accept(writer);\n<fim-suffix><fim-middle>    return {m_doc->buffer.GetString()};\n}"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)\n    {\n        strm << \"  subscription : \" << Resolve(subscription) << \"\\n\";\n    }\n    if (interval != DeribitInterval::NONE)\n    {\n        strm << \"  interval : \" << Resolve(interval) << \"\\n\";\n    }\n    strm << \"  channel : \" << channel << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nDeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type)\n    : m_handler(handler)\n    , m_timer(*this, \"deribit_refresh\")\n{\n    TBDEBUG(__func__ << \" : \" << endpoint);\n\n    std::string url(endpoint.GetCString());\n    auto found = url.find(\":\/\/\");\n    if (found != std::string::npos)\n    {\n        url = url.substr(found + 3);\n    }\n    m_session.host_port_path = url;\n\n    std::vector<String> slices;\n    m_session.host_port_path.Split(':', slices);\n    TBDUMP(slices);\n    switch (type)\n    {\n    case DeribitHost::NONE:\n        m_conf.header.insert({\"Host\", slices[0].GetCString()});\n        break;\n    default:\n        m_conf.header.insert({\"Host\", Resolve(type)});\n        break;\n    }\n}\n\nDeribitClient::~DeribitClient()\n{\n    TBDEBUG(__func__);\n    Disconnect();\n}\n\nvoid DeribitClient::Connect(const String & userId, const String & secret)\n{\n    TBDEBUG(__func__ << \" : userId=\" << userId << \" secret=\" << secret);\n    m_session.userId = userId;\n    m_session.secret = secret;\n\n    m_ws = std::make_unique<TbWebsocketClient>(*this, m_session.host_port_path, m_conf);\n    m_ws->Connect();\n}\n<fim-suffix><fim-middle>void DeribitClient::Disconnect()\n{\n    TBDEBUG(__func__);\n    if (m_ws)"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int<fim-suffix><fim-middle>size = 0;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if<fim-suffix>{ iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume {0}; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail() { InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::SendSnapshotDoneIfNeeded() { TBDEBUG(__func__); if (TB_UNLIKELY(!m_snapshotDone))<fim-middle>(value.Empty() or (value == \"{}\") or value.HasError())"}
{"content":"<fim-prefix>#include <strategy\/type\/InstrumentIdentifier.h>\n#include <strategy\/type\/InstrumentGroupIdentifier.h>\n#include <strategy\/instrument\/InstrumentGroupAggregateParameters.h>\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/stream\/PositionStream.h>\n#include <shared\/Macros.h>\n#include <shared\/VersionTracker.hpp>\n#include <shared\/volatility\/InterpolatedVolatilityModel.h>\n#include <shared\/Comparators.h>\n#include <shared\/smart_pointers\/SharedPointer.hpp>\n#include <shared\/smart_pointers\/WeakPointer.hpp>\n#include <shared\/sdk_definitions.h>\n#include <shared\/metaprogramming\/Badge.hpp>\n#include <bitset>\n#include \"UnderlyingTickRules.h\"\n#include \"..\/VolatilitySurfaceSubscriptionManager.h\"\n#include \"..\/plotting\/ZoomingSettings.h\"\n#include \"..\/historical_data_analysis\/ICalculationStreamWrapper.h\"\n#include \"..\/VolatilityPointsCollector.h\"\n\nTB_FORWARD_DECLARE_CLASS(InstrumentVolatilityData);\nclass ProductGroupCache;\n\nclass MaturityData\n{\npublic:\n    class IProvider\n    {\n    public:\n        virtual const InstrumentGroupIdentifier & GetProductGroupId() const = 0;\n        virtual void GetInstrumentVolatilityDataForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 std::vector<const InstrumentVolatilityData*> & data) const = 0;\n        virtual bool GetStrikeRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId, Price & minStrike,\n                                                    Price & maxStrike, const Price & strikeThreshold) const = 0;\n        virtual bool GetStrikesWithImpliedsRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 Price & minStrike, Price & maxStrike,\n                                                                 const Price & strikeThreshold) const = 0;\n        virtual const VolatilityModel GetVolatilityModelType() const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const InstrumentGroupIdentifier & groupId) const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const DateTime & maturityDate) const = 0;\n        virtual const TickRule * GetUnderlyingInstrumentTickRule(const InstrumentIdentifier & underlyingId) const = 0;\n        virtual std::pair<const MaturityData*,const MaturityData*> GetNeighboringMaturityData(const DateTime & maturityDate) const = 0;\n        virtual const MaturityData * FindMaturityData(const DateTime & maturityDate) const = 0;\n\n        virtual std::vector<InstrumentParameterDefinition> & GetVolatilitySurfaceTableDefinitionsMemCache() const = 0;\n\n        virtual const std::pair<DateTime, DateTime> & GetSampleDateTimePair() const = 0;\n<fim-suffix><fim-middle>        virtual const DateTime & GetValuationDate() const = 0;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <><fim-suffix><fim-middle>Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize())<fim-suffix><fim-middle>m_index = offset;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetState(StrategyState::RUNNING); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); } void DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" <<<fim-suffix>}<fim-middle>request);"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \"<fim-suffix>{ \/\/ start with just the<fim-middle>+ m_startTime.ToString(); } else if (m_startTime.Empty())"}
{"content":"<fim-prefix>#include \"..\/..\/my_custom_pricing\/tbricks_definitions.h\" constexpr VolatilityModel<fim-suffix>#endif \/\/ TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H<fim-middle>VolatilityModelMyCustom = VolatilityModel(custom::pricing::extended_enums::VolatilityModelMyCustom);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n<fim-suffix><fim-middle>    {\n        return m_data;\n    }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/CalculatedPropertiesStream.h> #include <vector> class PositionsData : public tbricks::CalculatedPropertiesTable::Stream::IHandler { public: PositionsData(const tbricks::PortfolioIdentifier& portfolioId, tbricks::StringParameter& status); ~PositionsData(); void Stop(); public: using Data = tbricks::SparseHash<tbricks::InstrumentVenueIdentification, tbricks::Volume>; const Data& GetData()<fim-suffix>protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const<fim-middle>const { return m_data; }"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n<fim-suffix><fim-middle>    {\n    public:\n        virtual ~IHandler() = default;"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString();<fim-suffix>else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts<fim-middle>}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters<fim-suffix>MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__);<fim-middle>and attributes     GetParameters().Merge(modifier.GetParameters());"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Reset(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Fail(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update) { TBDEBUG(__func__ << \": \" << stream); TBDUMP(update); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->HandleDistributedValuesUpdate(update); } else { TBDEBUG(\"No Deribit model associated with stream: \" << stream); } } std::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream) { auto it_streams = m_streams.find(stream); if (it_streams<fim-suffix>return std::nullopt; } return GetModel(it_streams->second); } std::optional<DeribitModel *> DeribitMdp::GetModel(const InstrumentIdentifier & instrument) { auto it_models = m_models.find(instrument); if (it_models == m_models.end()) { return std::nullopt;<fim-middle>== m_streams.end()) {"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n<fim-suffix><fim-middle>void public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context);<fim-suffix><fim-middle>auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;"}
{"content":"<fim-prefix>#include \"..\/shared_config.h\"\n\n#include \"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/tbricks_definitions.h\"\n#include <tests\/shared\/test_utils\/TestUtils.h>\n\n\/**\nThis test is designed for the version of GoFlatPlugin using TbOrderManager (no TbOrderMinion).\nPlease set the hardcoded flag of the app m_useMinions = false\n*\/\n\nvoid Test(TestEngine& te)\n{\n    \/* Test variables *\/\n    VenueInstrumentIdentifier viidOne;\n    Instrument instrumentOne;\n    StrategyIdentifier appId;\n    PortfolioIdentifier portfolioId{go_flat::GetPortfolioId()};\n\n    TBSTATUS(\"Initialize instruments\");\n    {\n        VenueIdentifier venueId = go_flat::GetTestVenueId();\n        viidOne.SetMIC(\"XXXX\");\n        viidOne.SetVenueIdentifier(venueId);\n        viidOne.Add(\"symbol\", \"ONE\");\n        std::vector<VenueInstrumentIdentifier> viids = {viidOne};\n\n        Instrument::Options options;\n        options.SetShortName(\"ONE\");\n        options.SetVenueInstrumentIdentifiers(viids);\n        instrumentOne = te.GetIS().CreateInstrument(options);\n    }\n\n    TBSTATUS(\"Prepare calculated properties\");\n    {\n        CalculatedPropertiesTableUpdate cpUpdate;\n        auto rowId = Uuid::Create();\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Instrument(), instrumentOne.GetIdentifier());\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::Venue(), go_flat::GetTestVenueId());\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::MIC(), MIC{\"XXXX\"});\n        cpUpdate.SetCalculatedProperty(rowId, go_flat::calculated_properties::position::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS(), Volume{100});\n\n        CalculatedPropertiesTable::Stream::Options options;\n        options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {});\n        cpUpdate.SetFilter(options.GetFilter());\n        cpUpdate.SetRowDataType(static_cast<CalculatedPropertiesTable::RowDataType>(5));\n        te.GetXE().UpdateCalculatedProperties(cpUpdate);\n    }\n\n    TBSTATUS(\"Prepare market data\");\n    {\n        BestPrice best;\n        best.SetBidPrice(38.0);\n        best.SetBidVolume(100);\n        best.SetAskPrice(39.0);\n        best.SetAskVolume(100);\n        te.GetMD(go_flat::GetTestVenueId()).UpdateBestPrice(viidOne, best);\n    }\n\n    TBSTATUS(\"Prepare trading information\");\n    {\n        tbricks::test::InstrumentTradingInformation iti;\n        iti.SetCurrency(\"USD\");\n        iti.SetDefaultTick(Price(0.1));\n        iti.SetLotVolume(Volume(10));\n        iti.SetMinimumVolume(Volume(10));\n        TestEngine::Get().GetTRD(viidOne.GetVenueIdentifier()).CreateInstrumentTradingInformation(viidOne, iti);\n    }\n<fim-suffix><fim-middle>    TBSTATUS(\"Setup the app\");\n    {\n        StrategyOptions options(go_flat::plug_ins::GoFlat());\n        appId = te.CreatePlugin(options, {}, true);"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT, PUBLIC_GetInstruments, }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; case DeribitMethod::PUBLIC_GetInstruments: return \"public\/get_instruments\"; default: return {}; } } enum class DeribitSubscription<fim-suffix><fim-middle>{ NONE,"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\" #include \"PositionsData.h\" #include \"tbricks_definitions.h\" #include \"execution\/TbOrderManager.h\" #include \"execution\/TbOrderMinion.h\" #include \"execution\/TbChildOrder.h\" #include <AsyncTask.h> #include <memory> using namespace tbricks; namespace sp = go_flat::strategy_parameters; GoFlatPlugin::GoFlatPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_portfolio(sp::Portfolio()) , m_statusText(sp::PlugInStatusDescription()) , m_executorType(execution::OrderExecutorType::ORDER_MANAGER) { TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered()); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); switch (m_executorType) { case execution::OrderExecutorType::ORDER_MANAGER: m_orders = std::make_unique<execution::TbOrderManager>(*this); break; case execution::OrderExecutorType::CHILD_ORDER: m_orders = std::make_unique<execution::TbChildOrder>(*this, *this); break; case execution::OrderExecutorType::ORDER_MINION: m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters); break; } m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier()); } void GoFlatPlugin::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); \/\/m_async->DoAsync(); \/\/ UNCOMMENT if you want to fire minion orders after the async task if (not m_positions or m_positions->GetData().empty()) { SetTransactionFail(\"No positions\", StrategyState::PAUSED); return; } if (m_orders) { if (not m_positions->GetData().empty()) { for (const auto& [ivid, pos] : m_positions->GetData()) { if (m_executorType == execution::OrderExecutorType::ORDER_MINION) { execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get()); minion->MonitorInstrument(ivid); \/\/continue; \/\/ UNCOMMENT if you want to fire minion orders after the async task } TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos); if (not pos.Empty() and pos != 0.0) { \/\/ we want to flatten the position so invert the volume m_orders->CreateOrder(ivid, -pos, m_portfolio.GetPortfolioIdentifier()); } } \/\/ we don't want more position updates from now m_positions->Stop(); SetState(StrategyState::RUNNING); return; } } SetState(StrategyState::PAUSED); } void GoFlatPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_orders) { m_orders->DeleteOrders(); } SetState(StrategyState::PAUSED); } void GoFlatPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_DELETE); if (m_orders) { m_orders->DeleteOrders(); } SetState(StrategyState::DELETED); } void GoFlatPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(\"Modify request: \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); if (modifier.GetParameters().HasParameter(sp::Portfolio()) and not m_portfolio.Empty()) { m_positions = std::make_unique<PositionsData>(m_portfolio.GetPortfolioIdentifier(), m_statusText); } } void GoFlatPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); context.GetItem(m_statusText).SetDirection(ParameterDefinition::Direction::OUTPUT); if (GetState().IsRunning()) { context.GetItem(m_portfolio).SetDirection(ParameterDefinition::Direction::OUTPUT); } else { context.GetItem(m_portfolio).SetDirection(ParameterDefinition::Direction::INPUT_OUTPUT); } context.SendReply(); } void GoFlatPlugin::HandleScheduledEvent(UserData&& data) { std::string* msg = static_cast<std::string*>(data.GetData()); if (msg) { TBDUMP(msg->c_str()); } if (m_async->HasResult()) { TBNOTICE(m_async->GetResult()); } if (m_executorType == execution::OrderExecutorType::ORDER_MINION) { if (not m_positions->GetData().empty()) { for<fim-suffix><fim-middle>(const auto& [ivid, pos] : m_positions->GetData())"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const<fim-suffix><fim-middle>tbricks::Binary & data) final;"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n<fim-suffix><fim-middle>{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \": \" << stream);\n}"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream & data); void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length); private: IWebsocketHandler & m_handler; tbricks::TCPStream m_tcp; std::random_device m_rd; std::shared_ptr<std::string> nonce_base64; Config m_config; std::string host; unsigned short port; std::string path; bool m_handshake_done = false; \/\/Binary_istream<fim-suffix><fim-middle>fragmented_in_message;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string><fim-suffix>}; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t);<fim-middle>reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status)<fim-suffix><fim-middle>final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/EventProcessor.h> #include <future> namespace misc { class AsyncProcessor { private: const tbricks::EventProcessor& m_proc; tbricks::StrategyIdentifier m_id; std::string m_result; public: AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc), m_id(appId) {}; void DoAsync() { std::thread([this]{ std::this_thread::sleep_for(std::chrono::seconds(3)); m_result = \"ASYNC SUCCESS\"; tbricks::UserData payload; payload.Set(&m_result, 0); \/\/ we can do shallow copy because the string is a member variable m_proc.ScheduleStrategyEvent(m_id, payload); }).detach(); } bool HasResult() const { return not m_result.empty(); } const std::string& GetResult()<fim-suffix><fim-middle>const { return m_result; }"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n<fim-suffix><fim-middle>const DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client<fim-suffix><fim-middle>= std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"WingPreferencesStorage.h\"\n#include \"CCSPreferencesStorage.h\"\n#include \"SVIPreferencesStorage.h\"\n#include <shared\/Macros.h>\n#include <shared\/SuppressSfApiClangWarnings.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/Exception.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\nusing namespace tbricks;\n\nclass BadPreferencesStorageCast: public Exception\n{\nprivate:\n    static String PreferenceKindsToString(const PreferencesStorageKind from,\n                                          const PreferencesStorageKind to)\n    {\n        std::stringstream sstrm;\n        sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to;\n        return std::move(sstrm).str();\n    }\n\npublic:\n    BadPreferencesStorageCast(const PreferencesStorageKind from,\n                              const PreferencesStorageKind to) :\n        Exception(PreferenceKindsToString(from, to))\n    {}\n};\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage);\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage);\n\ntemplate <class PreferencesStorageRef>\nPreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage);\n\ntemplate <class PreferencesStorageRef>\nPreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage);\n\n#define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\\n    template <> \\\n    inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\\n    { \\\n<fim-suffix><fim-middle>        if (TB_UNLIKELY(!pPreferencesStorage)) { \\\n            return nullptr; \\\n        } \\\n        \\"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n<fim-suffix><fim-middle>{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to; return std::move(sstrm).str(); } public: BadPreferencesStorageCast(const PreferencesStorageKind from, const PreferencesStorageKind to) : Exception(PreferenceKindsToString(from, to)) {} }; template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage); template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage); #define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\ { \\ if (TB_UNLIKELY(!pPreferencesStorage)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY((pPreferencesStorage->GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\ throw BadPreferencesStorageCast(pPreferencesStorage->GetKind(), kind); \\ } \\ \\ return<fim-suffix>} #define PREFERENCES_STORAGE_REF_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type & pref_storage_cast(specifier PreferencesStorage & preferencesStorage) \\ { \\<fim-middle>reinterpret_cast<specifier type*>(pPreferencesStorage); \\"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template<fim-suffix>void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm,<fim-middle><>"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice<fim-suffix><fim-middle>& bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Reset(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBWARNING(__func__ << \":<fim-suffix>auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Fail(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update) { TBDEBUG(__func__ << \": \" << stream); TBDUMP(update); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->HandleDistributedValuesUpdate(update); } else { TBDEBUG(\"No Deribit model associated with stream:<fim-middle>\" << stream);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n<fim-suffix><fim-middle>    {\n        rdbuf(&_buffer);\n    }"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\nusing Method = std::pair<DeribitMethod, std::string>;\n\nstatic std::vector<Method> GetAvailableMethods()\n<fim-suffix><fim-middle>{\n    return {\n            {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)},\n            {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)},"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ } EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetIndexPrice, index_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetCurrentFunding, current_funding, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetBid, best_bid_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetAsk, best_ask_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetBidVolume, best_bid_amount, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetAskVolume, best_ask_amount,<fim-suffix><fim-middle>0) } \/\/ namespace deribit"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class InstrumentEnricherPlugin : public tbricks::Strategy { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest()<fim-suffix>void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier<fim-middle>final; void HandleRunRequest() final;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n<fim-suffix><fim-middle>{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n<fim-suffix><fim-middle>void TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;"}
{"content":"<fim-prefix>#pragma once\n\n#include <string_view>\n#include <strategy\/type\/String.h>\n\nnamespace deribit {\n\nstruct RapidDocument;\n\nclass UpdateData\n{\npublic:\n    UpdateData();\n    virtual ~UpdateData();\n\n    std::string_view ToString();\n    void Parse(const tbricks::String& str);\n\nprotected:\n    RapidDocument* m_doc;\n};\n\nclass ticker_update : public UpdateData\n{\npublic:\n    ticker_update(const tbricks::String& str);\n\n    std::string_view GetInstrumentName();\n\n    int64_t GetTimestamp();\n    bool IsOpen();\n\n    double GetSettlementPrice();\n    double GetOpenInterest();\n    double GetMinPrice();\n    double GetMaxPrice();\n    double GetMarkPrice();\n    double GetLastPrice();\n    double GetIndexPrice();\n    double GetCurrentFunding();\n\n    double GetBid();\n    double GetAsk();\n    double GetBidVolume();\n    double GetAskVolume();\n};\n<fim-suffix><fim-middle>} \/\/ deribit"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\" using namespace tbricks; InstrumentManager::InstrumentManager(IHandler& handler) : m_handler(handler) , m_instrumentStream(*this) , m_iapStream(*this) { TBDEBUG(__func__ << \" ctor\"); } InstrumentManager::~InstrumentManager() { TBDEBUG(__func__ << \" dtor\"); Stop(); } void InstrumentManager::Stop() { TBDEBUG(__func__); m_instrumentCache.clear(); m_underlyingCache.clear(); m_instrumentStream.Close(); } void InstrumentManager::Start() { TBDEBUG(__func__); Stop(); OpenInstrumentStream(); } void InstrumentManager::OpenInstrumentStream() { TBDEBUG(__func__); InstrumentStream::Options options; options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup())); m_instrumentStream.Open(Stream::SNAPSHOT, options); TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter()); } void InstrumentManager::OpenIAPStream() { TBDEBUG(__func__); tbricks::InstrumentAggregateParameters::Stream::Options options; for (const auto& [instId, _] : m_instrumentCache) { options.AddInstrument(instId); } options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()}); m_iapStream.Close(); m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options); TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options); } void InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); } void InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID) { TBWARNING(\"Instrument cache stream staled = \" << streamID); } void InstrumentManager::HandleStreamFailed(const StreamIdentifier& streamID) { m_handler.HandleInstrumentManagerFailed(\"Instrument stream failed\"); } void InstrumentManager::HandleSnapshotEnd(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" <<<fim-suffix>{ TBDEBUG(\"Instruments snapshot done, enriching...\"); OpenIAPStream(); } else if (streamID == m_iapStream.GetIdentifier()) { \/\/ All data is collected, now perform the next steps EnrichInstruments(); } } void InstrumentManager::HandleInstrument(const StreamIdentifier& streamID, const Instrument& instrument) { TBDEBUG(__func__ << \" : stream = \" << streamID << \", instrument ID = \" << instrument.GetIdentifier()); TBDUMP(instrument); if (streamID == m_instrumentStream.GetIdentifier()) { m_instrumentCache[instrument.GetIdentifier()] =<fim-middle>streamID); if (streamID == m_instrumentStream.GetIdentifier())"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler & handler)\n    : m_instrumentStream(*this)\n    , m_handler(handler)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Clear()\n<fim-suffix><fim-middle>{\n    m_tbricksInstruments.clear();\n    m_deribitInstruments.clear();\n    m_pendingCreates.clear();"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n<fim-suffix><fim-middle>static std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n<fim-suffix><fim-middle>        m_index += str.size();\n    }"}
{"content":"<fim-prefix>#include \"IVolatilityModel.h\" #include<fim-suffix><fim-middle>\"ConstantVolatility.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\""}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::OpenCIVStream()\n{\n    CalculatedInstrumentValues::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrumentVenueIdentification(InstrumentVenueIdentification(instId));\n    }\n    options.AddValue(calculated_values::UnderlyingPrice());\n\n    auto throttle = MaximumUpdateTimeThrottle(Duration::Seconds(5));\n    options.SetThrottle(throttle);\n    m_calculatedValuesStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened calculated instrument values stream : \" << m_calculatedValuesStream.GetIdentifier() << \" with options : \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n        OpenCIVStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        m_instrumentCache[instrument.GetIdentifier()].instrument = instrument;\n\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()].maturityDate = tbMaturityDate;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_instrumentCache[instrumentID].underlyingInstrument = underlyingId;\n    }\n}\n\nvoid InstrumentManager::HandleCalculatedInstrumentValues(const StreamIdentifier& streamId,\n                                                         const CalculatedInstrumentValues::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamId);\n    TBDUMP(update);\n\n    if (streamId != m_calculatedValuesStream.GetIdentifier())\n    {\n        TBWARNING(__func__ << \": update for unknown CV stream \" << streamId << \" = \" << update);\n        return;\n    }\n    \n    CalculatedInstrumentValues::Update::Iterator it(update);\n\n    while (it != update.end())\n    {\n        const auto& instrumentID = it.GetRowInfo().GetIVID().GetInstrumentIdentifier();\n        if (it.GetColumnId() == calculated_values::UnderlyingPrice().GetIdentifier())\n        {\n            const auto& oldUnderlyingPrice = m_instrumentCache[instrumentID].underlyingPrice;\n            const auto& newUnderlyingPrice = it.GetValue().GetPrice();\n            TBDUMP(\"New CV Underlying price : \" << oldUnderlyingPrice << \"->\" << newUnderlyingPrice);\n            if (newUnderlyingPrice != oldUnderlyingPrice)\n            {\n                m_instrumentCache[instrumentID].underlyingPrice = newUnderlyingPrice;\n            }\n        }\n        ++it;\n    }\n}\n\nvoid InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n    {\n        const int total = m_instrumentCache.size();\n<fim-suffix><fim-middle>        std::stringstream result;\n        result << \"Total instruments = \" << total << \", successful = \" << total - m_failed\n               << \", failed = \" << m_failed;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n<fim-suffix><fim-middle>template <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n<fim-suffix><fim-middle>{\npublic:\n    virtual ~IWebsocketHandler() = default;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);\n\n     if (id.second != m_tickerId)\n    {\n        TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);\n        return;\n    }\n\n<fim-suffix><fim-middle>    if (value.Empty() or (value == \"{}\") or value.HasError())\n    {\n        Price emptyPrice;\n        Volume emptyVolume {0};"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if<fim-suffix>if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary()<fim-middle>(eof()) throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const<fim-suffix>void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override;<fim-middle>tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification<fim-suffix>tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem;<fim-middle>& id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; explicit InstrumentManager(IHandler& handler); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier&<fim-suffix>void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler interface void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId, const tbricks::CalculatedInstrumentValues::Update & update) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final; private: void OpenInstrumentStream(); void OpenIAPStream(); void OpenCIVStream(); void EnrichInstruments(); void ModifyGroup(); void CheckResolutionStatus(); void CheckModificationStatus(); struct InstrumentDetails { tbricks::Instrument instrument; tbricks::DateTime maturityDate; tbricks::InstrumentIdentifier underlyingInstrument; tbricks::Price underlyingPrice; }; using<fim-middle>stream, const tbricks::Instrument& instrument) final;"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindPreferencesStorageByScopeDefinition(const ScopeDefinition & scope) const\n{\n    switch (scope.type)\n    {\n    case enumerations::VolatilityManagerPersistentPreferencesScopeUser:\n        return (scope.id == m_provider.GetUserIdentifier().GetUuid()) ? m_pUserScopePreferencesStorage.get() : nullptr;\n    case enumerations::VolatilityManagerPersistentPreferencesScopeProduct:\n        return FindProductScopePreferencesStorage(scope.id);\n    case enumerations::VolatilityManagerPersistentPreferencesScopeMaturity:\n        return FindMaturityScopePreferencesStorage(scope.id);\n    default:\n        return nullptr;\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductGroupIdsWithExistingPersistentPreferences(SparseSet<InstrumentGroupIdentifier> & productGroupIds) const\n{\n    productGroupIds.clear();\n    productGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & pair: m_productScopePreferencesStorages) {\n        TB_UNUSED(productGroupIds.insert(pair.first));\n    }\n}\n<fim-suffix><fim-middle>void PersistentPreferencesManagerCore::GetProductAndMaturityGroupIdsWithExistingPersistentPreferences(SparseHash<InstrumentGroupIdentifier, SparseSet<InstrumentGroupIdentifier>> & productAndMaturityGroupIds) const\n{\n    productAndMaturityGroupIds.clear();\n    productAndMaturityGroupIds.resize(m_productScopePreferencesStorages.size());"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override; \/\/ MDTracker::IHandler void HandleBBOUpdate( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::BestPrice& before, const tbricks::BestPrice& change ) override; void HandleSnapshotEnd(const tbricks::InstrumentVenueIdentification& ivid) override; private: void EmergencyStop(); void<fim-suffix>const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, const tbricks::Price& price, const tbricks::Side& side, const tbricks::PortfolioIdentifier& portfolio); tbricks::Price RoundPriceToTicks(const tbricks::Price& price, const tbricks::Side& side, const tbricks::InstrumentVenueIdentification& ivid); void UpdateStats(const tbricks::Order::Update& update, const tbricks::Order& current); private: tbricks::Hash<tbricks::OrderIdentifier, tbricks::Order> m_orderData; tbricks::Hash<tbricks::Identifier, tbricks::OrderIdentifier> m_requests; tbricks::Hash<tbricks::InstrumentVenueIdentification, tbricks::OrderIdentifier> m_activeOrders; private: struct OrderRequest { tbricks::InstrumentVenueIdentification ivid;<fim-middle>DeleteSingleOrder(const tbricks::OrderIdentifier& id); void CreateSingleOrder("}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short<fim-suffix>public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary &<fim-middle>default_port = 80; };"}
{"content":"<fim-prefix>#ifndef TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H #define TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H \/** * This file is intended to introduce definitions of the customized metadata * items like instrument parameters or calculated values that are not supported * in the original version of the<fim-suffix>*<fim-middle>Pricing app."}
{"content":"<fim-prefix>#include \"TbOrderManager.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbOrderManager::TbOrderManager(IExecutionHandler& handler)\n: OrderExecutor(handler)\n{\n    TBDEBUG(__func__);\n}\n\nTbOrderManager::~TbOrderManager()\n{\n    TBDEBUG(__func__);\n    if (!m_orderData.empty())\n    {\n        DeleteOrders();\n    }\n}\n\nvoid TbOrderManager::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume, \/\/ negative for sell\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n\n    if (BestPrice bbo; m_md.GetBBO(ivid, bbo))\n    {\n        if (volume < 0.0 and bbo.HasBidPrice())\n        {\n            CreateSingleOrder(ivid, volume.Abs(), bbo.GetBidPrice(), Side::SELL, portfolio);\n        }\n        else if (volume > 0.0 and bbo.HasAskPrice())\n        {\n            CreateSingleOrder(ivid, volume.Abs(), bbo.GetAskPrice(), Side::BUY, portfolio);\n        }\n        else\n        {\n            TBWARNING(\"Missing price for \" << ivid);\n        }\n    }\n    else\n    {\n        m_md.Subscribe(ivid, this, TRACK_BBO);\n        m_orderQueue[ivid] = {ivid, volume, portfolio};\n        TBDEBUG(\"Waiting bbo for \" << ivid);\n    }\n}\n\nvoid TbOrderManager::DeleteOrders()\n{\n    TBDEBUG(__func__);\n    if (m_orderData.empty())\n    {\n        return;\n    }\n\n    for (Hash<OrderIdentifier, Order>::const_iterator it = m_orderData.begin(); it != m_orderData.end(); ++it)\n    {\n        DeleteSingleOrder(it->first);\n    }\n}\n\nvoid TbOrderManager::CreateSingleOrder(const InstrumentVenueIdentification& ivid, const Volume& volume, const Price& price, const Side& side, const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__);\n    TBDUMP(\"IVID=\" << ivid << \", vol=\" << volume << \", price=\" << price << \", side=\" << side << \", portfolio=\" << portfolio);\n    Order::Options orderOptions;\n    orderOptions.SetPortfolioIdentifier(portfolio);\n    orderOptions.SetValidity(Validity::VALID_IMMEDIATE);\n    orderOptions.SetInstrumentVenueIdentification(ivid);\n    orderOptions.SetActiveVolume(volume);\n    orderOptions.SetSide(side);\n    if (not price.Empty())\n    {\n        orderOptions.SetPrice(RoundPriceToTicks(price, side, ivid));\n    }\n    OrderCreateRequestResult req = OrderManager::SendCreateRequest(orderOptions, *this);\n    TBDUMP(\"Send order: \" << orderOptions);\n    m_requests[req.GetRequestIdentifier()] = req.GetOrderIdentifier();\n    m_activeOrders[ivid] = req.GetOrderIdentifier();\n}\n<fim-suffix><fim-middle>Price TbOrderManager::RoundPriceToTicks(const Price& price, const Side& side, const InstrumentVenueIdentification& ivid)\n{\n    TBDEBUG(__func__ << \": price=\" << price << \", side=\" << side << \", ivid=\" << ivid);\n    InstrumentTradingInformation tick_rules(ivid);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/String.h> #include <strategy\/type\/Volume.h><fim-suffix>struct Stats { tbricks::Volume bought; tbricks::Volume sold; tbricks::Double valueBought; tbricks::Double valueSold; }; enum class OrderExecutorType { ORDER_MANAGER, CHILD_ORDER, ORDER_MINION }; class IExecutionHandler { public: ~IExecutionHandler()<fim-middle>namespace execution {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler()<fim-suffix><fim-middle>= default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return false;\n}\n<fim-suffix><fim-middle>void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";"}
{"content":"<fim-prefix>#pragma once<fim-suffix>#include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) =<fim-middle>#include <strategy\/stream\/TCPStream.h>"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode<fim-suffix><fim-middle>SetState(StrategyState::PAUSED); }"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (m_volatility_model->IsInterpolated()) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group\n    , const InstrumentGroupAggregateParameters::Update & update)\n{\n    return HandleVolatilityGroupParameters(&update);\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group)\n{\n    PDEBUGN(\"Handle volatility group parameters snapshot done\");\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerSnapshot(m_group);\n    }\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType()\n{\n    PDEBUGN(\"VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType\");\n    if (SwitchVolatilityModel()) {\n        for (auto subscriber : m_subscribers) {\n            subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n        }\n    }\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParameters(const InstrumentGroupAggregateParameters::Update * update)\n{\n    PDEBUGN(\"Handle volatility group parameters\");\n    if (update) {\n        PDUMPN(\"Update = \" << *update);\n    }\n\n    bool changed = false;\n\n    changed |= SwitchVolatilityModel();\n    if (!changed && m_volatility_model) {\n        if (update) {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*update, *m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        } else {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        }\n    }\n\n    if (changed) {\n        m_volatility_models.clear();\n    }\n\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n    }\n\n    return changed;\n}\n\nbool VolatilityCurveHandler::SwitchVolatilityModel()\n{\n    PDEBUGN(\"Switch volatility model\");\n    if (!m_parameters_provider) return false;\n\n    const Integer & type = m_parameters_provider->GetVolatilityModelType();\n    PDEBUGN(\"New volatility model type \" << type);\n<fim-suffix><fim-middle>    const VolatilitySurfaceContainer * container = m_parameters_provider->GetVolatilitySurfaceContainer();\n    const auto interpolated = container && volatility::InterpolatedVolatilityModel::IsApplicable(*container, m_plugin.GetVolatilitySurfaceDefinitions(type), m_maturity_date);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n<fim-suffix><fim-middle>class Binary_istream\n{\npublic:\n    Binary_istream()"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/VisualizationApp.h> #include <strategy\/visualization\/ViewModelUpdate.h> #include <strategy\/visualization\/ICellValue.h> #include <strategy\/visualization\/Grid.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::VisualizationApp , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters<fim-suffix>void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VisualizationApp methods void<fim-middle>& parameters); \/\/ Strategy methods     void HandleDeleteRequest() final;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError =<fim-suffix><fim-middle>false; DeribitMethod jrpcMethod = DeribitMethod::NONE;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default;<fim-suffix>void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier)<fim-middle>protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp     void HandleRunRequest() override;"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate) HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight) HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight) HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price,<fim-suffix>VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double, NextDividend) VALUE(next_dividend_date, Date, NextDividendDate) VALUE(underlying_settlement_date, Date, UnderlyingSettlementDateUsed) VALUE(final_settlement_date, Date, FinalSettlementDateUsed) VALUE(next_call_put_date, DateTime, NextCall_DIV_PutDate) VALUE(days_to_next_dividend, Integer, DaysToNextDividend) VALUE(trading_days_to_next_dividend, Integer, TradingDaysToNextDividend) VALUE(days_to_maturity, Integer, DaysToMaturity) VALUE(time_to_next_dividend, Double, TimeToNextDividend) VALUE(months_to_maturity, Double, MonthsToMaturity) VALUE(years_to_maturity, Double, YearsToMaturity) VALUE(longest_days_to_maturity, Integer, LongestDaysToMaturity) VALUE(longest_months_to_maturity, Double, LongestMonthsToMaturity) VALUE(longest_years_to_maturity, Double, LongestYearsToMaturity) VALUE(vol_days_to_maturity, Integer,<fim-middle>Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n<fim-suffix><fim-middle>{\npublic:\n    struct Error\n    {"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n<fim-suffix><fim-middle>    JsonCall(const std::string_view id, DeribitMethod method);\n};"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const<fim-suffix><fim-middle>InstrumentVenueIdentification & ivid)"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95; const int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally; const double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1; const double CCS_MODEL_MINIMAL_STRIKE = 1.0e-6; const double CCS_MODEL_MINIMAL_SMOOTHNESS = 0.0; const double CCS_MODEL_DEFAULT_SMOOTHNESS = 1.0; const int CCS_MODEL_MINIMAL_NUMBER_OF_CCS_POINTS = 2; const int CCS_MODEL_MAXIMAL_NUMBER_OF_CCS_POINTS = 30; const double CCS_MODEL_DEFAULT_SLOPE_LEFT = -0.05; const double CCS_MODEL_DEFAULT_SLOPE_RIGHT = 0.05; const double CCS_MODEL_DEFAULT_BREAKPOINT_SCALE_FACTOR = 1.0; const double CCS_MODEL_MINIMAL_BREAKPOINT_SCALE_FACTOR = 0.0; const int CCS_MODEL_DEFAULT_ABSCISSA = 0; const double CCS_MODEL_DEFAULT_SLOPE_MULT = 1; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER = 1.0; const double CCS_MODEL_DEFAULT_CCS_BASE_SMILE_WEIGHT = 1.0; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER_SMILE_WEIGHT = 0.0; const double CCS_MODEL_DEFAULT_MULTIPLIER_RATIO = 0.0; const double SVI_MODEL_DEFAULT_A = 0.04; const double SVI_MODEL_DEFAULT_B = 0.4; const double SVI_MODEL_DEFAULT_RHO = -0.4; const double SVI_MODEL_DEFAULT_M = 0.05; const double SVI_MODEL_DEFAULT_SIGMA = 0.1; \/* * Volatility managers need Forward price to fit volatility model parameters * so when there is empty volatility model initially, Pricing cannot calculate * Forward price for underlyings paying capped dividends because the reference volatility is required * for its calculation thus giving us so called chicken-and-egg problem. * 20% volatility is assumed to be a good starting point taking into account * that it does not influence significantly in most of the cases on the resulting Forward price. *\/ constexpr double EMPTY_MODEL_DEFAULT_REFERENCE_VOLATILITY = 0.2; } \/\/ namespace volatility_model_constants #endif \/\/<fim-suffix><fim-middle>__TBRICKS__APPS__SHARED__VOLATILITY__VOLATILITY_MODEL_CONSTANTS__H"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetState(StrategyState::RUNNING); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void<fim-suffix>{ TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext<fim-middle>DeribitContributor::HandleDeleteRequest()"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override;<fim-suffix><fim-middle>void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override;"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION:<fim-suffix>return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod,<fim-middle>return \"subscription\"; case DeribitMethod::HEARTBEAT:"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/order_minion\/OrderMinionController.h\" #include \"shared\/order_minion\/OrderMinionRequest.h\" namespace execution { class TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler { public: TbOrderMinion(IExecutionHandler& handler, tbricks::Strategy& app, const tbricks::InitializationReason& reason,<fim-suffix>~TbOrderMinion(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; void MonitorInstrument(const tbricks::InstrumentVenueIdentification& ivid); protected: \/\/ OrderMinionRequest::IHandler void HandleOrderMinionUpdate( const OrderMinionUpdate& update ) override; private:<fim-middle>const tbricks::StrategyParameters& parameters);"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus &<fim-suffix>void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem<fim-middle>iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream & data); void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length); private: IWebsocketHandler & m_handler; tbricks::TCPStream m_tcp; std::random_device m_rd;<fim-suffix>Config m_config; std::string host; unsigned short port; std::string path; bool m_handshake_done =<fim-middle>std::shared_ptr<std::string> nonce_base64;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename<fim-suffix><fim-middle>T> void write(const T & t)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data)<fim-suffix>void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private:<fim-middle>final; void HandleStreamOpen(tbricks::TCPStream & stream) final;"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest()<fim-suffix><fim-middle>override; void HandleDeleteRequest() override;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream<fim-suffix>void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const<fim-middle>void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See<fim-suffix><fim-middle>http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information.     void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n<fim-suffix><fim-middle>    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)"}
{"content":"<fim-prefix>#include \"PositionsData.h\" #include \"tbricks_definitions.h\" #include <strategy\/Logger.h> #include <strategy\/stream_filter\/PositionByPortfolioFilter.h> #include <strategy\/SparseSet.h> #include <sstream> #include <vector> using namespace tbricks; namespace cps = go_flat::calculated_properties::position; PositionsData::PositionsData(const PortfolioIdentifier& portfolioId, StringParameter& status) : m_appStatus(status) , m_stream(*this) { TBDEBUG(__func__ << \" : \" << portfolioId); CalculatedPropertiesTable::Stream::Options options; options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {}); options.AddProperty(cps::Instrument()); options.AddProperty(cps::Venue()); options.AddProperty(cps::MIC()); options.AddProperty(cps::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS()); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); TBDUMP(\"Stream opened with options: \" << options); } PositionsData::~PositionsData() { TBDEBUG(__func__); m_stream.Close(); } void PositionsData::Stop() { TBDEBUG(__func__); m_stream.Close(); } void PositionsData::HandleStreamOpen(const StreamIdentifier& stream) { m_appStatus = \"Waiting for positions data\"; } void PositionsData::HandleStreamStale(const StreamIdentifier& stream) { m_appStatus = \"STALE STREAM for positions data\"; } void PositionsData::HandleStreamFailed(const StreamIdentifier& stream) { m_appStatus = \"FAILED STREAM for positions data\"; } void PositionsData::HandleSnapshotEnd(const StreamIdentifier& stream) { TBDEBUG(__func__ << \" : \" << stream); RefreshStatusText(); } void PositionsData::HandleCalculatedProperties(const StreamIdentifier & stream_id, const CalculatedPropertiesTable::Update & update) { TBDEBUG(__func__ << \" : \" << update); m_table.Merge(update); if (m_stream.IsSnapshotDone()) { RefreshStatusText(); } } void PositionsData::RefreshStatusText() { std::stringstream ss; ss << \"Received \" <<<fim-suffix>size_t valid_ivids = 0; for (const auto& row : m_table.GetRows()) { InstrumentVenueIdentification ivid; Volume pos; const auto& cols = row.second; TBDUMP(cols); for (const auto& c : cols) { if (c.first == cps::Instrument().GetIdentifier()) { ivid.SetInstrumentIdentifier(c.second.GetInstrumentIdentifier()); } else if (c.first == cps::MIC().GetIdentifier()) { ivid.SetMIC(c.second.GetMIC()); } else if (c.first == cps::Venue().GetIdentifier()) { ivid.SetVenueIdentifier(c.second.GetIdentifier()); } else if (c.first == cps::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS().GetIdentifier()) { pos = c.second.GetVolume(); } } if (ivid.GetInstrumentIdentifier().Empty() or ivid.GetVenueIdentifier().Empty() or ivid.GetMIC().Empty()) { TBDEBUG(\"Invalid<fim-middle>m_table.GetRows().size() << \" positions\" << std::endl;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class<fim-suffix><fim-middle>DeribitModel"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\" #include \"tbricks_definitions.h\" #include <cstdlib> #include <set> using namespace tbricks; ExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin2::HandlePricingModifyRequest(const PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin2::Calculate(const RequestAndIVIDs & values, const CalculatedValuesRequestFull & request) { m_rows = values; for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, civ_it.GetColumnId(), x); } } else { TBERROR(\"System asked for calculation which the plugin does not support!\"); } } Send(); } void ExampleCalcAppPlugin2::Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x) { CalculatedValueIdentifier calc_id(rowId, columnId); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } bool ExampleCalcAppPlugin2::HandlePartialPricingModifyRequest(const CalculatedValuesRequestUpdate &update) { if (update.GetRowsBegin() != update.GetRowsEnd()) { return false; } for(auto it = update.GetColumnsBegin(), end = update.GetColumnsEnd(); it != end; ++it) { if (it.GetColumnInfo().GetState() == CalculatedValuesRequestUpdate::State::UPDATE) { if( it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; it.GetColumnInfo().GetStrategyParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, it.GetColumnId(), x); } } else { TBERROR(\"System asked for calculation which the plugin does<fim-suffix><fim-middle>not support!\");"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\"\n#include \"StochasticVolatilityInspired.h\"\n#include \"ClampedCubicSpline.h\"\n#include \"WingVolatilityModel.h\"\n#include \"ConstantVolatility.h\"\n\nusing namespace tbricks;\nusing namespace volatility;\n\nIVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType)\n{\n#define VOLATILITY_MODEL_WRAP(name, type) \\\n    case VolatilityModel##name: \\\n        return new type;\n\n    switch(volatilityModelType)\n    {\n#include \"VolatilityModelList.h\"\n        default:\n            return nullptr;\n#undef VOLATILITY_MODEL_WRAP\n    }\n}\n\nSharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType)\n{\n    return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType));\n}\n\nstd::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType)\n{\n    std::vector<InstrumentParameterDefinition> defs;\n\n#define VOLATILITY_MODEL_WRAP(name, type) \\\n    case VolatilityModel##name: \\\n        { \\\n            volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\\n            return defs; \\\n        }\n\n    switch(volatilityModelType)\n    {\n#include \"VolatilityModelList.h\"\n    default:\n        return defs;\n#undef VOLATILITY_MODEL_WRAP\n    }\n}\n<fim-suffix><fim-middle>std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType)\n{\n    std::vector<InstrumentParameterDefinition> defs;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture<fim-suffix><fim-middle>maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed.         std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void<fim-suffix><fim-middle>TimerController::Update(const StrategyParameters& strategyParameters)"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n<fim-suffix><fim-middle>        {\n            parsed_host_port.second = default_port;\n        }\n    }"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default:<fim-suffix><fim-middle>return {}; } }"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include \"MyCustomPreferencesStorage.h\" #include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>(); case VolatilityModelSVI: return std::make_unique<SVIPreferencesStorage>(); case custom::pricing::extended_enums::VolatilityModelMyCustom:<fim-suffix><fim-middle>return std::make_unique<MyCustomPreferencesStorage>();"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/type\/Price.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/Boolean.h> #include <strategy\/calculated_property\/CalculatedPropertyFilter.h> #include <strategy\/TreeNodeParameters.h> #include <strategy\/parameter\/StrategyParameters.h> #include <strategy\/parameter\/StrategyInstanceParameters.h> CLANG_RESTORE_WARNINGS #include <set> using namespace tbricks; enum class PreferencesStorageKind { Common = 0, Wing, CCS, SVI }; std::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind); \/** * Struct representing the various settings common to all VMs; it is subclassed by structs * containing additional parameters relevant for particular VMs *\/ class PreferencesStorage: public Printable { public: PreferencesStorage(); protected: PreferencesStorage(const PreferencesStorage & storage) = default; PreferencesStorage & operator=(const PreferencesStorage & storage) = default; public: virtual ~PreferencesStorage(); virtual PreferencesStorageKind GetKind() const = 0; virtual void Clear(); virtual void Copy(const PreferencesStorage & preferencesStorage); virtual bool FillFromTreeNodeParameters(const TreeNodeParameters & parameters); virtual bool FillFromStrategyParameters(const StrategyParameters & parameters); virtual bool FillFromStrategyInstanceParameters(const StrategyInstanceParameters & parameters); virtual bool GetParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetParameters(TreeNodeParameters & parameters) const; virtual void GetParameters(StrategyParameters & parameters) const; virtual void GetParameters(StrategyInstanceParameters & parameters) const; virtual bool GetNonDefaultParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetNonDefaultParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetNonDefaultParameters(TreeNodeParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyInstanceParameters & parameters) const; \/\/ Update local values with non-empty values from the passed in preferences storage; \/\/ return true if something got changed as a result, false otherwise virtual bool Merge(const PreferencesStorage & preferencesStorage); virtual std::ostream & Print(std::ostream & strm) const override; \/\/ List of preferences that shouldn't be copied to other scope levels virtual const std::set<TreeNodeParameterDefinition> & GetLevelAnchoredParameters() const { return m_scopeLevelAnchoredPreferences; } \/\/ In case it is necessary to include all the exotic instruments, \/\/ we can't persist empty filter since it would be aggregated. \/\/ Hence, this dummy non-empty filter needs to be used for clear operations. static const CalculatedPropertyFilter<fim-suffix>\/\/ Autofit settings ValueWithDefault<Boolean> autoFit; ValueWithDefault<Boolean> autoApplyAutoFit; ValueWithDefault<Boolean> globalAvoidExtraFits; ValueWithDefault<Boolean> globalUnderlyingTradingStatusTracking; ValueWithDefault<Boolean> optionTradingStatusTracking; ValueWithDefault<Integer> loggingMode; ValueWithDefault<Integer> maxAllowedFitRejects; ValueWithDefault<Boolean> maturityExcludedFromGlobalActions; ValueWithDefault<Boolean> sendQuotingRecommendations; ValueWithDefault<Table> quotingRecommendations; \/\/ General settings ValueWithDefault<Boolean> parallelShift; ValueWithDefault<Enumeration> curveShiftUnits; ValueWithDefault<Integer> ATMVolatilityShiftMode; ValueWithDefault<Boolean> includeExoticOptions; ValueWithDefault<Boolean> autoFetchATMVolatilityPath; ValueWithDefault<Boolean> globalAutoFetchATMVolatilityPath; ValueWithDefault<Integer> instrumentGroupType; ValueWithDefault<Identifier> suggestContext; ValueWithDefault<Integer> trackingAreaType; ValueWithDefault<Boolean> volatilityCurveSafetyCheckEnabled; ValueWithDefault<Double> safetyParameterChange; ValueWithDefault<Double> safetyModelChange; ValueWithDefault<Boolean> checkForStaticArbitrage; ValueWithDefault<Double> calendarSpreadArbitrageTolerance; ValueWithDefault<Double> butterflyArbitrageTolerance; ValueWithDefault<Boolean> enableCurveQualityMetrics; \/\/ Fit settings ValueWithDefault<Integer> fitWeighting; ValueWithDefault<Boolean> autocorrectFitWeights; ValueWithDefault<Boolean> fitOnlyATMVol; ValueWithDefault<Boolean> addVirtualBids; ValueWithDefault<Double> virtualBidRatio; ValueWithDefault<Boolean> robustFittingOnWings; ValueWithDefault<Double> robustFittingOnWingsStrength; ValueWithDefault<Boolean> autoResetSwimRefPriceToATM; ValueWithDefault<Integer> crossingProcessing; ValueWithDefault<Boolean> anomalyDetection; ValueWithDefault<Double> anomalyDetectionSensitivity; \/\/ Implied vol filtering ValueWithDefault<Boolean> enableAmerican; ValueWithDefault<Boolean> enableATM; ValueWithDefault<Boolean> enableDeepITM; ValueWithDefault<Boolean> enableDeepOTM; ValueWithDefault<Boolean> enableEuropean; ValueWithDefault<Boolean> enableITM; ValueWithDefault<Boolean> enableCashDelivery; ValueWithDefault<Boolean> enableCrossings; ValueWithDefault<Boolean> enableLowBids; ValueWithDefault<Boolean> enablePhysicalDelivery; ValueWithDefault<Boolean> enableSmallDelta; ValueWithDefault<Boolean> enableWideSpreads; ValueWithDefault<Boolean> enableNoSpreads; ValueWithDefault<Boolean> enableOTM;<fim-middle>dummyFilter;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config<fim-suffix>\/\/\/ Idle timeout. Defaults to no timeout. long<fim-middle>{ \/\/\/ Timeout on request handling. Defaults to no timeout.         long timeout_request = 0;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionReverser : public tbricks::IRequestReplyHandler { public: PositionReverser() = default; ~PositionReverser() = default; void ReversePosition( const tbricks::Position& position, const tbricks::Price& atPrice); \/\/ IRequestReplyHandler method void HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) final; private: std::map<tbricks::Identifier,<fim-suffix><fim-middle>tbricks::Identifier> m_reversedPositions; };"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class InstrumentEnricherPlugin : public tbricks::Strategy { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; private: \/\/ app parameters tbricks::ParameterDefinition \/*InstrumentGroup*\/ m_instrumentGroup; tbricks::DateTimeParameter<fim-suffix><fim-middle>m_maturityDate; tbricks::StringParameter m_plugInStatusDescription;"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbChildOrder : public OrderExecutor, public tbricks::StrategyStream::IHandler, public tbricks::IRequestReplyHandler { public: TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app); ~TbChildOrder(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream)<fim-suffix>void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ StrategyStream::IHandler void HandleStrategyUpdate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyUpdate & update) final; void HandleStrategyInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyIdentifier & id) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier&<fim-middle>final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include \"shared\/app\/app.h\"\nCLANG_RESTORE_WARNINGS\n\n#include <limits>\n\nusing namespace tbricks;\n\nclass ValuesRequest;\n\nstruct ImpliedValue\n{\n    void Clear();\n\n    friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value)\n    { return value.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    Double implied_volatility;\n};\n\nstruct FairPriceValue\n{\n    FairPriceValue & operator += (const FairPriceValue & fair_price_value);\n    FairPriceValue & operator += (const Double & value);\n    FairPriceValue   operator *  (const Double & mult) const;\n    FairPriceValue & operator *= (const Double & mult);\n\n    void Clear();\n\n    bool SetError(const String & error);\n\n    friend std::ostream & operator << (std::ostream & strm, const FairPriceValue & price)\n<fim-suffix><fim-middle>    { return price.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);\n\n     if (id.second != m_tickerId)\n<fim-suffix><fim-middle>    {\n        TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);\n        return;\n    }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned<fim-suffix><fim-middle>char fin_rsv_opcode = 129);"}
{"content":"<fim-prefix>#include \"Values.h\"\n#include \"ValuesRequest.h\"\n\nvoid ImpliedValue::Clear()\n{\n    implied_volatility.Clear();\n}\n\nstd::ostream & ImpliedValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"] \" << implied_volatility;\n    return strm;\n}\n\nFairPriceValue & FairPriceValue::operator += (const FairPriceValue & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.fair_price.Empty()) {\n        fair_price += fair_price_value.fair_price;\n    } else if (fair_price_value.fair_price.HasError()) {\n        fair_price.SetError(fair_price_value.fair_price.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue & FairPriceValue::operator += (const Double & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.Empty()) {\n        fair_price += fair_price_value;\n    } else if (fair_price_value.HasError()) {\n        fair_price.SetError(fair_price_value.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue FairPriceValue::operator * (const Double & mult) const\n{\n    FairPriceValue fair_price_value = *this;\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price_value.fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price_value.fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price_value.fair_price.Clear();\n    }\n    return fair_price_value;\n}\n\nFairPriceValue & FairPriceValue::operator *= (const Double & mult)\n{\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nvoid FairPriceValue::Clear()\n{\n    fair_price.Clear();\n}\n\nbool FairPriceValue::SetError(const String & error)\n<fim-suffix><fim-middle>{\n    if (error == fair_price.GetError()) {\n        return false;\n    }"}
{"content":"<fim-prefix>#pragma once\n\n#include <string_view>\n#include <strategy\/type\/String.h>\n\nnamespace deribit {\n\nstruct RapidDocument;\n\nclass UpdateData\n{\npublic:\n    UpdateData();\n    virtual ~UpdateData();\n\n    std::string_view ToString();\n    void Parse(const tbricks::String& str);\n\nprotected:\n    RapidDocument* m_doc;\n};\n\nclass ticker_update : public UpdateData\n{\npublic:\n    ticker_update(const tbricks::String& str);\n\n    std::string_view GetInstrumentName();\n\n    int64_t GetTimestamp();\n    bool IsOpen();\n\n    double GetSettlementPrice();\n    double GetOpenInterest();\n    double GetMinPrice();\n    double GetMaxPrice();\n    double GetMarkPrice();\n    double GetLastPrice();\n    double GetIndexPrice();\n    double GetCurrentFunding();\n<fim-suffix><fim-middle>    double GetBid();\n    double GetAsk();\n    double GetBidVolume();\n    double GetAskVolume();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel {<fim-suffix>~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const<fim-middle>public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus<fim-suffix>void SendSnapshotDoneIfNeeded();<fim-middle>& iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n<fim-suffix><fim-middle>    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status<fim-suffix><fim-middle>= 1000, const std::string & reason = \"\");"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string><fim-suffix><fim-middle>Method; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods()"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\" SUPPRESS_SF_API_CLANG_WARNINGS #include \"shared\/app\/app.h\" CLANG_RESTORE_WARNINGS #include <limits> using namespace tbricks; class ValuesRequest; struct ImpliedValue { void Clear(); friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value) { return value.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double implied_volatility; }; struct FairPriceValue { FairPriceValue & operator += (const FairPriceValue & fair_price_value); FairPriceValue & operator += (const Double & value); FairPriceValue operator * (const Double & mult) const; FairPriceValue & operator *= (const Double & mult); void Clear(); bool SetError(const String & error); friend std::ostream & operator << (std::ostream & strm, const FairPriceValue & price) { return price.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t<fim-suffix><fim-middle>version = std::numeric_limits<uint64_t>::max();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler ,<fim-suffix><fim-middle>public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::IRequestReplyHandler"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n<fim-suffix><fim-middle>using namespace tbricks;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"OrderExecutor.h\"\n#include \"shared\/MDTracker.h\"\n\nnamespace execution {\n\nclass TbChildOrder : public OrderExecutor,\n                     public tbricks::StrategyStream::IHandler,\n                     public tbricks::IRequestReplyHandler\n{\npublic:\n    TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app);\n    ~TbChildOrder();\n\n    void DeleteOrders() override;\n    void CreateOrder(\n        const tbricks::InstrumentVenueIdentification& ivid,\n        const tbricks::Volume& volume, \/\/ negative for sell\n        const tbricks::PortfolioIdentifier& portfolio) override;\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;\n\n    void HandleStrategyUpdate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyUpdate & update) final;\n    void HandleStrategyInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyIdentifier & id) final;\n\n    void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override;\n\nprivate:\n<fim-suffix><fim-middle>private:\n    tbricks::Strategy& m_app;\n    tbricks::StrategyStream m_stream;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95; const int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally; const double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1; const double CCS_MODEL_MINIMAL_STRIKE = 1.0e-6; const double CCS_MODEL_MINIMAL_SMOOTHNESS = 0.0; const double CCS_MODEL_DEFAULT_SMOOTHNESS = 1.0; const int CCS_MODEL_MINIMAL_NUMBER_OF_CCS_POINTS = 2; const int CCS_MODEL_MAXIMAL_NUMBER_OF_CCS_POINTS = 30; const double CCS_MODEL_DEFAULT_SLOPE_LEFT = -0.05; const double CCS_MODEL_DEFAULT_SLOPE_RIGHT = 0.05; const double CCS_MODEL_DEFAULT_BREAKPOINT_SCALE_FACTOR = 1.0; const double CCS_MODEL_MINIMAL_BREAKPOINT_SCALE_FACTOR = 0.0; const int CCS_MODEL_DEFAULT_ABSCISSA = 0; const double CCS_MODEL_DEFAULT_SLOPE_MULT = 1; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER = 1.0; const double CCS_MODEL_DEFAULT_CCS_BASE_SMILE_WEIGHT = 1.0; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER_SMILE_WEIGHT = 0.0; const double CCS_MODEL_DEFAULT_MULTIPLIER_RATIO = 0.0; const double SVI_MODEL_DEFAULT_A = 0.04; const double SVI_MODEL_DEFAULT_B = 0.4; const double SVI_MODEL_DEFAULT_RHO = -0.4; const double SVI_MODEL_DEFAULT_M = 0.05; const double SVI_MODEL_DEFAULT_SIGMA = 0.1; \/* * Volatility managers need Forward price to fit volatility model parameters * so when there is empty volatility model initially, Pricing cannot calculate * Forward<fim-suffix><fim-middle>price for underlyings paying capped dividends because the reference volatility is required"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>(); case VolatilityModelSVI:<fim-suffix>return std::make_unique<CommonPreferencesStorage>(); } }<fim-middle>return std::make_unique<SVIPreferencesStorage>(); default:"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) { return true; } return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v !=<fim-suffix>return v->value.GetDouble(); \\ } \\ return default; \\ } EXTRACT_DOUBLE_METHOD(ticker_update::GetSettlementPrice, settlement_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetOpenInterest, open_interest, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMinPrice, min_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMaxPrice, max_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetMarkPrice, mark_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetLastPrice, last_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetIndexPrice, index_price, 0) EXTRACT_DOUBLE_METHOD(ticker_update::GetCurrentFunding, current_funding, 0)<fim-middle>msg.MemberEnd()) \\ { \\"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (m_volatility_model->IsInterpolated()) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group\n    , const InstrumentGroupAggregateParameters::Update & update)\n{\n    return HandleVolatilityGroupParameters(&update);\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group)\n{\n    PDEBUGN(\"Handle volatility group parameters snapshot done\");\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerSnapshot(m_group);\n    }\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType()\n{\n    PDEBUGN(\"VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType\");\n    if (SwitchVolatilityModel()) {\n        for (auto subscriber : m_subscribers) {\n            subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n        }\n    }\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParameters(const InstrumentGroupAggregateParameters::Update * update)\n{\n    PDEBUGN(\"Handle volatility group parameters\");\n    if (update) {\n        PDUMPN(\"Update = \" << *update);\n    }\n\n    bool changed = false;\n\n    changed |= SwitchVolatilityModel();\n    if (!changed && m_volatility_model) {\n        if (update) {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*update, *m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        } else {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        }\n    }\n\n    if (changed) {\n        m_volatility_models.clear();\n    }\n\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n    }\n\n    return changed;\n}\n\nbool VolatilityCurveHandler::SwitchVolatilityModel()\n{\n    PDEBUGN(\"Switch volatility model\");\n    if (!m_parameters_provider) return false;\n\n    const Integer & type = m_parameters_provider->GetVolatilityModelType();\n    PDEBUGN(\"New volatility model type \" << type);\n\n    const VolatilitySurfaceContainer * container = m_parameters_provider->GetVolatilitySurfaceContainer();\n    const auto interpolated = container && volatility::InterpolatedVolatilityModel::IsApplicable(*container, m_plugin.GetVolatilitySurfaceDefinitions(type), m_maturity_date);\n\n    if (m_volatility_model\n        && type == m_volatility_model->GetVolatilityModelType()\n        && interpolated == m_volatility_model->IsInterpolated())\n    {\n        PDEBUGN(\"Volatility model is not changed\");\n        return false;\n    }\n\n    bool changed = static_cast<bool>(m_volatility_model);\n    m_volatility_model.reset();\n    m_volatility_models.clear();\n\n    if (type.Empty()) {\n        PDEBUGN(\"Volatility type is empty, cached shared volatility models are cleared\");\n        return changed;\n    }\n\n    if (interpolated)\n    {\n        m_volatility_model = std::make_shared<volatility::InterpolatedVolatilityModel>(type.GetInt32());\n    } else {\n        switch(type.GetInt()) {\n            case pricing::VolatilityModelNone:\n                m_volatility_model = std::make_shared<volatility::ConstantVolatility>();\n                break;\n            case pricing::VolatilityModelCCS:\n                m_volatility_model = std::make_shared<volatility::ClampedCubicSpline>();\n                break;\n            case pricing::VolatilityModelCustom:\n                m_volatility_model = std::make_shared<volatility::CustomVolatilityModel>();\n                break;\n            case pricing::VolatilityModelWing:\n                m_volatility_model = std::make_shared<volatility::WingVolatilityModel>();\n                break;\n            case pricing::VolatilityModelSVI:\n            default:\n                m_volatility_model = std::make_shared<volatility::StochasticVolatilityInspired>();\n                break;\n        }\n    }\n\n    if (container) {\n        m_volatility_model->UpdateVolatilitySurfaceParameters(*m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n    }\n\n    PDEBUGN(\"Switched volatility model: \" << *m_volatility_model);\n<fim-suffix><fim-middle>    return true;\n}"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map><fim-suffix>{ public: class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier&<fim-middle>class PositionRetriever : public tbricks::PositionStream::IHandler"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect();<fim-suffix>\/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string &<fim-middle>void Shutdown(int status = 1000, const std::string & reason = \"\");"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <optional> struct DeribitInstrument { tbricks::String instrument_name; tbricks::String instrument_type; tbricks::String kind; tbricks::String settlement_currency; tbricks::String settlement_period; tbricks::String quote_currency; tbricks::String counter_currency; tbricks::String option_type; \/\/ \"call\" or \"put\" for options std::optional<tbricks::Double> strike; \/\/ Only for options tbricks::DateTime expiration_timestamp; tbricks::Double tick_size; tbricks::Double contract_size; tbricks::Boolean is_active;<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n<fim-suffix><fim-middle>enum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val)<fim-suffix>if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char val) { ostm.write(&val, sizeof(char)); return ostm;<fim-middle>{ int size = std::strlen(val);"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void<fim-suffix>{ TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started,<fim-middle>TimerController::Update(const StrategyParameters& strategyParameters)"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/type\/Price.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/Boolean.h> #include <strategy\/calculated_property\/CalculatedPropertyFilter.h> #include <strategy\/TreeNodeParameters.h> #include <strategy\/parameter\/StrategyParameters.h> #include <strategy\/parameter\/StrategyInstanceParameters.h> CLANG_RESTORE_WARNINGS #include <set> using namespace tbricks; enum class PreferencesStorageKind { Common = 0, Wing, CCS, SVI, MyCustom = 100000 }; std::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind); \/** * Struct representing the various settings common to all VMs; it is subclassed by structs * containing additional parameters relevant for particular VMs *\/ class PreferencesStorage: public Printable { public: PreferencesStorage(); protected: PreferencesStorage(const PreferencesStorage & storage) = default; PreferencesStorage & operator=(const PreferencesStorage & storage) = default; public: virtual ~PreferencesStorage(); virtual PreferencesStorageKind GetKind() const = 0; virtual void Clear(); virtual void Copy(const PreferencesStorage & preferencesStorage); virtual bool FillFromTreeNodeParameters(const TreeNodeParameters & parameters); virtual bool FillFromStrategyParameters(const StrategyParameters & parameters); virtual bool FillFromStrategyInstanceParameters(const StrategyInstanceParameters & parameters); virtual bool GetParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetParameters(TreeNodeParameters & parameters) const; virtual void GetParameters(StrategyParameters & parameters) const; virtual void GetParameters(StrategyInstanceParameters & parameters) const; virtual bool GetNonDefaultParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetNonDefaultParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetNonDefaultParameters(TreeNodeParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyInstanceParameters & parameters) const; \/\/ Update local values with non-empty values from the passed in preferences storage; \/\/ return true if something got changed as a result, false otherwise virtual bool Merge(const PreferencesStorage & preferencesStorage); virtual std::ostream & Print(std::ostream & strm) const override; \/\/ List of preferences that shouldn't be copied to other scope levels virtual const std::set<TreeNodeParameterDefinition> & GetLevelAnchoredParameters() const { return m_scopeLevelAnchoredPreferences; } \/\/ In case it is necessary to include all the exotic instruments, \/\/ we can't persist empty filter since it would be aggregated. \/\/ Hence, this dummy non-empty filter needs to be used for clear operations. static const CalculatedPropertyFilter dummyFilter; \/\/ Autofit settings ValueWithDefault<Boolean> autoFit; ValueWithDefault<Boolean> autoApplyAutoFit; ValueWithDefault<Boolean> globalAvoidExtraFits; ValueWithDefault<Boolean> globalUnderlyingTradingStatusTracking; ValueWithDefault<Boolean> optionTradingStatusTracking; ValueWithDefault<Integer> loggingMode; ValueWithDefault<Integer> maxAllowedFitRejects; ValueWithDefault<Boolean> maturityExcludedFromGlobalActions; ValueWithDefault<Boolean> sendQuotingRecommendations; ValueWithDefault<Table> quotingRecommendations; \/\/ General settings ValueWithDefault<Boolean> parallelShift; ValueWithDefault<Enumeration> curveShiftUnits; ValueWithDefault<Integer> ATMVolatilityShiftMode; ValueWithDefault<Boolean> includeExoticOptions; ValueWithDefault<Boolean> autoFetchATMVolatilityPath; ValueWithDefault<Boolean> globalAutoFetchATMVolatilityPath; ValueWithDefault<Integer> instrumentGroupType; ValueWithDefault<Identifier> suggestContext; ValueWithDefault<Integer> trackingAreaType; ValueWithDefault<Boolean> volatilityCurveSafetyCheckEnabled; ValueWithDefault<Double> safetyParameterChange; ValueWithDefault<Double> safetyModelChange; ValueWithDefault<Boolean> checkForStaticArbitrage; ValueWithDefault<Double> calendarSpreadArbitrageTolerance; ValueWithDefault<Double> butterflyArbitrageTolerance; ValueWithDefault<Boolean> enableCurveQualityMetrics; \/\/ Fit settings ValueWithDefault<Integer> fitWeighting; ValueWithDefault<Boolean> autocorrectFitWeights; ValueWithDefault<Boolean> fitOnlyATMVol; ValueWithDefault<Boolean> addVirtualBids; ValueWithDefault<Double> virtualBidRatio; ValueWithDefault<Boolean> robustFittingOnWings; ValueWithDefault<Double> robustFittingOnWingsStrength; ValueWithDefault<Boolean> autoResetSwimRefPriceToATM; ValueWithDefault<Integer> crossingProcessing; ValueWithDefault<Boolean> anomalyDetection; ValueWithDefault<Double> anomalyDetectionSensitivity; \/\/ Implied vol filtering ValueWithDefault<Boolean> enableAmerican; ValueWithDefault<Boolean> enableATM; ValueWithDefault<Boolean> enableDeepITM; ValueWithDefault<Boolean><fim-suffix>ValueWithDefault<Boolean> enableITM; ValueWithDefault<Boolean> enableCashDelivery; ValueWithDefault<Boolean> enableCrossings; ValueWithDefault<Boolean> enableLowBids; ValueWithDefault<Boolean> enablePhysicalDelivery; ValueWithDefault<Boolean> enableSmallDelta; ValueWithDefault<Boolean> enableWideSpreads; ValueWithDefault<Boolean> enableNoSpreads; ValueWithDefault<Boolean> enableOTM; ValueWithDefault<Boolean> enableLowVolumes; ValueWithDefault<Price> minimumBidPrice; ValueWithDefault<Volume> minimumVolume; ValueWithDefault<Table> manuallyToggledPoints; ValueWithDefault<Table> impliedVolatilitySources; ValueWithDefault<CalculatedPropertyFilter> instrumentFilter; ValueWithDefault<Integer> tradingPhaseProcessing; \/\/ Visualization settings ValueWithDefault<Boolean> showExcludedPoints; ValueWithDefault<Boolean> autocorrectVolatilityChartZooming; ValueWithDefault<Double> deltaValueForVerticalLines; ValueWithDefault<Boolean><fim-middle>enableDeepOTM; ValueWithDefault<Boolean> enableEuropean;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class<fim-suffix><fim-middle>DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n<fim-suffix><fim-middle>    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n<fim-suffix><fim-middle>    if (it->second.Empty()) {\n        return nullptr;\n    }"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)\n    {\n        HandleTickerUpdate(ticker, \"{}\");\n    }\n    SetState(StrategyState::PAUSED);\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n<fim-suffix><fim-middle>                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n<fim-suffix><fim-middle>        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__<fim-suffix><fim-middle><< \", item = \" << item);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n<fim-suffix><fim-middle>{\npublic:\n    Binary_ostream() { }\n    void close()"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    if (not m_client)\n    {\n        m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_PROD);\n    }\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n<fim-suffix><fim-middle>    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public<fim-suffix>Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t);<fim-middle>tbricks::Printable {"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n<fim-suffix><fim-middle>    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n    Binary_ostream() { }\n    void close()\n    {\n        m_data.Clear();\n    }\n    const tbricks::Binary & GetBinary()\n<fim-suffix><fim-middle>    {\n        return m_data;\n    }\n    template <typename T>"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\" #include <third_party\/include\/rapidjson\/pointer.h> #include <algorithm> #define SET_STRING_VIEW(key, string) \\ auto & params =<fim-suffix>Value v; \\ v.SetString(string.data(), string.size(), msg.GetAllocator()); \\ params.AddMember(#key, v, msg.GetAllocator()); #define SET_INTEGER(key, number) \\ auto & params = msg[\"params\"]; \\ Value v; \\ v.SetInt(number); \\ params.AddMember(#key, v, msg.GetAllocator()); namespace deribit { using namespace rapidjson; Json::Json() { msg.SetObject(); auto & allocator = msg.GetAllocator(); Value v; v.SetString(\"2.0\"); msg.AddMember(\"jsonrpc\", v, allocator); } Json::Json(Json && o) : msg(std::move(o.msg)) { } std::string_view Json::ToString() { buffer.Clear(); Writer<StringBuffer> writer(buffer); msg.Accept(writer); return {buffer.GetString()}; } std::string_view Json::GetId() { assert(msg[\"id\"].IsString()); return {msg[\"id\"].GetString()}; } void Json::Parse(std::string_view str) { msg.Clear(); StringStream s(str.data()); msg.ParseStream(s); } DeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods) { Parse(str); if (msg.HasMember(\"method\")) { std::string_view m(msg[\"method\"].GetString()); for (auto & method : methods) { if (method.second == m) { return method.first; } } } return DeribitMethod::NONE; } JsonCall::JsonCall(const std::string_view id, DeribitMethod method) : Json() { auto & allocator = msg.GetAllocator();<fim-middle>msg[\"params\"]; \\"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(\"HandleRunRequest\");\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(\"HandlePauseRequest\");\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(\"HandleDeleteRequest\");\n    SetState(StrategyState::DELETED);\n}\n<fim-suffix><fim-middle>void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(\"Modify request: \" << modifier);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; } void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice &<fim-suffix>void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem; tbricks::Identifier m_tickerId; bool m_snapshotDone {false}; };<fim-middle>bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return true; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl;<fim-suffix>{ TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)<fim-middle>} void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::HEARTBEAT: return<fim-suffix><fim-middle>\"heartbeat\"; default:"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n\npublic_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n{\n}\n\nheartbeat::heartbeat(JsonReply && base)\n    : JsonReply(std::move(base))\n    , type {Pointer(\"\/params\/type\").Get(msg)->GetString()}\n{\n}\n\nstd::string_view heartbeat::GetType() const\n{\n    return type;\n}\n\nbool heartbeat::IsTestRequest() const\n{\n    return type == \"test_request\" ? true : false;\n}\n\nsubscriptions::subscriptions(const std::string_view id, DeribitMethod method)\n    : JsonCall(id, method)\n{\n    auto & params = msg[\"params\"];\n    Value v(rapidjson::kArrayType);\n    params.AddMember(\"channels\", v, msg.GetAllocator());\n}\n\nvoid subscriptions::AddChannel(const std::string & channel)\n{\n    auto ptr = Pointer(\"\/params\/channels\");\n    if (ptr.IsValid())\n    {\n        Value ch;\n        ch.SetString(StringRef(channel.c_str(), channel.length()));\n        ptr.Get(msg)->PushBack(ch, msg.GetAllocator());\n    }\n}\n\nsubscriptions_reply::subscriptions_reply(JsonReply && base)\n    : JsonReply(std::move(base))\n{\n}\n<fim-suffix><fim-middle>std::vector<std::string_view> subscriptions_reply::GetChannels() const\n{\n    auto array = msg[\"result\"].GetArray();\n    std::vector<std::string_view> out;"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n<fim-suffix><fim-middle>        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include<fim-suffix>{ switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>(); case VolatilityModelSVI: return std::make_unique<SVIPreferencesStorage>(); case<fim-middle>\"MyCustomPreferencesStorage.h\" #include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way ==<fim-suffix><fim-middle>std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n    Binary_ostream() { }\n    void close()\n    {\n        m_data.Clear();\n    }\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n    template <typename T>\n    void write(const T & t)\n    {\n        tbricks::Binary vec;\n        vec.Set(reinterpret_cast<const void *>(&t), sizeof(T));\n        write(vec);\n    }\n    void write(const std::string & s)\n    {\n        write(s.c_str(), s.size());\n    }\n    void write(const char * p, size_t size)\n    {\n        m_data.Append(p, size);\n    }\n<fim-suffix><fim-middle>private:\n    tbricks::Binary m_data;\n};"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) NAMESPACE_PATH_GREEK(param_1, Double, Param1, custom::pricing::calculated_values) NAMESPACE_PATH_GREEK(param_2, Double, Param2, custom::pricing::calculated_values) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate) HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight) HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight) HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price, Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed) VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double, NextDividend) VALUE(next_dividend_date, Date, NextDividendDate) VALUE(underlying_settlement_date, Date, UnderlyingSettlementDateUsed) VALUE(final_settlement_date, Date, FinalSettlementDateUsed) VALUE(next_call_put_date, DateTime, NextCall_DIV_PutDate) VALUE(days_to_next_dividend, Integer, DaysToNextDividend) VALUE(trading_days_to_next_dividend, Integer, TradingDaysToNextDividend) VALUE(days_to_maturity, Integer, DaysToMaturity) VALUE(time_to_next_dividend, Double, TimeToNextDividend) VALUE(months_to_maturity, Double, MonthsToMaturity) VALUE(years_to_maturity, Double, YearsToMaturity) VALUE(longest_days_to_maturity, Integer, LongestDaysToMaturity) VALUE(longest_months_to_maturity, Double, LongestMonthsToMaturity) VALUE(longest_years_to_maturity, Double, LongestYearsToMaturity) VALUE(vol_days_to_maturity, Integer, VolatilityDaysToMaturity) VALUE(rate_days_to_maturity, Integer, RateDaysToMaturity) VALUE(expiration_time, Double, ExpirationTime) VALUE(rate_time, Double, RateTime) VALUE(volatility_time, Double, VolatilityTime) VALUE(rate, Double, FinancingRate) VALUE(rate_discount, Double, DiscountingRate) VALUE(present_value_adjustment_factor, Double, PresentValueAdjustmentFactor) VALUE(overnight_financing_factor, Double, OvernightFinancingFactor) VALUE(single_underlying, Boolean, SingleUnderlying) VALUE(version, Integer, ParameterVersion) VALUE(volatility_settings_changeset_used_1, Integer, VolatilitySettingsChangesetUsed1) VALUE(volatility_settings_changeset_used_2, Integer, VolatilitySettingsChangesetUsed2) VALUE(pricing_model_used,<fim-suffix>VALUE(accrued_interest, Price, AccruedInterest) VALUE(sink_factor, Double, SinkFactor) VALUE(rate_amount, Double, RateAmount) VALUE(ytm, Double, YTM) VALUE(volatility_model_used, Integer, VolatilityModelUsed) VALUE(solver_precision_setting_used, Integer, SolverPrecisionSettingUsed) VALUE(intrinsic_value, Double, IntrinsicValue) VALUE(valid_until, DateTime, ExternalValidUntil) VALUE(last_update_timestamp, DateTime, ExternalLastUpdated) VALUE(external_value_highlight, Integer, ExternalPricingHighlighting) VALUE(instrument_trading_phase, Integer, InstrumentTradingPhase) VALUE(average_life, Double,<fim-middle>Integer, PricingModelUsed) VALUE(valuation_price_source_used, Integer, ValuationPriceSourceUsed)"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\"\n#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include \"execution\/TbOrderManager.h\"\n#include \"execution\/TbOrderMinion.h\"\n#include \"execution\/TbChildOrder.h\"\n\n#include <AsyncTask.h>\n#include <memory>\n\nusing namespace tbricks;\n\nnamespace sp = go_flat::strategy_parameters;\n\nGoFlatPlugin::GoFlatPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_portfolio(sp::Portfolio())\n    , m_statusText(sp::PlugInStatusDescription())\n    , m_executorType(execution::OrderExecutorType::ORDER_MANAGER)\n{\n    TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered());\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    switch (m_executorType)\n    {\n        case execution::OrderExecutorType::ORDER_MANAGER:\n            m_orders = std::make_unique<execution::TbOrderManager>(*this);\n            break;\n        case execution::OrderExecutorType::CHILD_ORDER:\n            m_orders = std::make_unique<execution::TbChildOrder>(*this, *this);\n            break;\n        case execution::OrderExecutorType::ORDER_MINION:\n            m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters);\n            break;\n    }\n\n    m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier());\n}\n\nvoid GoFlatPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n\n    if (not m_positions or m_positions->GetData().empty())\n    {\n        SetTransactionFail(\"No positions\", StrategyState::PAUSED);\n        return;\n    }\n    if (m_orders)\n    {\n        if (not m_positions->GetData().empty())\n        {\n            for (const auto& [ivid, pos] : m_positions->GetData())\n            {\n                if (m_executorType == execution::OrderExecutorType::ORDER_MINION)\n                {\n                    execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get());\n                    minion->MonitorInstrument(ivid);\n                }\n                TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos);\n                if (not pos.Empty() and pos != 0.0)\n                {\n                    m_orders->CreateOrder(ivid, -pos, m_portfolio.GetPortfolioIdentifier());\n                }\n            }\n            m_positions->Stop();\n            SetState(StrategyState::RUNNING);\n            return;\n        }\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid GoFlatPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_orders)\n    {\n        m_orders->DeleteOrders();\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid GoFlatPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_DELETE);\n    if (m_orders)\n    {\n        m_orders->DeleteOrders();\n    }\n    SetState(StrategyState::DELETED);\n}\n\nvoid GoFlatPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(\"Modify request: \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n\n    if (modifier.GetParameters().HasParameter(sp::Portfolio()) and not m_portfolio.Empty())\n    {\n        m_positions = std::make_unique<PositionsData>(m_portfolio.GetPortfolioIdentifier(), m_statusText);\n    }\n}\n\nvoid GoFlatPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    context.GetItem(m_statusText).SetDirection(ParameterDefinition::Direction::OUTPUT);\n    if (GetState().IsRunning())\n    {\n        context.GetItem(m_portfolio).SetDirection(ParameterDefinition::Direction::OUTPUT);\n    }\n    else\n    {\n        context.GetItem(m_portfolio).SetDirection(ParameterDefinition::Direction::INPUT_OUTPUT);\n    }\n    context.SendReply();\n}\n\nvoid GoFlatPlugin::HandleScheduledEvent(UserData&& data)\n{\n    std::string* msg = static_cast<std::string*>(data.GetData());\n    if (msg)\n    {\n        TBDUMP(msg->c_str());\n    }\n    if (m_async->HasResult())\n    {\n        TBNOTICE(m_async->GetResult());\n    }\n\n    if (m_executorType == execution::OrderExecutorType::ORDER_MINION)\n    {\n        if (not m_positions->GetData().empty())\n        {\n            for (const auto& [ivid, pos] : m_positions->GetData())\n            {\n                TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos);\n                if (not pos.Empty() and pos != 0.0)\n                {\n                    m_orders->CreateOrder(ivid, -pos, m_portfolio.GetPortfolioIdentifier());\n                }\n            }\n        }\n    }\n}\n\nvoid GoFlatPlugin::PanicStop(const String& msg)\n{\n    TBDUMP(__func__ << \" : \" << msg);\n    SetTransactionFail(msg, StrategyState::PAUSED);\n}\n\nvoid GoFlatPlugin::AllDone(const execution::Stats& stats)\n<fim-suffix><fim-middle>{\n    TBDUMP(__func__);\n    std::stringstream ss;\n    ss << \"COMPLETE\" << std::endl;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n<fim-suffix><fim-middle>{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n<fim-suffix><fim-middle>    {\n    public:\n        virtual ~IHandler() = default;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters &<fim-suffix><fim-middle>parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp     void HandleRunRequest() override;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary<fim-suffix>} template <><fim-middle>& out) { out = m_data;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier<fim-suffix><fim-middle>& stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream<fim-suffix><fim-middle>s(str.GetCString());"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n<fim-suffix><fim-middle>    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod {<fim-suffix>PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } namespace deribit { using Method<fim-middle>NONE, PUBLIC_Auth,"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin2 : public tbricks::Pricing { public: ExampleCalcAppPlugin2(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; bool HandlePartialPricingModifyRequest(const tbricks::CalculatedValuesRequestUpdate &update) override; private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void HandleDeleteRequest() override {}; void HandleRunRequest() override {}; void HandlePauseRequest() override {}; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override {}; void HandleValidateRequest(tbricks::ValidationContext &context) override {}; void Calculate(const RequestAndIVIDs & values,<fim-suffix>void Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const<fim-middle>const tbricks::CalculatedValuesRequestFull & request);"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n<fim-suffix><fim-middle>    {\n        FailWithReason(\"Missing endpoint\");\n    }"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT, PUBLIC_GetInstruments, }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; case DeribitMethod::PUBLIC_GetInstruments: return \"public\/get_instruments\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string> Method; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods() { return { {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)}, {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)}, {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)}, {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)}, {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)}, {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)}, {DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)}, {DeribitMethod::PUBLIC_GetInstruments, Resolve(DeribitMethod::PUBLIC_GetInstruments)}, {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)}, {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}}; }<fim-suffix><fim-middle>} \/\/ namespace deribit"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n    Binary_ostream() { }\n    void close()\n    {\n        m_data.Clear();\n    }\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n    template <typename T>\n    void write(const T & t)\n    {\n        tbricks::Binary vec;\n        vec.Set(reinterpret_cast<const void *>(&t), sizeof(T));\n        write(vec);\n    }\n    void write(const std::string & s)\n    {\n        write(s.c_str(), s.size());\n    }\n    void write(const char * p, size_t size)\n    {\n        m_data.Append(p, size);\n    }\n\nprivate:\n    tbricks::Binary m_data;\n};\n\ntemplate <typename T>\nBinary_istream & operator>>(Binary_istream & istm, T & val)\n{\n    istm.read(val);\n\n    return istm;\n}\n<fim-suffix><fim-middle>template <typename T>\nBinary_ostream & operator<<(Binary_ostream & ostm, const T & val)\n{\n    ostm.write(val);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public<fim-suffix><fim-middle>tbricks::ITimerEventHandler { public: class IHandler"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n<fim-suffix><fim-middle>{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();<fim-suffix>if (model_opt)<fim-middle>auto model_opt = GetModel(instrument_id);"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\" SUPPRESS_SF_API_CLANG_WARNINGS #include \"shared\/app\/app.h\" CLANG_RESTORE_WARNINGS #include <limits> using namespace tbricks; class ValuesRequest; struct ImpliedValue { void Clear(); friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value) { return value.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double implied_volatility; }; struct FairPriceValue { FairPriceValue & operator += (const FairPriceValue & fair_price_value); FairPriceValue & operator += (const Double & value); FairPriceValue operator * (const Double & mult) const; FairPriceValue & operator *= (const Double & mult); void Clear(); bool SetError(const String & error); friend std::ostream & operator << (std::ostream & strm, const FairPriceValue & price) { return price.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double fair_price; }; struct Greeks { Greeks & operator += (const Greeks & greeks); Greeks operator * (const Double & mult) const; Greeks & operator *= (const Double & mult); void Clear(); void ClearNoncombinationValues(); void Set(const Greeks & greeks); bool SetError(const String & error); void SetErrorToCCSVolatilityModelGreeks(const String & error); void SetErrorToWingVolatilityModelGreeks(const String & error); void SetErrorToMyCustomVolatilityModelGreeks(const String & error); void ZeroFill(); friend std::ostream & operator << (std::ostream & strm, const Greeks & greeks) { return greeks.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double forward_price; Double quanto_forward_price; Double spot_price; Double strike_price; Double delta; Double gamma; Double option_equivalent_gamma; Double vega; Double option_equivalent_vega; Double rho; Double rho_discounting; Double vanna; Double vomma; Double skew_delta; Double skew_gamma; Double calendar_theta; Double volatility_theta; Double rate_theta; Double calendar_charm; Double calendar_skew_charm; Double calendar_color; Double opening_theta; Double opening_charm; Double opening_skew_charm; Double opening_color; Double overnight_theta; Double overnight_charm; Double overnight_skew_charm; Double overnight_color; Double divit; Double speed; Double skew_speed; Double zomma; Double volatility; Double at_the_money_volatility; Double at_the_money_straddle_price; Double straddle_price; Boolean exercise_boundary_reached; Boolean exercise_boundary_div_reached; Integer moneyness; Double simple_put_moneyness; Double wing_slope_sensitivity; Double wing_call_curvature_sensitivity; Double wing_put_curvature_sensitivity; Double ccs_left_slope_sensitivity; Double ccs_right_slope_sensitivity; Double asian_average_fix; Double delta_ytm; Double gamma_ytm; Double fair_ytm; Double implicit_atm_forward; Double implicit_atm_volatility; Double implicit_wing_atm_slope; Double equity_leg_override_price; Double yield; Double synthetic_yield; Double dividend_equivalent_yield; Double tenor_rate_sensitivity; Double bond_duration; Double bond_dv01; Double cash_delta_base; Double cash_gamma_base; Double cash_vega_base; Double param_1; Double param_2; }; struct GreeksCompact { enum class Items { forward_price = 0, spot_price, delta, gamma, option_equivalent_gamma, vega, option_equivalent_vega, rho, rho_discounting, vanna, vomma, skew_delta,<fim-suffix><fim-middle>skew_gamma,"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \":<fim-suffix>} void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ <<<fim-middle>\" << stream);"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n<fim-suffix><fim-middle>const DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(\"HandleRunRequest\"); SetState(StrategyState::RUNNING); } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(\"HandlePauseRequest\"); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(\"HandleDeleteRequest\"); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(\"Modify request: \" << modifier);<fim-suffix>MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(\"HandleValidateRequest: \" << context);<fim-middle>"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n<fim-suffix><fim-middle>void public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;\n    }\n}\n\nvoid InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n    {\n        const int total = m_instrumentCache.size();\n\n        std::stringstream result;\n        result << \"Total instruments = \" << total << \", successful = \" << total - m_failed\n               << \", failed = \" << m_failed;\n\n        m_handler.HandleImportComplete(result.str());\n    }\n}\n\nvoid InstrumentManager::EnrichInstruments()\n{\n    TBDEBUG(__func__);\n\n    for (const auto& [instID, instrument] : m_instrumentCache)\n    {\n        InstrumentModifier instrumentModifier(instID);\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        if (tbMaturityDate != m_handler.GetMaturityDate())\n        {\n            InstrumentAttributes attributes;\n            attributes.SetAttribute(instrument_attributes::MaturityDate(), m_handler.GetMaturityDate());\n            instrumentModifier.SetAttributes(attributes);\n            Instrument::RequestResult result = Instrument::SendModifyRequest(instrumentModifier, *this);\n            m_instrumentModifyRequests.emplace(result.GetRequestIdentifier(), instID);\n        }\n    }\n\n    ModifyGroup();\n    CheckModificationStatus();\n}\n\nvoid InstrumentManager::ModifyGroup()\n{\n    TBDEBUG(__func__);\n\n    InstrumentGroupIdentifier groupID = m_handler.GetInstrumentGroup().GetIdentifier();\n    std::vector<InstrumentParameterDefinition> defs;\n    defs.push_back(instrument_parameters::UnderlyingInstrument());\n\n    InstrumentGroupParameters groupParams(groupID, defs);\n    InstrumentIdentifier underlyingInstrument;\n    groupParams.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingInstrument);\n\n    InstrumentGroupParameters::Modifier modifier;\n    if (underlyingInstrument.Empty())\n    {\n        modifier.SetParameter(instrument_parameters::UnderlyingInstrument(), m_handler.GetUnderlyingInstrument());\n    }\n    else\n    {\n        TBNOTICE(\"Not changing existing underlying instrument for group\");\n    }\n\n    if (not modifier.Empty())\n    {\n        Identifier id = InstrumentGroupParameters::SendModifyRequest(groupID, modifier, *this);\n        m_groupModifyRequests.emplace(id, groupID);\n    }\n}\n\nvoid InstrumentManager::HandleRequestReply(const Identifier& id, class Status status, const String& status_text)\n{\n    TBDEBUG(__func__ << \" : \" << id);\n\n    if (const auto it = m_instrumentModifyRequests.find(id); it not_eq m_instrumentModifyRequests.end())\n    {\n        if (status not_eq Status::OK)\n        {\n            m_failed++;\n            TBWARNING(\"Instrument modification failed for = \" << it->second << \", reason = \" << status_text);\n        }\n        else\n        {\n            TBDUMP(\"Instrument modified succesfully = \" << it->second);\n        }\n        m_instrumentModifyRequests.erase(it);\n    }\n<fim-suffix><fim-middle>    if (const auto it = m_groupModifyRequests.find(id); it not_eq m_groupModifyRequests.end())\n    {\n        if (status not_eq Status::OK)\n        {"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel)"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing)<fim-suffix>VOLATILITY(my_custom, MyCustom)<fim-middle>VOLATILITY(custom, Custom)"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const<fim-suffix>int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double GetBid(); double GetAsk(); double GetBidVolume();<fim-middle>tbricks::String& str); std::string_view GetInstrumentName();"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n<fim-suffix><fim-middle>{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include<fim-suffix>ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone();<fim-middle><cstdlib> using namespace tbricks;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n<fim-suffix><fim-middle>{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n<fim-suffix><fim-middle>        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n{\n    SET_STRING_VIEW(client_id, val);\n}\n\nvoid public_auth::SetClientSecret(const std::string_view val)\n{\n    SET_STRING_VIEW(client_secret, val);\n}\n\nvoid public_auth::SetRefreshToken(const std::string_view val)\n{\n    SET_STRING_VIEW(refresh_token, val);\n}\n\npublic_set_heartbeat::public_set_heartbeat(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_SetHeartbeat)\n{\n}\n\nvoid public_set_heartbeat::SetInterval(int seconds)\n{\n    SET_INTEGER(interval, seconds);\n}\n\npublic_test::public_test(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Test)\n<fim-suffix><fim-middle>{\n}"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n<fim-suffix><fim-middle>    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n    return {buffer.GetString()};\n}\n\nconst DeribitMethod JsonReply::GetMethod() const\n{\n    return jrpcMethod;\n}\n\npublic_auth::public_auth(const std::string_view id)\n    : JsonCall(id, DeribitMethod::PUBLIC_Auth)\n{\n}\n\nvoid public_auth::SetGrantType(public_auth::GrantType type)\n{\n    auto & params = msg[\"params\"];\n    Value v;\n    switch (type)\n    {\n    case GrantType::CLIENT_CREDENTIALS:\n        v.SetString(\"client_credentials\");\n        break;\n    case GrantType::CLIENT_SIGNATURE:\n        v.SetString(\"client_signature\");\n        break;\n    case GrantType::REFRESH_TOKEN:\n        v.SetString(\"refresh_token\");\n        break;\n    default:\n        break;\n    }\n    params.AddMember(\"grant_type\", v, msg.GetAllocator());\n}\n\nvoid public_auth::SetClientId(const std::string_view val)\n<fim-suffix><fim-middle>{\n    SET_STRING_VIEW(client_id, val);\n}"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n<fim-suffix><fim-middle>    return {buffer.GetString()};\n}"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n<fim-suffix><fim-middle>    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }"}
{"content":"<fim-prefix>#include \"ReversalManager.h\" #include \"tbricks_definitions.h\" #include <map> using namespace tbricks; ReversalManager::ReversalManager(IHandler& callback) : m_callback(callback) , m_scheduledTimer(*this) , m_positionRetriever(*this) { } void ReversalManager::Start( const PortfolioIdentifier& portfolioId, const Integer& priceSource, const Time& startTime) { m_portfolioId = portfolioId; m_priceSource = priceSource; m_scheduledTimer.Start(startTime); } void ReversalManager::Stop() { m_scheduledTimer.Stop(); m_positionRetriever.Stop(); } void ReversalManager::HandleTimerEvent(Timer & timer) { TBDEBUG(__func__); m_positionRetriever.RetreivePositions(m_portfolioId); } void ReversalManager::HandleError(const tbricks::String& error) { m_callback.HandleError(error); } void ReversalManager::HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions) { for (const auto& [_, position] : positions) { Price reversalPrice; const auto& ivid = position.GetInstrumentVenueIdentification(); StatisticsStream stream;<fim-suffix>{<fim-middle>if (m_priceSource == position_reversals::enumerations::PositionReversalPriceSource::PositionReversalPriceSourceOpen)"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_plugInStatusDescription.Clear();\n        m_timerController.Start();\n    }\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::Stop()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsPaused())\n    {\n        TBDEBUG(\"Already stopped\");\n        return;\n    }\n\n    if (m_timerController.IsActive())\n    {\n        m_timerController.Stop();\n    }\n    m_instrumentManager.Stop();\n\n    Strategy::SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::ImportNow()\n{\n    TBDEBUG(__func__);\n    m_plugInStatusDescription.Clear();\n    m_instrumentManager.Start();\n}\n<fim-suffix><fim-middle>void InstrumentEnricherPlugin::HandleImportComplete(const String& status)\n{\n    TBDEBUG(__func__ << \" : \" << status);\n    m_plugInStatusDescription = status + \" at \" + DateTime::Now().ToString();"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return false; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if<fim-suffix>diagnostics.GetDebugStream() << \"for instrument \"<fim-middle>(!diagnostics.GetDiagnosticKey().empty()) { {"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    if (not m_client)\n    {\n        m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_PROD);\n    }\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n\n    for (auto & [instrument_id, request] : m_requestMap)\n    {\n        HandleDistributedValuesSubscription(request);\n    }\n    \n    for (const auto & [_, request] : m_pendingRequests)\n    {\n        HandleDistributedValuesRequest(request);\n    }\n    m_pendingRequests.clear();\n\n    m_instrumentManager.Start();\n    m_client->DownloadInstruments(Uuid::Create(), DeribitCurrency::BTC);\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    for (const auto & [ticker, instrument_id] : m_symbolMap)\n    {\n        HandleTickerUpdate(ticker, \"{}\");\n    }\n    SetState(StrategyState::PAUSED);\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> #include <shared\/volatility\/MyCustomVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility model types template <class ModelTypePtr> ModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel); template <class ModelTypePtr> ModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel); template <class ModelTypeRef> ModelTypeRef vol_model_cast(volatility::IVolatilityModel & model); template <class ModelTypeRef> ModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model); #define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\ { \\ if (TB_UNLIKELY(!pModel)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model*>(pModel); \\ } #define VOL_MODEL_REF_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model & vol_model_cast(specifier volatility::IVolatilityModel & rModel) \\ {<fim-suffix>TBWARNING(\"Detected attempt to cast volatility model of type \" << rModel.GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(rModel.GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model&>(rModel); \\ } #define VOL_MODEL_CAST_IMPL(specifier, model, type) \\ VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ VOL_MODEL_REF_CAST_IMPL(specifier, model, type) VOL_MODEL_CAST_IMPL(const, ClampedCubicSpline, VolatilityModelCCS) VOL_MODEL_CAST_IMPL(, ClampedCubicSpline, VolatilityModelCCS) VOL_MODEL_CAST_IMPL(const, StochasticVolatilityInspired, VolatilityModelSVI) VOL_MODEL_CAST_IMPL(, StochasticVolatilityInspired, VolatilityModelSVI) VOL_MODEL_CAST_IMPL(const, WingVolatilityModel, VolatilityModelWing) VOL_MODEL_CAST_IMPL(, WingVolatilityModel,<fim-middle>\\ if (TB_UNLIKELY(rModel.GetVolatilityModelType() != type)) { \\"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default;<fim-suffix><fim-middle>protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp     void HandleRunRequest() override;"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely picked up by another calc app \/\/ the engine was just checking if we responded to it } } Send();<fim-suffix><fim-middle>} \/\/ Note that here we use DEFINE_PRICING_ENTRY instead of the normal DEFINE_STRATEGY_ENTRY DEFINE_PRICING_ENTRY(ExampleCalcAppPlugin)"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include \"InstrumentManager.h\"\n\nclass InstrumentEnricherPlugin : public tbricks::Strategy\n                               , public InstrumentManager::IHandler\n{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\n<fim-suffix><fim-middle>    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return<fim-suffix>void write(const T & t) { tbricks::Binary vec; vec.Set(reinterpret_cast<const void *>(&t), sizeof(T)); write(vec); } void write(const std::string & s) { write(s.c_str(), s.size()); } void write(const char * p, size_t size) { m_data.Append(p, size); } private: tbricks::Binary m_data; }; template <typename T> Binary_istream & operator>>(Binary_istream & istm, T & val) { istm.read(val); return istm; }<fim-middle>m_data; } template <typename T>"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \", item = \" << item);\n}"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream) final; void UpgradeWs(); private: std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream & data); void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode,<fim-suffix>private: IWebsocketHandler & m_handler; tbricks::TCPStream m_tcp; std::random_device m_rd; std::shared_ptr<std::string> nonce_base64; Config m_config; std::string host; unsigned short port; std::string<fim-middle>size_t length);"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete (m_doc); } std::string_view UpdateData::ToString() { m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer); m_doc->msg.Accept(writer); return {m_doc->buffer.GetString()}; } void UpdateData::Parse(const tbricks::String & str) { m_doc->msg.Clear(); StringStream s(str.GetCString()); m_doc->msg.ParseStream(s); } ticker_update::ticker_update(const tbricks::String & str) : UpdateData() { Parse(str); } std::string_view ticker_update::GetInstrumentName() { auto & msg = m_doc->msg; auto i = msg.FindMember(\"instrument_name\"); if (i != msg.MemberEnd()) { return i->value.GetString(); } return {}; } int64_t ticker_update::GetTimestamp() { auto & msg = m_doc->msg; auto t = msg.FindMember(\"timestamp\"); if (t != msg.MemberEnd()) { return t->value.GetInt64(); } return 0; } bool ticker_update::IsOpen() { auto & msg = m_doc->msg; auto s = msg.FindMember(\"state\"); std::string_view state; if (s != msg.MemberEnd()) { state = s->value.GetString(); } if (not state.empty() and state.compare(\"open\") == 0) {<fim-suffix>return false; } #define EXTRACT_DOUBLE_METHOD(method, key, default) \\ double method() \\ { \\ auto & msg = m_doc->msg; \\ auto v = msg.FindMember(#key); \\ if (v != msg.MemberEnd()) \\ { \\ return v->value.GetDouble(); \\ } \\ return default; \\ }<fim-middle>return true; }"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"<fim-suffix>using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item<fim-middle>#include \"tbricks_definitions.h\""}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive();<fim-suffix><fim-middle>}"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ <<<fim-suffix><fim-middle>\", item = \" << item);"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const<fim-suffix>{ int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char val) { ostm.write(&val, sizeof(char)); return ostm;<fim-middle>char * val)"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) NAMESPACE_PATH_GREEK(param_1, Double, Param1, custom::pricing::calculated_values) NAMESPACE_PATH_GREEK(param_2, Double, Param2, custom::pricing::calculated_values) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate) HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight) HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight) HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price, Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed) VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double, NextDividend) VALUE(next_dividend_date, Date, NextDividendDate) VALUE(underlying_settlement_date, Date, UnderlyingSettlementDateUsed) VALUE(final_settlement_date, Date, FinalSettlementDateUsed) VALUE(next_call_put_date, DateTime, NextCall_DIV_PutDate) VALUE(days_to_next_dividend, Integer, DaysToNextDividend) VALUE(trading_days_to_next_dividend, Integer, TradingDaysToNextDividend) VALUE(days_to_maturity, Integer, DaysToMaturity) VALUE(time_to_next_dividend, Double, TimeToNextDividend) VALUE(months_to_maturity, Double, MonthsToMaturity) VALUE(years_to_maturity, Double, YearsToMaturity) VALUE(longest_days_to_maturity, Integer, LongestDaysToMaturity) VALUE(longest_months_to_maturity, Double, LongestMonthsToMaturity) VALUE(longest_years_to_maturity, Double, LongestYearsToMaturity) VALUE(vol_days_to_maturity, Integer, VolatilityDaysToMaturity) VALUE(rate_days_to_maturity, Integer, RateDaysToMaturity) VALUE(expiration_time, Double, ExpirationTime) VALUE(rate_time, Double, RateTime) VALUE(volatility_time, Double, VolatilityTime) VALUE(rate, Double, FinancingRate) VALUE(rate_discount, Double, DiscountingRate) VALUE(present_value_adjustment_factor, Double, PresentValueAdjustmentFactor) VALUE(overnight_financing_factor, Double, OvernightFinancingFactor) VALUE(single_underlying, Boolean, SingleUnderlying) VALUE(version, Integer, ParameterVersion) VALUE(volatility_settings_changeset_used_1, Integer, VolatilitySettingsChangesetUsed1) VALUE(volatility_settings_changeset_used_2, Integer, VolatilitySettingsChangesetUsed2) VALUE(pricing_model_used, Integer, PricingModelUsed) VALUE(valuation_price_source_used, Integer, ValuationPriceSourceUsed) VALUE(accrued_interest, Price, AccruedInterest) VALUE(sink_factor, Double,<fim-suffix><fim-middle>SinkFactor) VALUE(rate_amount, Double, RateAmount)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler ,<fim-suffix>class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String&<fim-middle>public tbricks::InstrumentAggregateParameters::Stream::IHandler { public:"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return std::make_unique<CCSPreferencesStorage>(); case VolatilityModelSVI: return std::make_unique<SVIPreferencesStorage>(); default: return std::make_unique<CommonPreferencesStorage>(); }<fim-suffix><fim-middle>}"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility model types template <class ModelTypePtr> ModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel); template <class ModelTypePtr> ModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel); template <class ModelTypeRef> ModelTypeRef vol_model_cast(volatility::IVolatilityModel & model); template <class ModelTypeRef> ModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model); #define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model * vol_model_cast(specifier<fim-suffix>{ \\ if (TB_UNLIKELY(!pModel)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model*>(pModel); \\ }<fim-middle>volatility::IVolatilityModel * pModel) \\"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n<fim-suffix><fim-middle>class public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n<fim-suffix><fim-middle>struct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string &<fim-suffix>istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in);<fim-middle>val) { int size = 0;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95; const int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally; const double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1; const double CCS_MODEL_MINIMAL_STRIKE = 1.0e-6; const double CCS_MODEL_MINIMAL_SMOOTHNESS = 0.0; const double CCS_MODEL_DEFAULT_SMOOTHNESS = 1.0; const int CCS_MODEL_MINIMAL_NUMBER_OF_CCS_POINTS = 2; const int CCS_MODEL_MAXIMAL_NUMBER_OF_CCS_POINTS = 30; const double CCS_MODEL_DEFAULT_SLOPE_LEFT = -0.05; const double CCS_MODEL_DEFAULT_SLOPE_RIGHT = 0.05; const double CCS_MODEL_DEFAULT_BREAKPOINT_SCALE_FACTOR =<fim-suffix>const double CCS_MODEL_MINIMAL_BREAKPOINT_SCALE_FACTOR = 0.0; const int CCS_MODEL_DEFAULT_ABSCISSA = 0; const double CCS_MODEL_DEFAULT_SLOPE_MULT = 1; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER = 1.0; const double CCS_MODEL_DEFAULT_CCS_BASE_SMILE_WEIGHT = 1.0; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER_SMILE_WEIGHT = 0.0; const double CCS_MODEL_DEFAULT_MULTIPLIER_RATIO = 0.0; const double SVI_MODEL_DEFAULT_A = 0.04; const double SVI_MODEL_DEFAULT_B = 0.4; const double SVI_MODEL_DEFAULT_RHO = -0.4; const double SVI_MODEL_DEFAULT_M = 0.05; const double SVI_MODEL_DEFAULT_SIGMA = 0.1; \/* * Volatility managers need Forward price to fit volatility model parameters * so when there is empty volatility model initially, Pricing cannot calculate<fim-middle>1.0;"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return<fim-suffix><fim-middle>std::make_unique<CCSPreferencesStorage>(); case VolatilityModelSVI:"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n<fim-suffix><fim-middle>        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction()) , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency()) , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_startTime(instrument_enricher::strategy_parameters::StartTime()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) , m_timerController(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { ImportNow(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); const StrategyParameters& parameters = modifier.GetParameters(); GetParameters().Merge(parameters); MergeAttributes(modifier.GetAttributes()); if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction())) { Integer action; parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);<fim-suffix><fim-middle>HandleAction(action); } if (parameters.GetParameter(m_startTime) or"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n\nprotected:\n    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;\n    void HandleStreamClose(tbricks::TCPStream & stream) final;\n\n    void UpgradeWs();\n\nprivate:\n    std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept;\n\n    void ParseHttpReply(const tbricks::Binary & data);\n    std::size_t ReadWsReply(std::istream & data);\n    void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length);\n\nprivate:\n    IWebsocketHandler & m_handler;\n    tbricks::TCPStream m_tcp;\n    std::random_device m_rd;\n    std::shared_ptr<std::string> nonce_base64;\n\n    Config m_config;\n<fim-suffix><fim-middle>    std::string host;\n    unsigned short port;\n    std::string path;\n    bool m_handshake_done = false;"}
{"content":"<fim-prefix>#include \"ReversalManager.h\" #include \"tbricks_definitions.h\" #include <map> using namespace tbricks; ReversalManager::ReversalManager(IHandler& callback) : m_callback(callback) , m_scheduledTimer(*this) , m_positionRetriever(*this) { } void ReversalManager::Start( const PortfolioIdentifier& portfolioId, const Integer& priceSource, const Time& startTime) { m_portfolioId = portfolioId; m_priceSource = priceSource; m_scheduledTimer.Start(startTime); } void ReversalManager::Stop() { m_scheduledTimer.Stop(); m_positionRetriever.Stop(); } void ReversalManager::HandleTimerEvent(Timer & timer) { TBDEBUG(__func__); m_positionRetriever.RetreivePositions(m_portfolioId); } void ReversalManager::HandleError(const tbricks::String& error) { m_callback.HandleError(error); } void ReversalManager::HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions) { for (const auto& [_, position] : positions) { Price reversalPrice; const auto& ivid<fim-suffix><fim-middle>= position.GetInstrumentVenueIdentification();"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/order_minion\/OrderMinionController.h\" #include \"shared\/order_minion\/OrderMinionRequest.h\" namespace execution { class TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler { public: TbOrderMinion(IExecutionHandler& handler, tbricks::Strategy& app, const tbricks::InitializationReason& reason, const tbricks::StrategyParameters& parameters); ~TbOrderMinion(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; void MonitorInstrument(const tbricks::InstrumentVenueIdentification& ivid); protected: \/\/ OrderMinionRequest::IHandler void HandleOrderMinionUpdate( const OrderMinionUpdate& update<fim-suffix>private: void UpdateStats(const OrderMinionUpdate& update, const OrderMinionRequest& request); private: OrderMinionController m_controller; tbricks::Hash<tbricks::InstrumentVenueIdentification,OrderMinionRequest><fim-middle>) override;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item<fim-suffix><fim-middle>= \" << item);"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95; const int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally; const double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1; const double CCS_MODEL_MINIMAL_STRIKE = 1.0e-6; const double CCS_MODEL_MINIMAL_SMOOTHNESS = 0.0; const double CCS_MODEL_DEFAULT_SMOOTHNESS = 1.0; const int CCS_MODEL_MINIMAL_NUMBER_OF_CCS_POINTS = 2; const int CCS_MODEL_MAXIMAL_NUMBER_OF_CCS_POINTS = 30; const double CCS_MODEL_DEFAULT_SLOPE_LEFT = -0.05; const double CCS_MODEL_DEFAULT_SLOPE_RIGHT = 0.05; const double CCS_MODEL_DEFAULT_BREAKPOINT_SCALE_FACTOR = 1.0; const double CCS_MODEL_MINIMAL_BREAKPOINT_SCALE_FACTOR = 0.0; const int CCS_MODEL_DEFAULT_ABSCISSA = 0; const double CCS_MODEL_DEFAULT_SLOPE_MULT = 1; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER = 1.0; const double CCS_MODEL_DEFAULT_CCS_BASE_SMILE_WEIGHT = 1.0; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER_SMILE_WEIGHT = 0.0; const double CCS_MODEL_DEFAULT_MULTIPLIER_RATIO = 0.0; const double SVI_MODEL_DEFAULT_A = 0.04; const double SVI_MODEL_DEFAULT_B = 0.4; const double SVI_MODEL_DEFAULT_RHO = -0.4; const double SVI_MODEL_DEFAULT_M = 0.05; const double SVI_MODEL_DEFAULT_SIGMA = 0.1; \/* * Volatility managers need Forward price to fit volatility model parameters * so when there is empty volatility model initially, Pricing cannot calculate * Forward price for underlyings paying capped dividends because the reference volatility is required * for its calculation thus giving us so called chicken-and-egg problem. * 20% volatility is assumed to be a good starting point taking into account * that it does not influence significantly in most of the cases<fim-suffix>*\/ constexpr double EMPTY_MODEL_DEFAULT_REFERENCE_VOLATILITY = 0.2; }<fim-middle>on the resulting Forward price."}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)<fim-suffix><fim-middle>{ String value;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n<fim-suffix><fim-middle>    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> #include <shared\/volatility\/MyCustomVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility<fim-suffix><fim-middle>model types"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n<fim-suffix><fim-middle>    {\n        m_plugInStatusDescription.Clear();\n        m_instrumentManager.Start();"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams;<fim-suffix>objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});<fim-middle>InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h>\n#include <shared\/volatility\/ClampedCubicSpline.h>\n#include <shared\/volatility\/StochasticVolatilityInspired.h>\n#include <shared\/volatility\/WingVolatilityModel.h>\n#include <shared\/volatility\/MyCustomVolatilityModel.h>\n\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypePtr>\nModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel);\n\ntemplate <class ModelTypeRef>\nModelTypeRef vol_model_cast(volatility::IVolatilityModel & model);\n<fim-suffix><fim-middle>template <class ModelTypeRef>\nModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model);"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n\n    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;\n\n    bool ParallelVerticalShift() const;\n\n    const InstrumentGroup & GetCurrentProductGroup() const { return m_instrumentGroup.GetInstrumentGroup(); }\n    const InstrumentGroup & GetReferenceInstrumentGroup() const { return m_refInstrumentGroup.GetInstrumentGroup(); }\n\n    const InstrumentIdentifier & GetFocusInstrumentIdentifier() const { return m_followedInstrumentId.GetInstrumentIdentifier(); }\n    const Integer & GetFocusInstrumentGroupType() const { return m_instrumentGroupType.GetInteger(); }\n\n    bool NoLayoutInterfaceMode() const { return !m_noLayoutInterfaceMode.Empty() && m_noLayoutInterfaceMode.GetBoolean(); }\n\n    bool GlobalAutoApplyManualFit() const { return !m_globalAutoApplyManualFit.Empty() && m_globalAutoApplyManualFit.GetBoolean(); }\n\n    bool GlobalAutoSuggest() const { return !m_globalAutoSuggest.Empty() && m_globalAutoSuggest.GetBoolean(); }\n\n    int CurveShiftUnits() const;\n\n<fim-suffix><fim-middle>    bool UseExoticOptions() const { return m_currentProductCommonValuesHandler.UseExoticOptions(); }\n    const CalculatedPropertyFilter & GetInstrumentFilter() const { return m_currentProductCommonValuesHandler.GetInstrumentFilter(); }"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi,<fim-suffix><fim-middle>SVI) VOLATILITY(wing, Wing) VOLATILITY(custom, Custom)"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status,<fim-suffix><fim-middle>const tbricks::String& status_text) override;"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include <string>\n#include <string_view>\n#include <vector>"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem &<fim-suffix>{ TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return true; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \"<fim-middle>item)"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)\n    {\n        strm << \"  subscription : \" << Resolve(subscription) << \"\\n\";\n    }\n    if (interval != DeribitInterval::NONE)\n    {\n        strm << \"  interval : \" << Resolve(interval) << \"\\n\";\n    }\n    strm << \"  channel : \" << channel << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nDeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type)\n    : m_handler(handler)\n    , m_timer(*this, \"deribit_refresh\")\n{\n    TBDEBUG(__func__ << \" : \" << endpoint);\n\n    std::string url(endpoint.GetCString());\n    auto found = url.find(\":\/\/\");\n    if (found != std::string::npos)\n    {\n        url = url.substr(found + 3);\n    }\n    m_session.host_port_path = url;\n<fim-suffix><fim-middle>    std::vector<String> slices;\n    m_session.host_port_path.Split(':', slices);\n    TBDUMP(slices);\n    switch (type)"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData {<fim-suffix>std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice();<fim-middle>public: UpdateData(); virtual ~UpdateData();"}
{"content":"<fim-prefix>#include \"PositionReverser.h\" #include \"tbricks_definitions.h\" #include <cmath> using namespace tbricks; void PositionReverser::ReversePosition( const Position& position, const Price& atPrice) { Trade reversedTrade; Volume netPosition = position.GetNetPosition(); if (netPosition > 0) { reversedTrade.SetSide(Side::SELL); } else { reversedTrade.SetSide(Side::BUY); } reversedTrade.SetPrice(atPrice); reversedTrade.SetType(TradeType::POSITION_ADJUSTMENT); reversedTrade.SetCurrency(position.GetCurrency()); reversedTrade.SetClient(position.GetClient()); reversedTrade.SetVolume(std::fabs(position.GetNetPosition())); reversedTrade.SetCounterpart(position.GetCounterpart()); Trade::RequestResult reqCreate = Trade::SendCreateRequest(reversedTrade, *this); m_reversedPositions[reqCreate.GetRequestIdentifier()] = position.GetIdentifier(); TBDEBUG(\"Requested to reverse<fim-suffix><< \" with trade: \" << reqCreate.GetTradeIdentifier()); } void PositionReverser::HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) { TBDEBUG(__func__ << \" \" << id << \" with status \" << status <<<fim-middle>position: \" << position.GetIdentifier()"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType) { return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType)); } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs; #undef VOLATILITY_MODEL_WRAP } } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define<fim-suffix>case VolatilityModel##name: \\ { \\ volatility::GetVolatilitySurfaceParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\"<fim-middle>VOLATILITY_MODEL_WRAP(name, type) \\"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n<fim-suffix><fim-middle>    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    TBSTATUS(\"Subscribing to ticker: \" << id);\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n        Integer enumValue;\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDBEUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n    {\n        TBWARNING(\"Received unknown instrument ticker: \" << ticker);\n        return;\n    }\n    auto request = m_requestMap.find(id);\n    if (request != m_requestMap.end())\n    {\n        for (const auto & object : request->second.GetObjects())\n        {\n            InstrumentIdentifier instrument;\n            object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrument);\n            if (instrument == id)\n            {\n                for (const auto & value : request->second.GetValues())\n                {\n                    if (value.GetDefinition() == dv::DeribitTicker())\n                    {\n                        String data(json.data(), json.size());\n                        IDistributionApp::Update({object.GetIdentifier(), value.GetIdentifier()}, data);\n                        IDistributionApp::Send();\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n<fim-suffix><fim-middle>std::pair<bool, VenueInstrumentIdentifier> DeribitContributor::ExtractVIID(const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : \" << instrument.GetShortName());\n    bool compatible = false;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String& reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); } const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); } const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); } \/\/ TimerController::IHandler void HandleTimerEventHit() final; void HandleTimerControllerUpdate(const tbricks::String&<fim-suffix>private: bool CheckRunningRequirement(); void HandleAction(const tbricks::Integer & action); void Start(); void Stop(); void ImportNow(); \/\/ app parameters tbricks::IntegerParameter m_instrument_enricherAppAction;<fim-middle>update, bool error) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitModel.h\"\n#include <shared\/API.h>\n\nclass DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler\n{\npublic:\n    DeribitMdp();\n    ~DeribitMdp() noexcept override = default;\n\nprotected:\n    void HandleSubscribe(tbricks::MarketDataItem & item) override;\n    void HandleUnsubscribe(tbricks::MarketDataItem & item) override;\n    void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override;\n    void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override;\n    bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override;\n    void GetDiagnostics(tbricks::Diagnostics & diagnostics) override;\n<fim-suffix><fim-middle>    void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamStale(const tbricks::StreamIdentifier & stream) override;\n    void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n{\n    Document msg;\n    StringBuffer buffer;\n};\n\nUpdateData::UpdateData()\n{\n    m_doc = new RapidDocument();\n}\n\nUpdateData::~UpdateData()\n{\n    delete (m_doc);\n}\n\nstd::string_view UpdateData::ToString()\n{\n    m_doc->buffer.Clear();\n    Writer<StringBuffer> writer(m_doc->buffer);\n    m_doc->msg.Accept(writer);\n    return {m_doc->buffer.GetString()};\n}\n\nvoid UpdateData::Parse(const tbricks::String & str)\n{\n    m_doc->msg.Clear();\n    StringStream s(str.GetCString());\n    m_doc->msg.ParseStream(s);\n}\n\nticker_update::ticker_update(const tbricks::String & str)\n    : UpdateData()\n{\n    Parse(str);\n}\n\nstd::string_view ticker_update::GetInstrumentName()\n{\n    auto & msg = m_doc->msg;\n    auto i = msg.FindMember(\"instrument_name\");\n    if (i != msg.MemberEnd())\n    {\n        return i->value.GetString();\n    }\n    return {};\n}\n\nint64_t ticker_update::GetTimestamp()\n{\n    auto & msg = m_doc->msg;\n    auto t = msg.FindMember(\"timestamp\");\n    if (t != msg.MemberEnd())\n    {\n        return t->value.GetInt64();\n    }\n    return 0;\n}\n\nbool ticker_update::IsOpen()\n{\n    auto & msg = m_doc->msg;\n    auto s = msg.FindMember(\"state\");\n    std::string_view state;\n    if (s != msg.MemberEnd())\n    {\n        state = s->value.GetString();\n    }\n    if (not state.empty() and state.compare(\"open\") == 0)\n    {\n        return true;\n    }\n    return false;\n}\n\n#define EXTRACT_DOUBLE_METHOD(method, key, default) \\\n    double method()                                 \\\n    {                                               \\\n        auto & msg = m_doc->msg;                    \\\n        auto v = msg.FindMember(#key);              \\\n        if (v != msg.MemberEnd())                   \\\n<fim-suffix><fim-middle>        {                                           \\\n            return v->value.GetDouble();            \\\n        }                                           \\\n        return default;                             \\"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include<fim-suffix><fim-middle>\"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\" #include \"PositionsData.h\" #include \"tbricks_definitions.h\" #include \"execution\/TbOrderManager.h\" #include \"execution\/TbOrderMinion.h\" #include \"execution\/TbChildOrder.h\" #include <AsyncTask.h> #include <memory> using namespace tbricks; namespace sp = go_flat::strategy_parameters; GoFlatPlugin::GoFlatPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_portfolio(sp::Portfolio()) , m_statusText(sp::PlugInStatusDescription()) , m_executorType(execution::OrderExecutorType::ORDER_MANAGER) { TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered()); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); switch (m_executorType) { case execution::OrderExecutorType::ORDER_MANAGER: m_orders = std::make_unique<execution::TbOrderManager>(*this); break; case execution::OrderExecutorType::CHILD_ORDER: m_orders = std::make_unique<execution::TbChildOrder>(*this, *this); break; case execution::OrderExecutorType::ORDER_MINION: m_orders = std::make_unique<execution::TbOrderMinion>(*this, *this, reason, parameters); break; } m_async = std::make_unique<misc::AsyncProcessor>(m_proc, GetIdentifier()); } void GoFlatPlugin::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); \/\/m_async->DoAsync(); \/\/ UNCOMMENT if you want to fire minion orders after the async task if (not m_positions or m_positions->GetData().empty()) { SetTransactionFail(\"No positions\", StrategyState::PAUSED); return; } if (m_orders) { if (not m_positions->GetData().empty()) { for (const auto& [ivid, pos] : m_positions->GetData()) { if (m_executorType == execution::OrderExecutorType::ORDER_MINION) { execution::TbOrderMinion* minion = static_cast<execution::TbOrderMinion*>(m_orders.get()); minion->MonitorInstrument(ivid); \/\/continue; \/\/ UNCOMMENT if you want to fire minion orders after the async task } TBDEBUG(\"Current ivid: \" << ivid << \", position: \" << pos); if (not pos.Empty() and pos != 0.0) { \/\/ we want to flatten the position so invert the volume m_orders->CreateOrder(ivid, -pos, m_portfolio.GetPortfolioIdentifier()); } } \/\/ we don't want more position updates from now m_positions->Stop(); SetState(StrategyState::RUNNING); return; } } SetState(StrategyState::PAUSED);<fim-suffix>TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_orders) { m_orders->DeleteOrders(); } SetState(StrategyState::PAUSED); } void GoFlatPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_DELETE); if (m_orders) { m_orders->DeleteOrders(); } SetState(StrategyState::DELETED); } void GoFlatPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(\"Modify request: \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); if (modifier.GetParameters().HasParameter(sp::Portfolio()) and not m_portfolio.Empty()) { m_positions = std::make_unique<PositionsData>(m_portfolio.GetPortfolioIdentifier(), m_statusText); } } void GoFlatPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); context.GetItem(m_statusText).SetDirection(ParameterDefinition::Direction::OUTPUT); if (GetState().IsRunning()) { context.GetItem(m_portfolio).SetDirection(ParameterDefinition::Direction::OUTPUT); }<fim-middle>} void GoFlatPlugin::HandlePauseRequest() {"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler<fim-suffix>{ public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates<fim-middle>{ public: class IHandler"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbChildOrder : public OrderExecutor, public tbricks::StrategyStream::IHandler, public tbricks::IRequestReplyHandler { public: TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app); ~TbChildOrder(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void<fim-suffix><fim-middle>HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n<fim-suffix><fim-middle>    Binary_ostream() { }\n    void close()\n    {\n        m_data.Clear();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler, public InstrumentManager::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public<fim-suffix><fim-middle>tbricks::IDistributionApp void HandleRunRequest() override;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using<fim-suffix>: m_stream(handler) , m_mdItem(item)<fim-middle>namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; explicit InstrumentManager(IHandler& handler); ~InstrumentManager(); void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& streamID) final; void HandleStreamStale(const tbricks::StreamIdentifier& streamID) final; void HandleStreamFailed(const tbricks::StreamIdentifier& streamID) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& streamID) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& streamID, const tbricks::Instrument& instrument)<fim-suffix>void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& streamID, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ IRequestReplyHandler void<fim-middle>final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const {<fim-suffix><fim-middle>return m_stream.GetIdentifier(); } bool IsSnapshotDone() const { return m_snapshotDone; }"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbChildOrder : public OrderExecutor, public tbricks::StrategyStream::IHandler, public tbricks::IRequestReplyHandler { public: TbChildOrder(IExecutionHandler& handler, tbricks::Strategy& app); ~TbChildOrder(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/<fim-suffix>protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ StrategyStream::IHandler void HandleStrategyUpdate(const tbricks::StreamIdentifier & stream, const tbricks::StrategyUpdate & update)<fim-middle>negative for sell         const tbricks::PortfolioIdentifier& portfolio) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/VisualizationApp.h>\n#include <strategy\/visualization\/ViewModelUpdate.h>\n#include <strategy\/visualization\/ICellValue.h>\n#include <strategy\/visualization\/Grid.h>\n#include \"InstrumentManager.h\"\n#include \"TimerController.h\"\n\nclass InstrumentEnricherPlugin : public tbricks::VisualizationApp\n                               , public InstrumentManager::IHandler\n                               , public TimerController::IHandler\n\n{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n\n    void HandleStrategyViewCreate(tbricks::visualization::models::AppViewModel & viewModel,\n                                  const tbricks::visualization::ViewModelUpdate & update) final;\n    void HandleStrategyViewUpdate(tbricks::visualization::models::AppViewModel & viewModel,\n                                  const tbricks::visualization::ViewModelUpdate & update) final;\n    void HandleStrategyViewDelete(tbricks::visualization::models::AppViewModel & viewModel) final { }\n    void HandleGridViewCreate(tbricks::visualization::models::GridViewModel & viewModel,\n                              const tbricks::visualization::ViewModelUpdate & update) final { }\n    void HandleGridViewUpdate(tbricks::visualization::models::GridViewModel & viewModel,\n                              const tbricks::visualization::ViewModelUpdate & update) final { }\n    void HandleImportComplete(const tbricks::String& status) final;\n    void HandleInstrumentManagerFailed(const tbricks::String& reason) final;\n    const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); }\n    const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); }\n    const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); }\n\n    void HandleTimerEventHit() final;\n    void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final;\n\nprivate:\n    bool CheckRunningRequirement();\n    void HandleAction(const tbricks::Integer & action);\n    void Start();\n    void Stop();\n    void ImportNow();\n\n    tbricks::IntegerParameter                          m_instrument_enricherAppAction;\n    tbricks::DurationParameter                         m_importFrequency;\n    tbricks::InstrumentGroupParameter                  m_instrumentGroup;\n    tbricks::DateTimeParameter                         m_maturityDate;\n    tbricks::StringParameter                           m_plugInStatusDescription;\n    tbricks::DateTimeParameter                         m_startTime;\n    tbricks::InstrumentIdentifierParameter             m_underlyingInstrument;\n<fim-suffix><fim-middle>    tbricks::visualization::Grid                       m_instrumentsGrid;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/test\/TestEngine.h> using namespace tbricks; using namespace tbricks::test; #ifndef TIMEOUT #define TIMEOUT tbricks::Duration::Seconds(5) #endif void Test(TestEngine &te); tbricks::String get_current_root(); tbricks::String get_apps_relative(); int main(int \/*argc*\/, char * \/*argv*\/[]) { TestEngine te(\"..\/system.xml\", \"..\/engine.xml\"); te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\"); te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString()); te.RunTest(Test, TIMEOUT); return 0; } namespace go_flat { tbricks::VenueIdentifier GetTestVenueId() { return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"}; } tbricks::PortfolioIdentifier GetPortfolioId() { return {\"2eb2249c-bc89-11ee-a950-d946a31b499d\"}; } } \/\/ namespace go_flat #include <filesystem> namespace fs = std::filesystem; tbricks::String get_current_root() { fs::path current(fs::current_path()); fs::path apps; if (std::getenv(\"TB_APPS\") == nullptr) { apps = fs::path(\"\/opt\/tbricks\/apps\"); } else { apps = fs::path(std::getenv(\"TB_APPS\")); } current = fs::relative(current, apps); return tbricks::String(current.c_str()); }<fim-suffix>{ fs::path apps; if (std::getenv(\"TB_APPS\") == nullptr)<fim-middle>tbricks::String get_apps_relative()"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class InstrumentEnricherPlugin : public tbricks::Strategy { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy<fim-suffix>void HandleRunRequest() final; void HandlePauseRequest() final;<fim-middle>methods void HandleDeleteRequest() final;"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n<fim-suffix><fim-middle>        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n\nvoid DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;\n    token.Clear();\n    refresh.Clear();\n    expires.Clear();\n    expires_datetime.Clear();\n}\n\nstd::ostream & DeribitClient::Session::Print(std::ostream & strm) const\n{\n    strm << \"<Session> {\\n\";\n    strm << \"  connected = \" << std::boolalpha << connected << \"\\n\";\n    strm << \"  logged_in = \" << std::boolalpha << logged_in << \"\\n\";\n    strm << \"  heartbeat = \" << hb << \"\\n\";\n    strm << \"  userId = \" << userId << \"\\n\";\n    strm << \"  secret = \" << secret << \"\\n\";\n    strm << \"  host_port_path = \" << host_port_path << \"\\n\";\n    strm << \"  token = \" << token << \"\\n\";\n    strm << \"  refresh = \" << refresh << \"\\n\";\n    strm << \"  expires = \" << expires << \"\\n\";\n    strm << \"  expires_datetime = \" << expires_datetime << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & operator<<(std::ostream & strm, const SingleTransaction & t)\n{\n    strm << \"<SingleTransaction> {\\n\";\n    strm << \"  id : \" << t.id << \"\\n\";\n    strm << \"  method : \" << Resolve(t.method) << \"\\n\";\n    if (t.call)\n    {\n        strm << \"  call : \" << t.call->ToString() << \"\\n\";\n    }\n    if (t.reply)\n    {\n        strm << \"  reply : \" << t.reply->ToString() << \"\\n\";\n    }\n    if (not t.reqChannels.empty())\n    {\n        strm << \"  reqChannels : \" << t.reqChannels << \"\\n\";\n    }\n    strm << \"}\";\n    return strm;\n}\n\nstd::ostream & DeribitClient::Subscription::Print(std::ostream & strm) const\n{\n    strm << \"<Subscription> {\\n\";\n    strm << \"  ticker : \" << ticker << \"\\n\";\n    if (subscription != DeribitSubscription::NONE)\n    {\n        strm << \"  subscription : \" << Resolve(subscription) << \"\\n\";\n    }\n    if (interval != DeribitInterval::NONE)\n    {\n        strm << \"  interval : \" << Resolve(interval) << \"\\n\";\n    }\n    strm << \"  channel : \" << channel << \"\\n\";\n    strm << \"}\";\n    return strm;\n}\n\nDeribitClient::DeribitClient(IHandler & handler, const String & endpoint, DeribitHost type)\n    : m_handler(handler)\n    , m_timer(*this, \"deribit_refresh\")\n{\n    TBDEBUG(__func__ << \" : \" << endpoint);\n\n    std::string url(endpoint.GetCString());\n    auto found = url.find(\":\/\/\");\n    if (found != std::string::npos)\n    {\n        url = url.substr(found + 3);\n    }\n    m_session.host_port_path = url;\n\n    std::vector<String> slices;\n    m_session.host_port_path.Split(':', slices);\n    TBDUMP(slices);\n    switch (type)\n    {\n    case DeribitHost::NONE:\n<fim-suffix><fim-middle>        m_conf.header.insert({\"Host\", slices[0].GetCString()});\n        break;\n    default:\n        m_conf.header.insert({\"Host\", Resolve(type)});"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n<fim-suffix><fim-middle>    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        m_pendingRequests.insert({request.GetIdentifier(), request});\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    if (v.GetDefinition() == dv::DeribitTicker())\n                    {\n                        m_client->SubscribeToTicker({id});\n                    }\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n<fim-suffix><fim-middle>    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request)<fim-suffix><fim-middle>override; private: \/\/ App parameters     tbricks::StringParameter m_clientID;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\" class PositionsData; namespace execution { class OrderExecutor; } namespace misc { class AsyncProcessor; } class GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler { public: GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ Strategy methods void HandleDeleteRequest() override; void HandleRunRequest() override; void HandlePauseRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override; void HandleValidateRequest(tbricks::ValidationContext &context) override; void HandleScheduledEvent(tbricks::UserData&& data) override; \/\/ OrderHandler::IHandler<fim-suffix>void AllDone(const execution::Stats& stats) override; private: \/\/ app<fim-middle>void PanicStop(const tbricks::String& msg) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n<fim-suffix><fim-middle>    virtual void HandleMessage(std::string_view message) = 0;\n};"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class InstrumentEnricherPlugin : public tbricks::Strategy { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; private: \/\/ app parameters tbricks::ParameterDefinition \/*InstrumentGroup*\/<fim-suffix><fim-middle>m_instrumentGroup; tbricks::DateTimeParameter m_maturityDate;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;\n    }\n}\n\nvoid InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n    {\n        const int total = m_instrumentCache.size();\n\n        std::stringstream result;\n        result << \"Total instruments = \" << total << \", successful = \" << total - m_failed\n               << \", failed = \" << m_failed;\n\n        m_handler.HandleImportComplete(result.str());\n    }\n}\n\nvoid InstrumentManager::EnrichInstruments()\n{\n    TBDEBUG(__func__);\n\n    for (const auto& [instID, instrument] : m_instrumentCache)\n    {\n        InstrumentModifier instrumentModifier(instID);\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        if (tbMaturityDate != m_handler.GetMaturityDate())\n        {\n            InstrumentAttributes attributes;\n            attributes.SetAttribute(instrument_attributes::MaturityDate(), m_handler.GetMaturityDate());\n            instrumentModifier.SetAttributes(attributes);\n            Instrument::RequestResult result = Instrument::SendModifyRequest(instrumentModifier, *this);\n            m_instrumentModifyRequests.emplace(result.GetRequestIdentifier(), instID);\n        }\n    }\n\n    ModifyGroup();\n    CheckModificationStatus();\n}\n\nvoid InstrumentManager::ModifyGroup()\n{\n    TBDEBUG(__func__);\n\n    InstrumentGroupIdentifier groupID = m_handler.GetInstrumentGroup().GetIdentifier();\n    std::vector<InstrumentParameterDefinition> defs;\n    defs.push_back(instrument_parameters::UnderlyingInstrument());\n\n    InstrumentGroupParameters groupParams(groupID, defs);\n    InstrumentIdentifier underlyingInstrument;\n    groupParams.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingInstrument);\n\n    InstrumentGroupParameters::Modifier modifier;\n    if (underlyingInstrument.Empty())\n<fim-suffix><fim-middle>    {\n        modifier.SetParameter(instrument_parameters::UnderlyingInstrument(), m_handler.GetUnderlyingInstrument());\n    }\n    else"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return false;\n}\n<fim-suffix><fim-middle>void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";"}
{"content":"<fim-prefix>#pragma once #include <strategy\/EventProcessor.h> #include <future> namespace misc { class AsyncProcessor { private: const tbricks::EventProcessor& m_proc; tbricks::StrategyIdentifier m_id; std::string m_result; public: AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc),<fim-suffix><fim-middle>m_id(appId) {};"}
{"content":"<fim-prefix>#pragma once\n\n#include \"shared\/API.h\"\n#include <map>\n\nclass PositionRetriever : public tbricks::PositionStream::IHandler\n{\npublic:\n\n    class IHandler;\n\n    PositionRetriever(IHandler& callback);\n\n    void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId);\n    void Stop();\n\n    void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier &stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier &stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier &stream) final;\n\n    \/**\n     * PositionStream::IHandler\n     *\/\n    void HandlePosition(const tbricks::StreamIdentifier & stream_id,\n                        const tbricks::Position & position) final;\n\n    void HandlePositionInvalidate(  const tbricks::StreamIdentifier & stream_id,\n                                    const tbricks::Identifier & id) final;\n<fim-suffix><fim-middle>private:"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just<fim-suffix><fim-middle>the frequency         m_startTimerEvent.Start(m_frequency);"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType) { return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType)); } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs; #undef VOLATILITY_MODEL_WRAP } } std::vector<InstrumentParameterDefinition><fim-suffix>{ std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name:<fim-middle>VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType)"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n<fim-suffix><fim-middle>    {\n        auto * model = *model_opt;\n        model->Reset();\n    }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto<fim-suffix><fim-middle>data = static_cast<char *>(m_data.GetData());"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest &<fim-suffix>private: \/\/<fim-middle>request) override;"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired) VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(None,ConstantVolatility)"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace<fim-suffix>typedef std::pair<DeribitMethod, std::string> Method; \/\/ Attempt to order<fim-middle>deribit {"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n\n    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;\n\n    bool ParallelVerticalShift() const;\n\n    const InstrumentGroup & GetCurrentProductGroup() const { return m_instrumentGroup.GetInstrumentGroup(); }\n    const InstrumentGroup & GetReferenceInstrumentGroup() const { return m_refInstrumentGroup.GetInstrumentGroup(); }\n\n    const InstrumentIdentifier & GetFocusInstrumentIdentifier() const { return m_followedInstrumentId.GetInstrumentIdentifier(); }\n    const Integer & GetFocusInstrumentGroupType() const { return m_instrumentGroupType.GetInteger(); }\n\n    bool NoLayoutInterfaceMode() const { return !m_noLayoutInterfaceMode.Empty() && m_noLayoutInterfaceMode.GetBoolean(); }\n\n    bool GlobalAutoApplyManualFit() const { return !m_globalAutoApplyManualFit.Empty() && m_globalAutoApplyManualFit.GetBoolean(); }\n<fim-suffix><fim-middle>    bool GlobalAutoSuggest() const { return !m_globalAutoSuggest.Empty() && m_globalAutoSuggest.GetBoolean(); }"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; }<fim-suffix>void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; }<fim-middle>template <>"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public:<fim-suffix>protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem &<fim-middle>DeribitMdp(); ~DeribitMdp() noexcept override = default;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);<fim-suffix><fim-middle>if (m_client)"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\"\n#include \"shared\/order_minion\/OrderMinionCancelRequest.h\"\n#include \"shared\/order_minion\/tbricks_definitions.h\"\n#include \"shared\/sdk_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters)\n: OrderExecutor(handler)\n, m_controller( reason, app)\n{\n    TBDEBUG(__func__);\n\n}\n\nTbOrderMinion::~TbOrderMinion()\n{\n    TBDEBUG(__func__);\n    DeleteOrders();\n}\n\nvoid TbOrderMinion::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume, \/\/ negative for sell\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n<fim-suffix><fim-middle>    OrderMinionRequest req(this);\n    req.SetExecution(enumerations::OrderMinionExecutionHitRepeatedly);\n    req.SetIVID(ivid);\n    req.SetMarketDataIVID(ivid);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/test\/TestEngine.h> using namespace tbricks; using namespace tbricks::test; #ifndef TIMEOUT #define TIMEOUT tbricks::Duration::Seconds(5) #endif void Test(TestEngine &te); tbricks::String get_current_root(); tbricks::String get_apps_relative(); int main(int<fim-suffix>TestEngine te(\"..\/system.xml\", \"..\/engine.xml\"); te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\"); te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString()); te.RunTest(Test, TIMEOUT); return 0; } namespace go_flat { tbricks::VenueIdentifier GetTestVenueId() { return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"}; } tbricks::PortfolioIdentifier GetPortfolioId() { return {\"2eb2249c-bc89-11ee-a950-d946a31b499d\"}; } }<fim-middle>\/*argc*\/, char * \/*argv*\/[]) {"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionReverser : public tbricks::IRequestReplyHandler { public: PositionReverser() = default; ~PositionReverser() = default; void ReversePosition( const tbricks::Position& position, const tbricks::Price& atPrice); \/\/ IRequestReplyHandler method void HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) final; private: std::map<tbricks::Identifier,<fim-suffix><fim-middle>tbricks::Identifier> m_reversedPositions; };"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\"<fim-suffix>using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); }<fim-middle>#include \"tbricks_definitions.h\" #include <cstdlib>"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return false;\n}\n<fim-suffix><fim-middle>void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";"}
{"content":"<fim-prefix>#include \"PositionsData.h\" #include \"tbricks_definitions.h\" #include <strategy\/Logger.h> #include <strategy\/stream_filter\/PositionByPortfolioFilter.h><fim-suffix><fim-middle>#include <strategy\/SparseSet.h>"}
{"content":"<fim-prefix>#include \"PositionReverser.h\" #include \"tbricks_definitions.h\" #include <cmath> using namespace tbricks; void PositionReverser::ReversePosition( const Position& position, const Price& atPrice) { Trade reversedTrade; Volume netPosition = position.GetNetPosition(); if (netPosition > 0) { reversedTrade.SetSide(Side::SELL); } else { reversedTrade.SetSide(Side::BUY); } reversedTrade.SetPrice(atPrice); reversedTrade.SetType(TradeType::POSITION_ADJUSTMENT); reversedTrade.SetCurrency(position.GetCurrency()); reversedTrade.SetClient(position.GetClient()); reversedTrade.SetVolume(std::fabs(position.GetNetPosition())); reversedTrade.SetCounterpart(position.GetCounterpart()); Trade::RequestResult reqCreate = Trade::SendCreateRequest(reversedTrade, *this); m_reversedPositions[reqCreate.GetRequestIdentifier()] = position.GetIdentifier(); TBDEBUG(\"Requested to reverse position: \" << position.GetIdentifier() << \" with trade: \" << reqCreate.GetTradeIdentifier()); } void PositionReverser::HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status,<fim-suffix>{ TBDEBUG(__func__ << \" \" << id << \" with status \" << status << \" \" << status_text); auto iterCreate = m_reversedPositions.find(id); bool isCreateRequest = (iterCreate != m_reversedPositions.end()); if (not isCreateRequest) { TBDEBUG(\"Received unknow request reply.\"); return; } if (status<fim-middle>const tbricks::String & status_text)"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } namespace deribit { using Method = std::pair<DeribitMethod, std::string>; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods() { return { {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)}, {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)}, {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)}, {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}};<fim-suffix><fim-middle>} } \/\/ namespace deribit"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n<fim-suffix><fim-middle>std::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); \/\/ Perform an operation SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ <<<fim-suffix>\/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription<fim-middle>\" : \" << modifier);"}
{"content":"<fim-prefix>#pragma once #include<fim-suffix>#include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; };<fim-middle><string_view>"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/<fim-suffix>unsigned short<fim-middle>Set proxy authorization (username:password)         std::string proxy_auth;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n<fim-suffix><fim-middle>JsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n    \n    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }\n\n    TBDUMP(bbo);\n    m_mdItem.PartialUpdate(bbo);\n    if (not stats.Empty())\n    {\n        m_mdItem.PartialUpdate(stats);\n    }\n\n    if (not status.Empty())\n    {\n        TBDUMP(status);\n        m_mdItem.PartialUpdate(status);\n    }\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)\n{\n    String value;\n    it.GetValue(value);\n    TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);\n\n     if (id.second != m_tickerId)\n    {\n        TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id);\n        return;\n    }\n\n    if (value.Empty() or (value == \"{}\") or value.HasError())\n    {\n        Price emptyPrice;\n        Volume emptyVolume {0};\n        iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale);\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\");\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n        bbo.SetAskPrice(emptyPrice);\n        bbo.SetBidPrice(emptyPrice);\n        bbo.SetAskVolume(emptyVolume);\n        bbo.SetBidVolume(emptyVolume);\n        return;\n    }\n\n    iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk);\n    iStatus.SetVenueInstrumentMarketDataStatus(\"OK\");\n\n    deribit::ticker_update update(value);\n\n    if (update.IsOpen())\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed);\n    }\n    else\n    {\n        iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed);\n        iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed);\n    }\n\n    bbo.SetAskPrice(update.GetAsk());\n    bbo.SetBidPrice(update.GetBid());\n    bbo.SetAskVolume(update.GetAskVolume());\n    bbo.SetBidVolume(update.GetBidVolume());\n    auto millis = update.GetTimestamp();\n    DateTime timestamp = DateTime::Now();\n    if (millis > 0)\n    {\n        timestamp = DateTime::Create(millis \/ 1000);\n    }\n    bbo.SetExchangeModifiedDatetime(timestamp);\n    \n    stats.SetLastPrice(update.GetLastPrice());\n    stats.SetOpenInterest(update.GetOpenInterest());\n    stats.SetDailySettlementPrice(update.GetSettlementPrice());\n    stats.SetHighPrice(update.GetMaxPrice());\n    stats.SetLowPrice(update.GetMinPrice());\n}\n\nvoid DeribitModel::Reset()\n{\n    InstrumentStatus status;\n    BestPrice bbo;\n    Price emptyPrice;\n    Volume emptyVolume;\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale);\n    status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\");\n    status.SetVenueInstrumentTradingStatus(String());\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    bbo.SetAskPrice(emptyPrice);\n    bbo.SetBidPrice(emptyPrice);\n    bbo.SetAskVolume(emptyVolume);\n    bbo.SetBidVolume(emptyVolume);\n\n    m_mdItem.PartialUpdate(status);\n    m_mdItem.PartialUpdate(bbo);\n    m_mdItem.Flush();\n    SendSnapshotDoneIfNeeded();\n}\n\nvoid DeribitModel::Fail()\n{\n    InstrumentStatus status;\n    BestPrice bbo;\n<fim-suffix><fim-middle>    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n\nprivate:\n    std::string_view type;\n};\n\nclass subscriptions : public JsonCall\n{\npublic:\n    subscriptions(const std::string_view id, DeribitMethod method);\n\n    void AddChannel(const std::string & channel);\n};\n\nclass subscriptions_reply : public JsonReply\n{\npublic:\n    subscriptions_reply(JsonReply && base);\n\n    std::vector<std::string_view> GetChannels() const;\n};\n\nclass subscription_update : public JsonReply\n{\npublic:\n    subscription_update(JsonReply && base);\n<fim-suffix><fim-middle>    std::string_view GetChannel() const;\n    std::string_view GetData();"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\" #include \"shared\/order_minion\/OrderMinionCancelRequest.h\" #include \"shared\/order_minion\/tbricks_definitions.h\" #include \"shared\/sdk_definitions.h\" using namespace tbricks; namespace execution { TbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters) : OrderExecutor(handler) , m_controller( reason, app) { TBDEBUG(__func__); } TbOrderMinion::~TbOrderMinion() { TBDEBUG(__func__); DeleteOrders(); } void TbOrderMinion::CreateOrder( const InstrumentVenueIdentification& ivid, const Volume& volume, \/\/ negative for sell const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio); OrderMinionRequest req(this); req.SetExecution(enumerations::OrderMinionExecutionHitRepeatedly); req.SetIVID(ivid); req.SetMarketDataIVID(ivid); req.SetPortfolio(portfolio); req.SetSide((volume > 0.0 ? Side::BUY : Side::SELL)); req.SetVolume(volume.Abs()); req.SetPriceMode(enumerations::OrderMinionPrice::OrderMinionPriceBestPossible); auto result = m_controller.Request(req); if (result == OrderMinionController::FAILURE) { m_handler.PanicStop(result.GetError()); return; } m_requests[ivid] = req; } void TbOrderMinion::DeleteOrders() {<fim-suffix>{ m_controller.Prepare(ivid); } void TbOrderMinion::HandleOrderMinionUpdate( const OrderMinionUpdate& update ) { TBDEBUG(__func__ << \" : \" << update); if (update.DidFail()) { m_handler.PanicStop(update.GetError()); } else if (update.IsFinished()) { const auto& reqId = update.GetRequestID(); auto it = std::find_if(m_requests.begin(), m_requests.end(), [&reqId](const auto& req){ return req.second.GetRequestID() == reqId; }); if (it == m_requests.end()) { TBWARNING(\"Received update for unknown request\"); return; } TBDEBUG(\"Completed order<fim-middle>TBDEBUG(__func__); m_controller.Stop(); } void TbOrderMinion::MonitorInstrument(const InstrumentVenueIdentification &ivid)"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <=<fim-suffix>return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char<fim-middle>0) return ostm; ostm.write(val.c_str(), val.size());"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { \/\/ Here is where we would open the DistributedValues::Stream } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update<fim-suffix><fim-middle>& update)"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include \"shared\/app\/app.h\"\nCLANG_RESTORE_WARNINGS\n\n#include <limits>\n\nusing namespace tbricks;\n\nclass ValuesRequest;\n\nstruct ImpliedValue\n{\n    void Clear();\n\n    friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value)\n    { return value.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    Double implied_volatility;\n};\n\nstruct FairPriceValue\n{\n    FairPriceValue & operator += (const FairPriceValue & fair_price_value);\n    FairPriceValue & operator += (const Double & value);\n    FairPriceValue   operator *  (const Double & mult) const;\n    FairPriceValue & operator *= (const Double & mult);\n\n    void Clear();\n\n    bool SetError(const String & error);\n\n    friend std::ostream & operator << (std::ostream & strm, const FairPriceValue & price)\n    { return price.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;\n\n    uint64_t version = std::numeric_limits<uint64_t>::max();\n    Double fair_price;\n};\n\nstruct Greeks\n{\n    Greeks & operator += (const Greeks & greeks);\n    Greeks   operator  * (const Double & mult) const;\n    Greeks & operator *= (const Double & mult);\n\n    void Clear();\n    void ClearNoncombinationValues();\n\n    void Set(const Greeks & greeks);\n\n    bool SetError(const String & error);\n\n    void SetErrorToCCSVolatilityModelGreeks(const String & error);\n    void SetErrorToWingVolatilityModelGreeks(const String & error);\n\n    void ZeroFill();\n\n    friend std::ostream & operator << (std::ostream & strm, const Greeks & greeks)\n<fim-suffix><fim-middle>    { return greeks.Print(strm); }\n    std::ostream & Print(std::ostream & strm) const;"}
{"content":"<fim-prefix>#pragma once\n#include <shared\/API.h>\n#include \"tbricks_definitions.h\"\n<fim-suffix><fim-middle>class TimerController : public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply :<fim-suffix>struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public:<fim-middle>public Json { public:"}
{"content":"<fim-prefix>#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include <strategy\/Logger.h>\n#include <strategy\/stream_filter\/PositionByPortfolioFilter.h>\n#include <strategy\/SparseSet.h>\n#include <sstream>\n#include <vector>\n\nusing namespace tbricks;\n\nnamespace cps = go_flat::calculated_properties::position;\n\nPositionsData::PositionsData(const PortfolioIdentifier& portfolioId, StringParameter& status)\n: m_appStatus(status)\n, m_stream(*this)\n{\n    TBDEBUG(__func__ << \" : \" << portfolioId);\n\n    CalculatedPropertiesTable::Stream::Options options;\n\n    options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {});\n\n    options.AddProperty(cps::Instrument());\n    options.AddProperty(cps::Venue());\n    options.AddProperty(cps::MIC());\n    options.AddProperty(cps::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS());\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n    TBDUMP(\"Stream opened with options: \" << options);\n}\n\nPositionsData::~PositionsData()\n{\n    TBDEBUG(__func__);\n    m_stream.Close();\n}\n\nvoid PositionsData::Stop()\n{\n    TBDEBUG(__func__);\n    m_stream.Close();\n}\n\nvoid PositionsData::HandleStreamOpen(const StreamIdentifier& stream)\n{\n    m_appStatus = \"Waiting for positions data\";\n}\n\nvoid PositionsData::HandleStreamStale(const StreamIdentifier& stream)\n{\n    m_appStatus = \"STALE STREAM for positions data\";\n}\n\nvoid PositionsData::HandleStreamFailed(const StreamIdentifier& stream)\n{\n    m_appStatus = \"FAILED STREAM for positions data\";\n}\n\nvoid PositionsData::HandleSnapshotEnd(const StreamIdentifier& stream)\n{\n    TBDEBUG(__func__ << \" : \" << stream);\n    RefreshStatusText();\n}\n\nvoid PositionsData::HandleCalculatedProperties(const StreamIdentifier & stream_id, const CalculatedPropertiesTable::Update & update)\n{\n    TBDEBUG(__func__ << \" : \" << update);\n    m_table.Merge(update);\n\n    if (m_stream.IsSnapshotDone())\n    {\n        RefreshStatusText();\n    }\n}\n\nvoid PositionsData::RefreshStatusText()\n<fim-suffix><fim-middle>{\n    std::stringstream ss;\n    ss << \"Received \" << m_table.GetRows().size() << \" positions\" << std::endl;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/EventProcessor.h> #include <future> namespace misc { class AsyncProcessor { private: const tbricks::EventProcessor& m_proc; tbricks::StrategyIdentifier m_id; std::string m_result; public: AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc), m_id(appId) {}; void DoAsync() { std::thread([this]{ std::this_thread::sleep_for(std::chrono::seconds(3)); m_result = \"ASYNC SUCCESS\"; tbricks::UserData payload; payload.Set(&m_result, 0); \/\/ we can do shallow copy because the string is a member variable m_proc.ScheduleStrategyEvent(m_id, payload); }).detach(); } bool HasResult() const { return not m_result.empty(); } const std::string& GetResult() const { return m_result;<fim-suffix><fim-middle>} };"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char *<fim-suffix>{ setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) {<fim-middle>p, size_t l)"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n<fim-suffix><fim-middle>const PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Reset(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Fail(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update) { TBDEBUG(__func__ << \": \" << stream); TBDUMP(update); auto model_opt = GetModel(stream); if (model_opt) { auto * model<fim-suffix><fim-middle>= *model_opt; model->HandleDistributedValuesUpdate(update); }"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewCreate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    viewModel.MergeUpdate(update);\n}\n\nvoid InstrumentEnricherPlugin::HandleStrategyViewUpdate(visualization::models::AppViewModel& viewModel,\n                                                 const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    auto it = update.begin();\n    while (it != update.end())\n    {\n        TBDUMP(it.GetCell().GetCalculatedProperty() << \" \" << it.GetCell().GetCellValue());\n\n        auto & calcProp = it.GetCell().GetCalculatedProperty().GetDefinition();\n        auto & cellValue = it.GetCell().GetCellValue();\n\n        if (calcProp == instrument_enricher::calculated_properties::strategy::ImportFrequency())\n        {\n            m_importFrequency = cellValue.GetDuration();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::InstrumentGroup())\n        {\n            m_instrumentGroup = cellValue.GetInstrumentGroupIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::UnderlyingInstrument())\n<fim-suffix><fim-middle>        {\n            m_underlyingInstrument = cellValue.GetInstrumentIdentifier();\n        }\n        else if (calcProp == instrument_enricher::calculated_properties::strategy::StartTime())"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VizualizationApp methods void HandleStrategyViewCreate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update)<fim-suffix>void HandleStrategyViewUpdate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleStrategyViewDelete( tbricks::visualization::models::AppViewModel& viewModel) final; void HandleGridViewCreate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleGridViewUpdate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleGridViewDelete(tbricks::visualization::models::GridViewModel& viewModel) final; \/\/ ReversalManager::IHandler methods<fim-middle>final;"}
{"content":"<fim-prefix>#pragma once #include <third_party\/include\/rapidjson\/document.h> #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void<fim-suffix>void<fim-middle>HandleWebsocketDisconnected(const tbricks::String & reason) final;"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT,\n    PUBLIC_GetInstruments,\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    case DeribitMethod::PUBLIC_GetInstruments:\n        return \"public\/get_instruments\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n<fim-suffix><fim-middle>    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n\ntemplate <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);\n}\n\ntemplate <>\nBinary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)\n{\n    if (val.size() <= 0)\n        return ostm;\n\n    ostm.write(val.c_str(), val.size());\n\n    return ostm;\n}\n\nBinary_ostream & operator<<(Binary_ostream & ostm, const char * val)\n{\n    int size = std::strlen(val);\n    if (size <= 0)\n        return ostm;\n<fim-suffix><fim-middle>    ostm.write(val, size);"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n\nclass InstrumentEnricherPlugin : public tbricks::Strategy\n{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n<fim-suffix><fim-middle>protected:\n    bool CheckRunningRequirement();"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentsGrid(instrument_enricher::strategy_parameters::InstrumentsGrid(), *this)\n    , m_importOnce(false)\n    , m_instrumentManager(*this, m_instrumentsGrid)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n<fim-suffix><fim-middle>    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; namespace dv = deribit_contributor::distributed_values; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); m_supported_values.insert(dv::DeribitTicker().GetIdentifier()); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::FailWithReason(const String & reason) { SetTransactionFail(reason, StrategyState::PAUSED); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); DistributedValuesReply reply(request.GetIdentifier(), false); \/\/ Check that all objects are supported by the app InstrumentIdentifier instrumentId; for (const auto & object : request.GetObjects()) { auto & objParams = object.GetParameters(); if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency())) { \/\/ if instrument is not defined in the request TBDEBUG(\"Object missing required parameters:\\n\" << object << \"Rejecting request.\"); IDistributionApp::SendDistributedValuesReply(reply); return; } \/\/ Check instrument listed<fim-suffix>auto [compatible, viid] = ExtractVIID(i); if (not compatible) { TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\"); IDistributionApp::SendDistributedValuesReply(reply); return; } } for (const auto & value : request.GetValues()) { if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end()) { TBDEBUG(\"Unsupported value:\\n\" << value << \"Rejecting request.\"); IDistributionApp::SendDistributedValuesReply(reply); return; } } if (GetState() == StrategyState::PAUSED) { TBDEBUG(\"Request cannot be answered immediately. App is paused.\"); return; } \/\/ Send successful reply reply.SetSupported(true); IDistributionApp::SendDistributedValuesReply(reply); } void DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); InstrumentIdentifier instrumentId; const auto & request_id = request.GetIdentifier(); \/\/ For all objects in the request ... for (const auto & object : request.GetObjects()) { if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId)) { auto [compatible, viid] = ExtractVIID({instrumentId}); if (m_client and compatible) { SparseHash<String, String> keys; viid.GetKeys(keys); auto & id = keys[\"symbol\"]; for (const auto & v : request.GetValues()) {<fim-middle>on venue Instrument i(instrumentId);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h><fim-suffix>{ public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return<fim-middle>class DeribitModel"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } namespace deribit {<fim-suffix>\/\/ Attempt<fim-middle>using Method = std::pair<DeribitMethod, std::string>;"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"execution\/IExecutionHandler.h\" class PositionsData; namespace execution { class OrderExecutor; } namespace misc { class AsyncProcessor; } class GoFlatPlugin : public tbricks::Strategy, public execution::IExecutionHandler { public: GoFlatPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ Strategy methods void HandleDeleteRequest() override; void HandleRunRequest() override; void HandlePauseRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override; void HandleValidateRequest(tbricks::ValidationContext &context) override; void HandleScheduledEvent(tbricks::UserData&& data) override; \/\/ OrderHandler::IHandler void PanicStop(const tbricks::String& msg) override; void AllDone(const execution::Stats& stats) override; private: \/\/ app<fim-suffix>tbricks::StringParameter m_statusText; std::unique_ptr<PositionsData> m_positions; std::unique_ptr<execution::OrderExecutor> m_orders; tbricks::EventProcessor m_proc;<fim-middle>parameters tbricks::PortfolioIdentifierParameter m_portfolio;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n\nprivate:\n    std::string_view type;\n};\n<fim-suffix><fim-middle>class subscriptions : public JsonCall\n{\npublic:\n    subscriptions(const std::string_view id, DeribitMethod method);"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return false; }<fim-suffix>{ diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for<fim-middle>void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing)<fim-suffix><fim-middle>VOLATILITY(custom, Custom)"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n<fim-suffix><fim-middle>    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}"}
{"content":"<fim-prefix>VOLATILITY_MODEL_WRAP(SVI,StochasticVolatilityInspired) VOLATILITY_MODEL_WRAP(CCS,ClampedCubicSpline) VOLATILITY_MODEL_WRAP(Wing,WingVolatilityModel)<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP(None,ConstantVolatility)"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetState(StrategyState::RUNNING); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all<fim-suffix><fim-middle>modified parameters and attributes     GetParameters().Merge(modifier.GetParameters());"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <deribit\/DeribitClient.h>\n\nclass DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler\n{\npublic:\n    DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n    ~DeribitContributor() noexcept override = default;\n\nprotected:\n<fim-suffix><fim-middle>    void HandleRunRequest() override;\n    void HandlePauseRequest() override;\n    void HandleDeleteRequest() override;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public<fim-suffix><fim-middle>Json { public:"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT, PUBLIC_GetInstruments, }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case<fim-suffix>return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; case DeribitMethod::PUBLIC_GetInstruments: return \"public\/get_instruments\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {};<fim-middle>DeribitMethod::PRIVATE_Unsubscribe:"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler, public InstrumentManager::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy,<fim-suffix>void HandlePauseRequest() override;<fim-middle>public tbricks::IDistributionApp void HandleRunRequest() override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n<fim-suffix><fim-middle>    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler ,<fim-suffix>, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid); ~InstrumentManager() noexcept<fim-middle>public tbricks::CalculatedInstrumentValues::Stream::IHandler"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <optional> struct DeribitInstrument { tbricks::String instrument_name; tbricks::String instrument_type; tbricks::String kind; tbricks::String settlement_currency; tbricks::String settlement_period; tbricks::String quote_currency; tbricks::String counter_currency; tbricks::String option_type; \/\/ \"call\" or \"put\" for options std::optional<tbricks::Double> strike; \/\/ Only for options tbricks::DateTime expiration_timestamp; tbricks::Double tick_size; tbricks::Double contract_size; tbricks::Boolean is_active; \/\/ Constructor that safely extracts data from rapidjson Value static std::optional<DeribitInstrument> FromJson(const rapidjson::Value& value) { DeribitInstrument data; \/\/ Required fields - if any of these are missing, return nullopt if (!value.HasMember(\"instrument_name\") || !value[\"instrument_name\"].IsString() || !value.HasMember(\"kind\") || !value[\"kind\"].IsString() || !value.HasMember(\"settlement_currency\") || !value[\"settlement_currency\"].IsString() || !value.HasMember(\"counter_currency\") || !value[\"counter_currency\"].IsString() || !value.HasMember(\"is_active\") || !value[\"is_active\"].IsBool()) {<fim-suffix>data.kind = value[\"kind\"].GetString(); data.settlement_currency = value[\"settlement_currency\"].GetString(); data.counter_currency = value[\"counter_currency\"].GetString(); data.is_active = value[\"is_active\"].GetBool(); \/\/ Optional fields - use safe accessors data.instrument_type =<fim-middle>return std::nullopt; } data.instrument_name = value[\"instrument_name\"].GetString();"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include \"InstrumentManager.h\"\n#include \"TimerController.h\"\n\nclass InstrumentEnricherPlugin : public tbricks::Strategy\n                               , public InstrumentManager::IHandler\n                               , public TimerController::IHandler\n\n{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n\n    void HandleImportComplete(const tbricks::String& status) final;\n    void HandleInstrumentManagerFailed(const tbricks::String& reason) final;\n    const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); }\n    const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() final { return m_underlyingInstrument.GetInstrumentIdentifier(); }\n    const tbricks::DateTime& GetMaturityDate() final { return m_maturityDate.GetDateTime(); }\n\n    void HandleTimerEventHit() final;\n    void HandleTimerControllerUpdate(const tbricks::String& update, bool error) final;\n\nprivate:\n    bool CheckRunningRequirement();\n    void HandleAction(const tbricks::Integer & action);\n    void Start();\n    void Stop();\n    void ImportNow();\n<fim-suffix><fim-middle>    tbricks::IntegerParameter                          m_instrument_enricherAppAction;\n    tbricks::DurationParameter                         m_importFrequency;\n    tbricks::InstrumentGroupParameter                  m_instrumentGroup;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel<fim-suffix><fim-middle>*> GetModel(const tbricks::InstrumentIdentifier & instrument);"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    if (not m_client)\n    {\n        m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_PROD);\n    }\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n<fim-suffix><fim-middle>    {\n        m_client->Disconnect();\n        return;\n    }"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t<fim-suffix>const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double<fim-middle>MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n<fim-suffix><fim-middle>    bool IsTest() const;"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\"\n#include \"tbricks_definitions.h\"\n#include <cstdlib>\n#include <set>\n\nusing namespace tbricks;\n\nExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request)\n: Pricing(request)\n{\n    srand (time(NULL)); \/\/ Initialize random seed.\n\n    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n    SnapshotDone();\n}\n\nvoid ExampleCalcAppPlugin2::HandlePricingModifyRequest(const PricingModifyRequest& request)\n{\n    RequestAndIVIDs IVIDs;\n    request.GetIVIDs(IVIDs);\n    Calculate(IVIDs, request.GetFullCalculatedValuesRequest());\n}\n\nvoid ExampleCalcAppPlugin2::Calculate(const RequestAndIVIDs & values, const CalculatedValuesRequestFull & request)\n{\n    m_rows = values;\n\n    for (const auto & civ_it : request.GetColumns())\n    {\n        if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2())\n        {\n            Double x;\n            StrategyParameters parameters;\n            civ_it.GetColumnInfo().GetParameters(parameters);\n            parameters.GetParameter(strategy_parameters::X(), x);\n            for (const auto & ivids_it : m_rows)\n            {\n                Calculate(ivids_it.first, civ_it.GetColumnId(), x);\n            }\n        }\n        else\n        {\n            TBERROR(\"System asked for calculation which the plugin does not support!\");\n        }\n    }\n    Send();\n}\n\nvoid ExampleCalcAppPlugin2::Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x)\n<fim-suffix><fim-middle>{\n    CalculatedValueIdentifier calc_id(rowId, columnId);\n    Double result;\n    if( x.Empty() )"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n<fim-suffix><fim-middle>    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\" #include \"PricingPlugin.h\" #include \"volatility\/CustomVolatilityModel.h\" #include \"shared\/volatility\/InterpolatedVolatilityModel.h\" #include <utility> using namespace tbricks; VolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin , const StreamSettingsPtr & stream_settings_ptr , const InstrumentGroupIdentifier & group , const DateTime & maturity_date) : m_plugin(plugin) , m_maturity_date(maturity_date) , m_group(group) , m_stream_settings_ptr(stream_settings_ptr) { PDUMPN(\"Create volatility curve handler\"); m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true); if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) { HandleVolatilityGroupParameters(); } } VolatilityCurveHandler::~VolatilityCurveHandler() { m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider); m_parameters_provider = nullptr; } bool VolatilityCurveHandler::IsSnapshotDone() const { if (!m_parameters_provider) return true; return m_parameters_provider->IsSnapshotDone(); } void VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber) { if (!subscriber) return; m_subscribers.push_back(subscriber); } void VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber) { auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber); if (found != m_subscribers.end()) { std::swap(*found, m_subscribers.back()); m_subscribers.pop_back(); } } bool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides) { if (!m_parameters_provider) return false; return m_parameters_provider->UpdateOverrides(overrides); } std::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source) { if (!m_volatility_model) return {}; if (source.Empty()) return m_volatility_model; auto & weak = m_volatility_models[source]; auto ret = weak.lock(); if (ret) return ret; ret.reset(m_volatility_model->Clone()); weak = ret; return ret; } std::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source) { if (!m_volatility_model) return {}; if (m_volatility_model->IsInterpolated()) return {}; if (source.Empty()) return m_volatility_model; auto & weak = m_volatility_models[source]; auto<fim-suffix>if (ret) return ret; ret.reset(m_volatility_model->Clone()); weak = ret; return ret; } bool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group , const InstrumentGroupAggregateParameters::Update & update) { return HandleVolatilityGroupParameters(&update); } void VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group) { PDEBUGN(\"Handle volatility group parameters snapshot done\"); for (auto subscriber : m_subscribers) { subscriber->HandleVolatilityCurveHandlerSnapshot(m_group); } } void VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType() { PDEBUGN(\"VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType\"); if (SwitchVolatilityModel()) { for (auto subscriber : m_subscribers) { subscriber->HandleVolatilityCurveHandlerUpdate(m_group); } } } bool VolatilityCurveHandler::HandleVolatilityGroupParameters(const InstrumentGroupAggregateParameters::Update * update) { PDEBUGN(\"Handle volatility group parameters\"); if (update) { PDUMPN(\"Update = \" << *update); } bool changed = false; changed |= SwitchVolatilityModel(); if (!changed && m_volatility_model) { if (update) { changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*update, *m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date); } else { changed |=<fim-middle>ret = weak.lock();"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) ,<fim-suffix>} void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const<fim-middle>m_startTimerEvent(*this) {"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider<fim-suffix>void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item)<fim-middle>void HandleSubscribe(tbricks::MarketDataItem & item) override;"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if<fim-suffix>\/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else<fim-middle>(m_startTime.Empty()) {"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n\nVolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)\n:\n      m_plugin(plugin)\n    , m_maturity_date(maturity_date)\n    , m_group(group)\n    , m_stream_settings_ptr(stream_settings_ptr)\n{\n    PDUMPN(\"Create volatility curve handler\");\n    m_parameters_provider = m_plugin.CreateVolatilityGroupSubscriber(*this, m_group, m_stream_settings_ptr, true);\n    if (m_parameters_provider && m_parameters_provider->IsSnapshotDone()) {\n        HandleVolatilityGroupParameters();\n    }\n}\n\nVolatilityCurveHandler::~VolatilityCurveHandler()\n{\n    m_plugin.RemoveVolatilityGroupSubscriber(*this, m_parameters_provider);\n    m_parameters_provider = nullptr;\n}\n\nbool VolatilityCurveHandler::IsSnapshotDone() const\n{\n    if (!m_parameters_provider) return true;\n\n    return m_parameters_provider->IsSnapshotDone();\n}\n\nvoid VolatilityCurveHandler::AddSubscriber(ISubscriber * subscriber)\n{\n    if (!subscriber) return;\n\n    m_subscribers.push_back(subscriber);\n}\n\nvoid VolatilityCurveHandler::RemoveSubscriber(ISubscriber * subscriber)\n{\n    auto found = std::find(m_subscribers.begin(), m_subscribers.end(), subscriber);\n    if (found != m_subscribers.end()) {\n        std::swap(*found, m_subscribers.back());\n        m_subscribers.pop_back();\n    }\n}\n\nbool VolatilityCurveHandler::UpdateOverrides(const CalculatedValuesRequestFull::Overrides & overrides)\n{\n    if (!m_parameters_provider) return false;\n\n    return m_parameters_provider->UpdateOverrides(overrides);\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nstd::shared_ptr<volatility::IVolatilityModel> VolatilityCurveHandler::GetNoninterpolatedVolatilityModel(const Uuid & source)\n{\n    if (!m_volatility_model) return {};\n    if (m_volatility_model->IsInterpolated()) return {};\n    if (source.Empty()) return m_volatility_model;\n\n    auto & weak = m_volatility_models[source];\n    auto ret = weak.lock();\n    if (ret) return ret;\n\n    ret.reset(m_volatility_model->Clone());\n\n    weak = ret;\n    return ret;\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParametersUpdate(const InstrumentGroupIdentifier & group\n    , const InstrumentGroupAggregateParameters::Update & update)\n{\n    return HandleVolatilityGroupParameters(&update);\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupParametersSnapshotDone(const InstrumentGroupIdentifier & group)\n{\n    PDEBUGN(\"Handle volatility group parameters snapshot done\");\n    for (auto subscriber : m_subscribers) {\n        subscriber->HandleVolatilityCurveHandlerSnapshot(m_group);\n    }\n}\n\nvoid VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType()\n{\n    PDEBUGN(\"VolatilityCurveHandler::HandleVolatilityGroupOverriddenModelType\");\n    if (SwitchVolatilityModel()) {\n        for (auto subscriber : m_subscribers) {\n            subscriber->HandleVolatilityCurveHandlerUpdate(m_group);\n        }\n    }\n}\n\nbool VolatilityCurveHandler::HandleVolatilityGroupParameters(const InstrumentGroupAggregateParameters::Update * update)\n{\n    PDEBUGN(\"Handle volatility group parameters\");\n    if (update) {\n        PDUMPN(\"Update = \" << *update);\n    }\n\n    bool changed = false;\n\n    changed |= SwitchVolatilityModel();\n<fim-suffix><fim-middle>    if (!changed && m_volatility_model) {\n        if (update) {\n            changed |= m_volatility_model->UpdateVolatilitySurfaceParameters(*update, *m_parameters_provider->GetVolatilitySurfaceContainer(), m_maturity_date);\n        } else {"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n\nclass InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::CalculatedInstrumentValues::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n        virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0;\n        virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0;\n        virtual const tbricks::DateTime& GetMaturityDate() = 0;\n        virtual void HandleImportComplete(const tbricks::String& status) = 0;\n        virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;\n    };\n\n    InstrumentManager(IHandler& handler, tbricks::visualization::Grid& instrumentsGrid);\n    ~InstrumentManager() noexcept override;\n    void Start();\n    void Stop();\n\nprotected:\n    void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamStale(const tbricks::StreamIdentifier& stream) final;\n    void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final;\n    void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final;\n\n    void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final;\n    void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {};\n\n    void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID,\n                                             const tbricks::InstrumentIdentifier & instrumentID,\n                                             const tbricks::InstrumentAggregateParameters::Update & update) override;\n<fim-suffix><fim-middle>    void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId,\n                                                  const tbricks::CalculatedInstrumentValues::Update & update) final;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n    \n    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);\n    \n    if (read > 0 && read < m_buffer.GetSize())\n    {\n        Binary fragment(&static_cast<char *>(m_buffer.GetData())[read], \n                       m_buffer.GetSize() - read);\n        m_buffer = fragment;\n    }\n    else if (read == m_buffer.GetSize())\n    {\n        m_buffer.Clear();\n    }\n}\n\nvoid TbWebsocketClient::HandleStreamOpen(TCPStream & stream)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    UpgradeWs();\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction()) , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency()) , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_startTime(instrument_enricher::strategy_parameters::StartTime()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_importOnce(false) , m_instrumentManager(*this) , m_timerController(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { ImportNow(); SetState(StrategyState::RUNNING); }<fim-suffix>{ TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier) { TBSTATUS(__func__ << \" : \" << modifier); const StrategyParameters& parameters = modifier.GetParameters(); GetParameters().Merge(parameters); MergeAttributes(modifier.GetAttributes()); if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction())) { Integer action; parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action); HandleAction(action); } if (parameters.GetParameter(m_startTime) or parameters.GetParameter(m_importFrequency)) { m_timerController.Update(parameters); } m_instrument_enricherAppAction.Clear(); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.GetItem(m_instrument_enricherAppAction).SetDirection(direction); auto &action_vi = context.GetItem(m_instrument_enricherAppAction); std::vector<Integer> allowed_actions; if (GetState().IsRunning()) { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer); } else { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer); allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow); } action_vi.SetValidValues(allowed_actions); action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT); if (not GetState().IsRunning()) { auto& freqValidationItem = context.GetItem(m_importFrequency); Duration frequency; freqValidationItem.GetValue(frequency); if (not frequency.Empty() and frequency < Duration::Seconds(1)) { freqValidationItem.SetValue(Duration::Seconds(1)); m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\"; } freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT); } context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } return true; } void InstrumentEnricherPlugin::HandleAction(const Integer & action) { TBDEBUG(__func__ << \" : \" << action); if(TB_UNLIKELY(action.Empty())) { TBDEBUG(\"Action is empty, skipping\"); } switch (action.GetInt()) { case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer: Start(); break; case<fim-middle>} void InstrumentEnricherPlugin::HandlePauseRequest()"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\" #include \"shared\/order_minion\/OrderMinionCancelRequest.h\" #include \"shared\/order_minion\/tbricks_definitions.h\" #include \"shared\/sdk_definitions.h\" using namespace tbricks; namespace execution { TbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const<fim-suffix>: OrderExecutor(handler) , m_controller( reason, app) { TBDEBUG(__func__); } TbOrderMinion::~TbOrderMinion() { TBDEBUG(__func__); DeleteOrders(); } void TbOrderMinion::CreateOrder( const InstrumentVenueIdentification& ivid, const Volume& volume, \/\/ negative for sell const PortfolioIdentifier& portfolio) { TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio); OrderMinionRequest req(this); req.SetExecution(enumerations::OrderMinionExecutionHitRepeatedly); req.SetIVID(ivid); req.SetMarketDataIVID(ivid); req.SetPortfolio(portfolio); req.SetSide((volume > 0.0 ? Side::BUY : Side::SELL)); req.SetVolume(volume.Abs()); req.SetPriceMode(enumerations::OrderMinionPrice::OrderMinionPriceBestPossible); auto result = m_controller.Request(req); if (result == OrderMinionController::FAILURE) { m_handler.PanicStop(result.GetError()); return; } m_requests[ivid] = req; } void TbOrderMinion::DeleteOrders() { TBDEBUG(__func__); m_controller.Stop(); } void TbOrderMinion::MonitorInstrument(const InstrumentVenueIdentification &ivid) { m_controller.Prepare(ivid); } void TbOrderMinion::HandleOrderMinionUpdate( const OrderMinionUpdate& update ) {<fim-middle>InitializationReason & reason, const StrategyParameters & parameters)"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n<fim-suffix><fim-middle>{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if<fim-suffix><fim-middle>(size <= 0)"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n<fim-suffix><fim-middle>DeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler & handler)\n    : m_instrumentStream(*this)\n    , m_handler(handler)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Clear()\n{\n    m_tbricksInstruments.clear();\n    m_deribitInstruments.clear();\n    m_pendingCreates.clear();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n<fim-suffix><fim-middle>    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByVenueFilter(m_handler.GetVenueIdentifier()) && InstrumentStream::Filters::DeletedFilter(\/*deleted=*\/false));\n    m_instrumentStream.Open(Stream::SNAPSHOT_AND_LIVE, options);"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else { m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \" + m_frequency.ToString(); }<fim-suffix>void<fim-middle>m_handler.HandleTimerControllerUpdate(status, \/*error =*\/ false); }"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction()) , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency()) , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_startTime(instrument_enricher::strategy_parameters::StartTime()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_importOnce(false) , m_instrumentManager(*this) , m_timerController(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { ImportNow(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier) { TBSTATUS(__func__ << \" : \" << modifier); const StrategyParameters& parameters = modifier.GetParameters(); GetParameters().Merge(parameters); MergeAttributes(modifier.GetAttributes()); if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction())) { Integer action; parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action); HandleAction(action); } if (parameters.GetParameter(m_startTime) or parameters.GetParameter(m_importFrequency)) { m_timerController.Update(parameters); } m_instrument_enricherAppAction.Clear(); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context) { TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.GetItem(m_instrument_enricherAppAction).SetDirection(direction); auto &action_vi = context.GetItem(m_instrument_enricherAppAction); std::vector<Integer> allowed_actions; if (GetState().IsRunning()) { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer); } else { allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer); allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow); } action_vi.SetValidValues(allowed_actions); action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT); if (not GetState().IsRunning()) { auto& freqValidationItem = context.GetItem(m_importFrequency); Duration frequency; freqValidationItem.GetValue(frequency); if (not frequency.Empty() and frequency < Duration::Seconds(1)) { freqValidationItem.SetValue(Duration::Seconds(1)); m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\"; } freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT); } context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } return true; } void InstrumentEnricherPlugin::HandleAction(const Integer & action) { TBDEBUG(__func__ << \" : \" << action); if(TB_UNLIKELY(action.Empty())) { TBDEBUG(\"Action is empty, skipping\"); } switch (action.GetInt()) { case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer: Start(); break; case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer: Stop(); break; case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow: m_importOnce = true; ImportNow(); break; default: TBDEBUG(\"Unknown action\");<fim-suffix>} } void InstrumentEnricherPlugin::Start() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_timerController.Start(); } SetState(StrategyState::RUNNING); } void InstrumentEnricherPlugin::Stop() { TBDEBUG(__func__); if (m_timerController.IsActive()) { m_timerController.Stop(); } m_instrumentManager.Stop(); m_importOnce = false; if (GetState().IsPaused()) { TBDEBUG(\"Already stopped\"); return; } Strategy::SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::ImportNow() { TBDEBUG(__func__); m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); } void InstrumentEnricherPlugin::HandleImportComplete(const String& status) { TBDEBUG(__func__ << \" : \" << status); m_plugInStatusDescription = status + \" at \" + DateTime::Now().ToString(); if (m_importOnce) { Stop(); } } void InstrumentEnricherPlugin::HandleInstrumentManagerFailed(const String& reason) { TBWARNING(__func__ << \" : Instrument manager failed with reason = \" << reason); HandlePauseRequest(); } void InstrumentEnricherPlugin::HandleTimerEventHit() { TBDEBUG(__func__); if<fim-middle>break;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n<fim-suffix><fim-middle>    GetParameters().Merge(parameters);"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n<fim-suffix><fim-middle>    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n<fim-suffix><fim-middle>void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n\n    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());\n        HandleRunRequest();\n    }\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    if (not m_client)\n    {\n        m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_PROD);\n    }\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    else\n    {\n        SetState(StrategyState::PAUSED);\n    }\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n<fim-suffix><fim-middle>void DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/<fim-suffix>void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/<fim-middle>Strategy methods     void HandleDeleteRequest() final;"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/type\/Price.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/Boolean.h> #include <strategy\/calculated_property\/CalculatedPropertyFilter.h> #include <strategy\/TreeNodeParameters.h> #include <strategy\/parameter\/StrategyParameters.h> #include <strategy\/parameter\/StrategyInstanceParameters.h> CLANG_RESTORE_WARNINGS #include <set> using namespace tbricks; enum class PreferencesStorageKind { Common = 0, Wing, CCS, SVI }; std::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind); \/** * Struct representing the various settings common to all VMs; it is subclassed by structs * containing additional parameters relevant for particular VMs *\/ class PreferencesStorage: public Printable { public: PreferencesStorage(); protected: PreferencesStorage(const PreferencesStorage & storage) = default; PreferencesStorage & operator=(const PreferencesStorage & storage) = default; public: virtual ~PreferencesStorage(); virtual PreferencesStorageKind GetKind() const = 0; virtual void Clear(); virtual void Copy(const PreferencesStorage<fim-suffix><fim-middle>& preferencesStorage);"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false;<fim-suffix><fim-middle>bool logged_in = false;"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing) VOLATILITY(custom, Custom) VOLATILITY(my_custom,<fim-suffix><fim-middle>MyCustom)"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status<fim-suffix>\/\/ MDTracker::IHandler void HandleBBOUpdate( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::BestPrice& before, const tbricks::BestPrice& change ) override; void HandleSnapshotEnd(const tbricks::InstrumentVenueIdentification& ivid) override; private: void EmergencyStop(); void DeleteSingleOrder(const tbricks::OrderIdentifier& id); void CreateSingleOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, const tbricks::Price& price, const tbricks::Side& side, const tbricks::PortfolioIdentifier& portfolio); tbricks::Price RoundPriceToTicks(const tbricks::Price& price, const tbricks::Side& side, const tbricks::InstrumentVenueIdentification& ivid); void UpdateStats(const tbricks::Order::Update& update, const<fim-middle>status, const tbricks::String& status_text) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument); \/\/ app<fim-suffix>tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint; std::unique_ptr<DeribitClient> m_client;<fim-middle>parameters tbricks::StringParameter m_clientID;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n<fim-suffix><fim-middle>    m_buffer << data;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n<fim-suffix><fim-middle>    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val, size);<fim-suffix><fim-middle>return ostm;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n\nclass DeribitModel\n{\n\npublic:\n    DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler);\n    ~DeribitModel() noexcept = default;\n\n    void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update);\n\n    const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); }\n<fim-suffix><fim-middle>    bool IsSnapshotDone() const { return m_snapshotDone; }"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem<fim-suffix><fim-middle>& item)"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    PUBLIC_Subscribe,\n    PUBLIC_Unsubscribe,\n    PRIVATE_Subscribe,\n    PRIVATE_Unsubscribe,\n    SUBSCRIPTION,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::PUBLIC_Subscribe:\n        return \"public\/subscribe\";\n    case DeribitMethod::PUBLIC_Unsubscribe:\n        return \"public\/unsubscribe\";\n    case DeribitMethod::PRIVATE_Subscribe:\n        return \"private\/subscribe\";\n    case DeribitMethod::PRIVATE_Unsubscribe:\n        return \"private\/unsubscribe\";\n    case DeribitMethod::SUBSCRIPTION:\n        return \"subscription\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitSubscription\n{\n    NONE,\n    SUB_Ticker\n};\n\nstatic std::string Resolve(DeribitSubscription e)\n{\n    switch (e)\n    {\n    case DeribitSubscription::SUB_Ticker:\n        return \"ticker\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitInterval\n{\n    NONE,\n    SUB_100,\n    SUB_RAW\n};\n\nstatic std::string Resolve(DeribitInterval e)\n{\n    switch (e)\n    {\n    case DeribitInterval::SUB_100:\n        return \"100ms\";\n    case DeribitInterval::SUB_RAW:\n        return \"raw\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitCurrency\n{\n    BTC,\n    ETH,\n    USDT\n};\n\nstatic std::string Resolve(DeribitCurrency e)\n{\n    switch (e)\n    {\n    case DeribitCurrency::BTC:\n        return \"BTC\";\n    case DeribitCurrency::ETH:\n        return \"ETH\";\n    case DeribitCurrency::USDT:\n        return \"USDT\";\n    default:\n        return {};\n    }\n}\n\nenum class DeribitKind\n{\n    FUTURE,\n    OPTION,\n    ALL\n};\n\nstatic std::string Resolve(DeribitKind e)\n{\n    switch (e)\n    {\n    case DeribitKind::ALL:\n        return \"*\";\n    case DeribitKind::FUTURE:\n        return \"future\";\n    case DeribitKind::OPTION:\n        return \"option\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\n\ntypedef std::pair<DeribitMethod, std::string> Method;\n\nstatic std::vector<Method> GetAvailableMethods()\n{\n    return {\n            {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)},\n            {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)},\n            {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)},\n            {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)},\n            {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)},\n            {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)},\n            {DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)},\n            {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)},\n<fim-suffix><fim-middle>            {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}};\n}"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(\"HandleRunRequest\"); SetState(StrategyState::RUNNING); } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(\"HandlePauseRequest\"); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(\"HandleDeleteRequest\"); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(\"Modify request: \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters());<fim-suffix><fim-middle>MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename T> void write(const T & t) { tbricks::Binary vec; vec.Set(reinterpret_cast<const void *>(&t), sizeof(T)); write(vec); } void write(const std::string & s) { write(s.c_str(), s.size()); } void write(const char * p, size_t size) { m_data.Append(p, size); } private: tbricks::Binary m_data; }; template <typename T> Binary_istream & operator>>(Binary_istream & istm, T & val) { istm.read(val); return<fim-suffix>Binary_ostream & operator<<(Binary_ostream &<fim-middle>istm; } template <typename T>"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n<fim-suffix><fim-middle>    SubscribeForAppConfigurationRootNode();\n}"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public<fim-suffix>, public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final;<fim-middle>tbricks::Strategy , public InstrumentManager::IHandler"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor :<fim-suffix>{ public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy,<fim-middle>public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n<fim-suffix><fim-middle>const PreferencesStorage * PersistentPreferencesManagerCore::FindPreferencesStorageByScopeDefinition(const ScopeDefinition & scope) const\n{\n    switch (scope.type)\n    {"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val);<fim-suffix>}; class public_set_heartbeat : public JsonCall { public: public_set_heartbeat(const std::string_view id); void SetInterval(int seconds); }; class public_test : public JsonCall { public: public_test(const std::string_view id); }; class heartbeat : public JsonReply { public: heartbeat(JsonReply && base); std::string_view GetType() const; bool IsTestRequest() const; private: std::string_view type; }; class subscriptions : public JsonCall { public:<fim-middle>void SetRefreshToken(const std::string_view val);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public<fim-suffix><fim-middle>tbricks::IDistributionApp, public DeribitClient::IHandler {"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto<fim-suffix>m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__<fim-middle>* model = *model_opt;"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindPreferencesStorageByScopeDefinition(const ScopeDefinition & scope) const\n{\n    switch (scope.type)\n    {\n    case enumerations::VolatilityManagerPersistentPreferencesScopeUser:\n        return (scope.id == m_provider.GetUserIdentifier().GetUuid()) ? m_pUserScopePreferencesStorage.get() : nullptr;\n    case enumerations::VolatilityManagerPersistentPreferencesScopeProduct:\n        return FindProductScopePreferencesStorage(scope.id);\n    case enumerations::VolatilityManagerPersistentPreferencesScopeMaturity:\n        return FindMaturityScopePreferencesStorage(scope.id);\n    default:\n        return nullptr;\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductGroupIdsWithExistingPersistentPreferences(SparseSet<InstrumentGroupIdentifier> & productGroupIds) const\n{\n    productGroupIds.clear();\n    productGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & pair: m_productScopePreferencesStorages) {\n        TB_UNUSED(productGroupIds.insert(pair.first));\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductAndMaturityGroupIdsWithExistingPersistentPreferences(SparseHash<InstrumentGroupIdentifier, SparseSet<InstrumentGroupIdentifier>> & productAndMaturityGroupIds) const\n{\n    productAndMaturityGroupIds.clear();\n    productAndMaturityGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & [productGroupId, _]: m_productScopePreferencesStorages) {\n        TB_UNUSED(productAndMaturityGroupIds[productGroupId]);\n    }\n\n    for(const auto & pair: m_maturityScopePreferencesStoragesByProductGroupId) {\n        const InstrumentGroupIdentifier & productGroupId = pair.first;\n        SparseSet<InstrumentGroupIdentifier> & maturityGroupIds = productAndMaturityGroupIds[productGroupId];\n        maturityGroupIds.insert(pair.second.first);\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetMaturityGroupIdsWithExistingPersistentPreferences(const InstrumentGroupIdentifier & productGroupId,\n                                                                                            SparseSet<InstrumentGroupIdentifier> & maturityGroupIds) const\n{\n    if (TB_UNLIKELY(productGroupId.Empty())) {\n        return;\n    }\n\n    const auto [maturitiesBeginIt, maturitiesEndIt] = m_maturityScopePreferencesStoragesByProductGroupId.equal_range(productGroupId);\n    for (auto it = maturitiesBeginIt; it != maturitiesEndIt; it++) {\n        maturityGroupIds.insert(it->second.first);\n    }\n}\n\nbool PersistentPreferencesManagerCore::GetAggregatePreferencesForProductScope(const InstrumentGroupIdentifier & productGroupId,\n                                                                              PreferencesStorage & preferencesStorage) const\n{\n    TBDEBUG(\"PersistentPreferencesManagerCore::GetAggregatePreferencesForProductScope: product group id = \" << productGroupId);\n\n    preferencesStorage.Clear();\n\n    if (m_provider.IsPreferencesPersistenceDisabled())\n    {\n        if (TB_UNLIKELY(!m_pNonPersistentUserScopePreferences)) {\n            NOTIFY_WARNING(\"persistence of preferences is disabled but non-persistent in-memory storage is not allocated\");\n            return false;\n        }\n\n        preferencesStorage.Copy(*m_pNonPersistentUserScopePreferences);\n        return true;\n    }\n\n    preferencesStorage.Copy(*m_pUserScopePreferencesStorage);\n<fim-suffix><fim-middle>    const Integer & currentPreferencesScope = m_provider.GetCurrentPreferencesScope();\n    if (!currentPreferencesScope.Empty() && (currentPreferencesScope.GetInt32() == enumerations::VolatilityManagerPersistentPreferencesScopeUser)) {\n        TBDEBUG(\"Ignoring the actual product scope preferences because preferences scope is set to user\");\n        return true;"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing) VOLATILITY(custom,<fim-suffix><fim-middle>Custom)"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionRetriever : public tbricks::PositionStream::IHandler { public: class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId); void Stop(); \/\/ Common Stream methods void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final; void HandleStreamStale(const tbricks::StreamIdentifier &stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier &stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier &stream)<fim-suffix>*\/ void HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) final; void HandlePositionInvalidate( const tbricks::StreamIdentifier & stream_id, const tbricks::Identifier & id) final; private: IHandler& m_callback; tbricks::PositionStream<fim-middle>final; \/**      * PositionStream::IHandler"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); }<fim-suffix>{ TBDEBUG(__func__ << \" : \" << context); auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); } bool InstrumentEnricherPlugin::CheckRunningRequirement() { TBDEBUG(__func__); if (m_instrumentGroup.Empty()) { m_plugInStatusDescription = \"Instrument group is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_maturityDate.Empty()) { m_plugInStatusDescription = \"Maturity date is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } if (m_underlyingInstrument.Empty()) { m_plugInStatusDescription = \"Underlying instrument is empty\"; TBWARNING(m_plugInStatusDescription.GetString()); return false; } Strategy::SetState(StrategyState::RUNNING); return true; } void InstrumentEnricherPlugin::HandleInstrumentManagerFailed(const String& reason) {<fim-middle>void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context)"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument); private: std::map<tbricks::StreamIdentifier, tbricks::InstrumentIdentifier> m_streams;<fim-middle>"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else<fim-suffix>\/\/ start with just the frequency<fim-middle>if (m_startTime.Empty()) {"}
{"content":"<fim-prefix>#include \"PositionReversalsPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; PositionReversalsPlugin::PositionReversalsPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_manager(*this) , m_portfolio(position_reversals::strategy_parameters::Portfolio()) , m_startTime(position_reversals::strategy_parameters::PositionReversalStartTime()) , m_priceSource(position_reversals::strategy_parameters::PositionReversalPriceSource()) , m_status(position_reversals::strategy_parameters::StatusInformationText()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always start in paused mode SetState(StrategyState::PAUSED); if (GetTransactionOperation().IsRun()) { DoRun(); } } bool PositionReversalsPlugin::CanRun(tbricks::String& error) { TBDEBUG(__func__); if (m_portfolio.GetPortfolioIdentifier().Empty()) { error = \"No portfolio selected\"; return false; } if (m_startTime.GetTime().Empty()) { error = \"No start time selected\"; return false; } if (m_priceSource.GetInteger().Empty()) { error = \"No price source selected\"; return false; } return true; } void PositionReversalsPlugin::DoRun() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); String error; if (CanRun(error)) { m_manager.Start(m_portfolio.GetPortfolioIdentifier(), m_priceSource.GetInteger(), m_startTime.GetTime()); SetState(StrategyState::RUNNING); } else { m_status = error; SetTransactionFail(error); } } void PositionReversalsPlugin::DoPause() { m_manager.Stop(); SetState(StrategyState::PAUSED); } void PositionReversalsPlugin::HandleRunRequest(void) { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); } else { DoRun(); } } void PositionReversalsPlugin::HandlePauseRequest(void) { TBDEBUG(__func__); if (GetState().IsPaused()) { TBDEBUG(\"Already paused\"); } else { DoPause(); } } void PositionReversalsPlugin::HandleDeleteRequest(void) { TBDEBUG(__func__); DoPause(); SetState(StrategyState::DELETED); } void PositionReversalsPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" modifier: \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void PositionReversalsPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" constext:\" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void PositionReversalsPlugin::HandleStrategyViewCreate( visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \", update: \" << update); viewModel.MergeUpdate(update); viewModel.ApplyModifications(); } void PositionReversalsPlugin::HandleStrategyViewUpdate( visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \", update: \" << update); m_status = \"\"; viewModel.MergeUpdate(update); viewModel.ApplyModifications(); } void<fim-suffix>TBDEBUG(__func__); } void PositionReversalsPlugin::HandleGridViewUpdate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update) { TBDEBUG(__func__ << \" update = \" << update); viewModel.MergeUpdate(update); viewModel.ApplyModifications(); viewModel.RejectUnconfirmedModifications(); } void PositionReversalsPlugin::HandleGridViewDelete(visualization::models::GridViewModel& viewModel) { TBDEBUG(__func__); } void PositionReversalsPlugin::HandleGridViewCreate(visualization::models::GridViewModel& viewModel,<fim-middle>PositionReversalsPlugin::HandleStrategyViewDelete(visualization::models::AppViewModel& viewModel) {"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <><fim-suffix>{ out =<fim-middle>void Binary_istream::read(tbricks::Binary & out)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker,<fim-suffix><fim-middle>const std::string_view & json) override;"}
{"content":"<fim-prefix>#pragma once<fim-suffix>#include <strategy\/VisualizationApp.h> #include <strategy\/visualization\/ViewModelUpdate.h> #include <strategy\/visualization\/ICellValue.h> #include <strategy\/visualization\/Grid.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::VisualizationApp , public InstrumentManager::IHandler , public TimerController::IHandler<fim-middle>#include <shared\/API.h>"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType) { return SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType)); } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs; #undef VOLATILITY_MODEL_WRAP } } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilitySurfaceParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs; #undef<fim-suffix><fim-middle>VOLATILITY_MODEL_WRAP } }"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n\nclass Binary_ostream\n{\npublic:\n    Binary_ostream() { }\n    void close()\n    {\n        m_data.Clear();\n    }\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n    template <typename T>\n    void write(const T & t)\n    {\n        tbricks::Binary vec;\n        vec.Set(reinterpret_cast<const void *>(&t), sizeof(T));\n        write(vec);\n    }\n    void write(const std::string & s)\n    {\n        write(s.c_str(), s.size());\n    }\n    void write(const char * p, size_t size)\n    {\n        m_data.Append(p, size);\n    }\n\nprivate:\n    tbricks::Binary m_data;\n};\n\ntemplate <typename T>\nBinary_istream & operator>>(Binary_istream & istm, T & val)\n{\n    istm.read(val);\n\n    return istm;\n}\n<fim-suffix><fim-middle>template <typename T>\nBinary_ostream & operator<<(Binary_ostream & ostm, const T & val)\n{\n    ostm.write(val);"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item);<fim-suffix>{ TBDEBUG(__func__<fim-middle>} bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)"}
{"content":"<fim-prefix>#include \"..\/..\/my_custom_pricing\/tbricks_definitions.h\" constexpr<fim-suffix>#endif \/\/ TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H<fim-middle>VolatilityModel VolatilityModelMyCustom = VolatilityModel(custom::pricing::extended_enums::VolatilityModelMyCustom);"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n<fim-suffix><fim-middle>#define BUFFER_MIN_SIZE 4"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/String.h> #include <strategy\/type\/Volume.h> namespace execution { struct Stats { tbricks::Volume bought; tbricks::Volume sold; tbricks::Double valueBought; tbricks::Double valueSold; }; enum class OrderExecutorType { ORDER_MANAGER, CHILD_ORDER, ORDER_MINION }; class IExecutionHandler { public: ~IExecutionHandler() = default; virtual void<fim-suffix>virtual void PanicStop(const tbricks::String& msg) = 0; }; } \/\/<fim-middle>AllDone(const Stats& stats) = 0;"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" #define MAX_INSTRUMENTS 10 using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) {<fim-suffix>m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return (m_models.size() < MAX_INSTRUMENTS); } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \" << stream); auto model_opt = GetModel(stream); if (model_opt) { auto * model = *model_opt; model->Reset(); } else { TBDEBUG(\"Unknown stream\"); } } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBWARNING(__func__ << \": \"<fim-middle>auto * model = *model_opt;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n<fim-suffix><fim-middle>bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS)<fim-suffix><fim-middle>VOLATILITY(svi, SVI) VOLATILITY(wing, Wing)"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility,<fim-suffix>GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) NAMESPACE_PATH_GREEK(param_1, Double, Param1, custom::pricing::calculated_values) NAMESPACE_PATH_GREEK(param_2, Double, Param2, custom::pricing::calculated_values) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate) HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight) HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight) HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price, Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed) VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double, NextDividend) VALUE(next_dividend_date, Date, NextDividendDate) VALUE(underlying_settlement_date, Date, UnderlyingSettlementDateUsed) VALUE(final_settlement_date,<fim-middle>Double, ImplicitATM_Volatility)"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const<fim-suffix>const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double<fim-middle>double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5;"}
{"content":"<fim-prefix>#include \"ReversalManager.h\" #include<fim-suffix>#include <map> using namespace tbricks; ReversalManager::ReversalManager(IHandler& callback) : m_callback(callback) , m_scheduledTimer(*this) , m_positionRetriever(*this)<fim-middle>\"tbricks_definitions.h\""}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call;<fim-suffix>friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual<fim-middle>std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler {<fim-suffix><fim-middle>public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();"}
{"content":"<fim-prefix>#pragma once\n\n#include \"shared\/API.h\"\n#include \"ReversalManager.h\"\n\nclass PositionReversalsPlugin  : public tbricks::VisualizationApp\n                            , public ReversalManager::IHandler\n{\npublic:\n    PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n    ~PositionReversalsPlugin() = default;\n\n    bool CanRun(tbricks::String& error);\n    void DoRun();\n    void DoPause();\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n\n    void HandleStrategyViewCreate(\n            tbricks::visualization::models::AppViewModel& viewModel,\n            const tbricks::visualization::ViewModelUpdate& update) final;\n    void HandleStrategyViewUpdate(\n            tbricks::visualization::models::AppViewModel& viewModel,\n            const tbricks::visualization::ViewModelUpdate& update) final;\n    void HandleStrategyViewDelete(\n            tbricks::visualization::models::AppViewModel& viewModel) final;\n    void HandleGridViewCreate(\n            tbricks::visualization::models::GridViewModel& viewModel,\n            const tbricks::visualization::ViewModelUpdate& update) final;\n    void HandleGridViewUpdate(\n            tbricks::visualization::models::GridViewModel& viewModel,\n            const tbricks::visualization::ViewModelUpdate& update) final;\n    void HandleGridViewDelete(tbricks::visualization::models::GridViewModel& viewModel) final;\n\n    void HandleError(const tbricks::String& error) final;\n    void HandlePositionsReversed() final;\n\nprivate:\n<fim-suffix><fim-middle>    ReversalManager m_manager;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default;<fim-suffix><fim-middle>virtual void HandleTimerEventHit() = 0;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; };<fim-suffix>{ public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header<fim-middle>class TbWebsocketClient : public tbricks::TCPStream::IHandler"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); }<fim-suffix>{ String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value);<fim-middle>m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats)"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n    \n<fim-suffix><fim-middle>    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String<fim-suffix>std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double<fim-middle>& str);"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker;<fim-suffix><fim-middle>DeribitSubscription subscription = DeribitSubscription::NONE;"}
{"content":"<fim-prefix>#include \"PositionReversalsPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nPositionReversalsPlugin::PositionReversalsPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_manager(*this)\n    , m_portfolio(position_reversals::strategy_parameters::Portfolio())\n    , m_startTime(position_reversals::strategy_parameters::PositionReversalStartTime())\n    , m_priceSource(position_reversals::strategy_parameters::PositionReversalPriceSource())\n    , m_status(position_reversals::strategy_parameters::StatusInformationText())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    if (GetTransactionOperation().IsRun())\n    {\n        DoRun();\n    }\n\n}\n\nbool PositionReversalsPlugin::CanRun(tbricks::String& error)\n{\n    TBDEBUG(__func__);\n\n    if (m_portfolio.GetPortfolioIdentifier().Empty())\n    {\n        error = \"No portfolio selected\";\n        return false;\n    }\n\n    if (m_startTime.GetTime().Empty())\n    {\n        error = \"No start time selected\";\n        return false;\n    }\n\n    if (m_priceSource.GetInteger().Empty())\n    {\n        error = \"No price source selected\";\n        return false;\n    }\n\n    return true;\n}\n\nvoid PositionReversalsPlugin::DoRun()\n{\n    TBDEBUG(__func__);\n\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n    String error;\n    if (CanRun(error))\n    {\n        m_manager.Start(m_portfolio.GetPortfolioIdentifier(),\n                        m_priceSource.GetInteger(),\n                        m_startTime.GetTime());\n\n        SetState(StrategyState::RUNNING);\n    }\n    else\n    {\n        m_status = error;\n        SetTransactionFail(error);\n    }\n}\n\nvoid PositionReversalsPlugin::DoPause()\n{\n    m_manager.Stop();\n    SetState(StrategyState::PAUSED);\n}\n\nvoid PositionReversalsPlugin::HandleRunRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n    }\n    else\n    {\n        DoRun();\n    }\n}\n\nvoid PositionReversalsPlugin::HandlePauseRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsPaused())\n    {\n        TBDEBUG(\"Already paused\");\n    }\n    else\n    {\n        DoPause();\n    }\n}\n\nvoid PositionReversalsPlugin::HandleDeleteRequest(void)\n{\n    TBDEBUG(__func__);\n    DoPause();\n    SetState(StrategyState::DELETED);\n}\n\nvoid PositionReversalsPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" modifier: \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid PositionReversalsPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" constext:\"  << context);\n\n    context.SendReply();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewCreate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewUpdate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n\n    m_status = \"\";\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewDelete(visualization::models::AppViewModel& viewModel)\n{\n    TBDEBUG(__func__);\n}\n\nvoid PositionReversalsPlugin::HandleGridViewUpdate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n    viewModel.RejectUnconfirmedModifications();\n}\n\nvoid PositionReversalsPlugin::HandleGridViewDelete(visualization::models::GridViewModel& viewModel)\n{\n    TBDEBUG(__func__);\n}\n\nvoid PositionReversalsPlugin::HandleGridViewCreate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n    HandleGridViewUpdate(viewModel, update);\n}\n\nvoid PositionReversalsPlugin::HandleError(const tbricks::String& error)\n{\n    m_status = error;\n}\n<fim-suffix><fim-middle>void PositionReversalsPlugin::HandlePositionsReversed()\n{\n    m_status = \"Position reversals done!\";\n}"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionRetriever : public tbricks::PositionStream::IHandler { public: class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId); void Stop(); \/\/ Common Stream methods void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final; void HandleStreamStale(const tbricks::StreamIdentifier &stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier &stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier &stream) final; \/** * PositionStream::IHandler *\/ void HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) final; void HandlePositionInvalidate( const tbricks::StreamIdentifier & stream_id, const tbricks::Identifier & id) final; private: IHandler& m_callback; tbricks::PositionStream m_positionStream; bool m_wasStreamStale{false}; std::map<tbricks::Identifier, tbricks::Position><fim-suffix>{ public: virtual void HandleError(const tbricks::String& error) = 0; virtual<fim-middle>m_positions; }; class PositionRetriever::IHandler"}
{"content":"<fim-prefix>VOLATILITY(ccs, CCS) VOLATILITY(svi, SVI) VOLATILITY(wing,<fim-suffix>VOLATILITY(my_custom, MyCustom)<fim-middle>Wing) VOLATILITY(custom, Custom)"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *><fim-suffix><fim-middle>GetModel(const tbricks::InstrumentIdentifier & instrument);"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t); void OnHeartbeat(deribit::JsonReply && incoming); void OnTestReply(SingleTransaction & t); void OnSubscribeReply(SingleTransaction & t); void OnSubscriptionUpdate(deribit::JsonReply && incoming); private: SingleTransaction & NewTransaction(const tbricks::Identifier & uuid = tbricks::Uuid::Create()); protected: void PerformTransaction(SingleTransaction & t); private: IHandler & m_handler; std::unique_ptr<TbWebsocketClient> m_ws; TbWebsocketClient::Config m_conf; Session m_session; tbricks::Timer m_timer; std::vector<deribit::Method> m_availableMethods =<fim-suffix><fim-middle>deribit::GetAvailableMethods();"}
{"content":"<fim-prefix>#include \"Values.h\"\n#include \"ValuesRequest.h\"\n\nvoid ImpliedValue::Clear()\n{\n    implied_volatility.Clear();\n}\n\nstd::ostream & ImpliedValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"] \" << implied_volatility;\n    return strm;\n}\n\nFairPriceValue & FairPriceValue::operator += (const FairPriceValue & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.fair_price.Empty()) {\n        fair_price += fair_price_value.fair_price;\n    } else if (fair_price_value.fair_price.HasError()) {\n        fair_price.SetError(fair_price_value.fair_price.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue & FairPriceValue::operator += (const Double & fair_price_value)\n{\n    if (!fair_price.Empty() && !fair_price_value.Empty()) {\n        fair_price += fair_price_value;\n    } else if (fair_price_value.HasError()) {\n        fair_price.SetError(fair_price_value.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nFairPriceValue FairPriceValue::operator * (const Double & mult) const\n{\n    FairPriceValue fair_price_value = *this;\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price_value.fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price_value.fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price_value.fair_price.Clear();\n    }\n    return fair_price_value;\n}\n\nFairPriceValue & FairPriceValue::operator *= (const Double & mult)\n{\n    if (!fair_price.Empty() && !mult.Empty()) {\n        fair_price *= mult;\n    } else if (mult.HasError()) {\n        fair_price.SetError(mult.GetError());\n    } else if (!fair_price.HasError()) {\n        fair_price.Clear();\n    }\n    return *this;\n}\n\nvoid FairPriceValue::Clear()\n{\n    fair_price.Clear();\n}\n\nbool FairPriceValue::SetError(const String & error)\n{\n    if (error == fair_price.GetError()) {\n        return false;\n    }\n\n    fair_price.SetError(error);\n    return true;\n}\n\nstd::ostream & FairPriceValue::Print(std::ostream & strm) const\n{\n    strm << \"[\" << version << \"]\" << fair_price;\n    return strm;\n}\n\nGreeks & Greeks::operator += (const Greeks & greeks)\n{\n#define TB_GREEKS_ADD(value) \\\n    if (!value.Empty() && !greeks.value.Empty()) { \\\n        value += greeks.value; \\\n<fim-suffix><fim-middle>    } else if (greeks.value.HasError()) { \\\n        value.SetError(greeks.value.GetError()); \\\n    } else if (!value.HasError()) { \\\n        value.Clear(); \\"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; typedef tbricks::String Ticker; typedef std::string Channel; struct<fim-suffix>{ Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t); void OnHeartbeat(deribit::JsonReply && incoming); void OnTestReply(SingleTransaction & t); void OnSubscribeReply(SingleTransaction & t); void OnSubscriptionUpdate(deribit::JsonReply && incoming); private: SingleTransaction & NewTransaction(const tbricks::Identifier<fim-middle>Subscription : public tbricks::Printable"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double<fim-suffix>double GetCurrentFunding(); double GetBid(); double GetAsk(); double GetBidVolume();<fim-middle>GetIndexPrice();"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const<fim-suffix><fim-middle>Error & GetError() const;"}
{"content":"<fim-prefix>#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include <strategy\/Logger.h>\n#include <strategy\/stream_filter\/PositionByPortfolioFilter.h>\n#include <strategy\/SparseSet.h>\n#include <sstream>\n#include <vector>\n\nusing namespace tbricks;\n\nnamespace cps = go_flat::calculated_properties::position;\n\nPositionsData::PositionsData(const PortfolioIdentifier& portfolioId, StringParameter& status)\n: m_appStatus(status)\n, m_stream(*this)\n{\n    TBDEBUG(__func__ << \" : \" << portfolioId);\n\n    CalculatedPropertiesTable::Stream::Options options;\n\n    options.SetFilter(portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, {});\n\n    options.AddProperty(cps::Instrument());\n    options.AddProperty(cps::Venue());\n    options.AddProperty(cps::MIC());\n    options.AddProperty(cps::NetPosition_LEFT_PARENTHESIS_Period_RIGHT_PARENTHESIS());\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n    TBDUMP(\"Stream opened with options: \" << options);\n}\n\nPositionsData::~PositionsData()\n{\n    TBDEBUG(__func__);\n    m_stream.Close();\n}\n\nvoid PositionsData::Stop()\n{\n    TBDEBUG(__func__);\n    m_stream.Close();\n}\n\nvoid PositionsData::HandleStreamOpen(const StreamIdentifier& stream)\n{\n    m_appStatus = \"Waiting for positions data\";\n}\n\nvoid PositionsData::HandleStreamStale(const StreamIdentifier& stream)\n{\n    m_appStatus = \"STALE STREAM for positions data\";\n}\n\nvoid PositionsData::HandleStreamFailed(const StreamIdentifier& stream)\n{\n    m_appStatus = \"FAILED STREAM for positions data\";\n}\n\nvoid PositionsData::HandleSnapshotEnd(const StreamIdentifier& stream)\n{\n    TBDEBUG(__func__ << \" : \" << stream);\n    RefreshStatusText();\n}\n<fim-suffix><fim-middle>void PositionsData::HandleCalculatedProperties(const StreamIdentifier & stream_id, const CalculatedPropertiesTable::Update & update)\n{\n    TBDEBUG(__func__ << \" : \" << update);\n    m_table.Merge(update);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update<fim-suffix>std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier<fim-middle>& update) override;"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindMaturityScopePreferencesStorage(const InstrumentGroupIdentifier & maturityGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n\n    auto it = m_maturityScopePreferencesStorages.find(maturityGroupId);\n    if (it == m_maturityScopePreferencesStorages.end()) {\n        return nullptr;\n    }\n\n    if (it->second.Empty()) {\n        return nullptr;\n    }\n\n    return &(*it->second);\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindPreferencesStorageByScopeDefinition(const ScopeDefinition & scope) const\n{\n    switch (scope.type)\n    {\n    case enumerations::VolatilityManagerPersistentPreferencesScopeUser:\n        return (scope.id == m_provider.GetUserIdentifier().GetUuid()) ? m_pUserScopePreferencesStorage.get() : nullptr;\n    case enumerations::VolatilityManagerPersistentPreferencesScopeProduct:\n        return FindProductScopePreferencesStorage(scope.id);\n    case enumerations::VolatilityManagerPersistentPreferencesScopeMaturity:\n        return FindMaturityScopePreferencesStorage(scope.id);\n    default:\n        return nullptr;\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductGroupIdsWithExistingPersistentPreferences(SparseSet<InstrumentGroupIdentifier> & productGroupIds) const\n{\n    productGroupIds.clear();\n    productGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & pair: m_productScopePreferencesStorages) {\n        TB_UNUSED(productGroupIds.insert(pair.first));\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetProductAndMaturityGroupIdsWithExistingPersistentPreferences(SparseHash<InstrumentGroupIdentifier, SparseSet<InstrumentGroupIdentifier>> & productAndMaturityGroupIds) const\n{\n    productAndMaturityGroupIds.clear();\n    productAndMaturityGroupIds.resize(m_productScopePreferencesStorages.size());\n    for(const auto & [productGroupId, _]: m_productScopePreferencesStorages) {\n        TB_UNUSED(productAndMaturityGroupIds[productGroupId]);\n    }\n\n    for(const auto & pair: m_maturityScopePreferencesStoragesByProductGroupId) {\n        const InstrumentGroupIdentifier & productGroupId = pair.first;\n        SparseSet<InstrumentGroupIdentifier> & maturityGroupIds = productAndMaturityGroupIds[productGroupId];\n        maturityGroupIds.insert(pair.second.first);\n    }\n}\n\nvoid PersistentPreferencesManagerCore::GetMaturityGroupIdsWithExistingPersistentPreferences(const InstrumentGroupIdentifier & productGroupId,\n                                                                                            SparseSet<InstrumentGroupIdentifier> & maturityGroupIds) const\n{\n    if (TB_UNLIKELY(productGroupId.Empty())) {\n        return;\n    }\n<fim-suffix><fim-middle>    const auto [maturitiesBeginIt, maturitiesEndIt] = m_maturityScopePreferencesStoragesByProductGroupId.equal_range(productGroupId);\n    for (auto it = maturitiesBeginIt; it != maturitiesEndIt; it++) {\n        maturityGroupIds.insert(it->second.first);\n    }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument); \/\/ app parameters tbricks::StringParameter m_clientID; tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint; std::unique_ptr<DeribitClient> m_client; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::DistributedValuesRequest> m_requestMap; tbricks::SparseHash<tbricks::Identifier,<fim-suffix><fim-middle>tbricks::DistributedValuesRequest> m_pendingRequests; tbricks::Set<tbricks::Identifier> m_supported_values;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \"<fim-suffix>return false; } void<fim-middle><< ivid);"}
{"content":"<fim-prefix>VOLATILITY(ccs,<fim-suffix>VOLATILITY(custom, Custom)<fim-middle>CCS) VOLATILITY(svi, SVI) VOLATILITY(wing, Wing)"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String userId; tbricks::String secret; tbricks::String host_port_path; bool connected = false; bool logged_in = false; int hb = 0; void SetExpires(int seconds); bool IsExpired() const; void Reset(); \/\/ Printable std::ostream & Print(std::ostream<fim-suffix>}; typedef tbricks::String Ticker; typedef std::string Channel; struct Subscription : public tbricks::Printable { Ticker ticker; DeribitSubscription subscription = DeribitSubscription::NONE; DeribitInterval interval = DeribitInterval::NONE; Channel channel; \/\/ should be always sorted \/\/ Printable std::ostream & Print(std::ostream & strm) const final; }; private: void OnLoginReply(SingleTransaction & t); void OnSetHeartbeatReply(SingleTransaction & t); void OnHeartbeat(deribit::JsonReply && incoming); void OnTestReply(SingleTransaction & t);<fim-middle>& strm) const final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer&<fim-suffix>void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive();<fim-middle>timer) override; void Update(const tbricks::StrategyParameters& strategyParameters);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return<fim-suffix>bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature<fim-middle>m_index; }"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n<fim-suffix><fim-middle>    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } }<fim-suffix><fim-middle>void TimerController::Update(const StrategyParameters& strategyParameters)"}
{"content":"<fim-prefix>#include \"shared\/API.h\"\n#include \"InstrumentPricing.h\"\n#include \"util\/Log.h\"\n#include \"PricingPlugin.h\"\n#include \"InstrumentFilterSubscriber.h\"\n#include \"Underlying.h\"\n#include \"payments\/DividendInstrument.h\"\n#include \"payments\/PaymentInstrument.h\"\n#include \"UnderlyingComponentsManager.h\"\n#include \"price_providers\/BarrierInstrument.h\"\n#include \"models\/ModelCalculatorFactory.h\"\n#include \"models\/TurboOptionModelCalculator.h\"\n#include \"models\/TurboOptionWithDividendsModelCalculator.h\"\n#include \"models\/MiniFutureModelCalculator.h\"\n#include \"models\/CallableBullBearContractModelCalculator.h\"\n#include \"models\/CBBCWithDividendsModelCalculator.h\"\n#include \"models\/CBBCBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/CBBCWithDividendsBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/BondModelCalculator.h\"\n#include \"models\/EquityReturnModelCalculator.h\"\n#include \"price_providers\/PriceProviderEmpty.h\"\n#include \"price_providers\/PriceProviderSingle.h\"\n#include \"price_providers\/PriceProviderQuote.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/interest_rate\/YieldCurveWrapper.h\"\n#include \"UserPreferencesSubscriber.h\"\n#include \"time\/TimeOptions.h\"\n#include \"time\/TimeValues.h\"\n#include \"time\/VolatilityTimeWeights.h\"\n#include \"time\/CalendarUtils.h\"\n#include <cmath>\n#include <algorithm>\n#include <type_traits>\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include \"shared\/combination\/ICombinationModel.h\"\n#include \"shared\/Macros.h\"\n#include <shared\/instrument_types\/InstrumentTypes.h>\n#include <shared\/metaprogramming\/Defer.hpp>\n\n#include \"util\/Tokens.h\"\n\n#include \"models\/EquityModelCalculator.h\"\n#include \"models\/ExternalModelCalculator.h\"\n#include \"models\/ExternalTaylorModelCalculator.h\"\n#include \"models\/ExternalModelDistributionCalculator.h\"\n\n#include \"models\/PricingCombinationModel.h\"\n#include \"models\/util\/MiscCalculations.h\"\n#include \"models\/util\/DividendsUtil.h\"\n\n#include \"shared\/datetime_helpers\/DateTimeHelpers.h\"\n#include \"shared\/smart_pointers\/IntrusiveWeakPointer.hpp\"\n\n#include <shared\/time\/TimeParser.h>\n#include <shared\/StateRestorer.hpp>\n\n#include \"tbricks_definitions.h\"\n#include \"shared\/pricing\/tbricks_constants.h\"\n\nusing namespace tbricks;\n\nstd::ostream & operator<<(std::ostream & os, const RelativeValuationTime val_time)\n{\n    using RVT = RelativeValuationTime;\n    switch (val_time) {\n    case RVT::NOW:                 return os << \"Now\";\n    case RVT::TODAY_CLOSE:         return os << \"Today close\";\n    case RVT::NEXT_OPEN:           return os << \"Next open\";\n    case RVT::NEXT_DAY:            return os << \"Next day\";\n    default:                       return os << \"Unrecognized valuation time\";\n    }\n}\n\nInstrumentPricing::InstrumentPricing(PricingPlugin & plugin, const InstrumentIdentification & id,\n                                     const InstrumentVenueIdentification & ivid,\n                                     std::shared_ptr<SnapshotToken> snapshot_token,\n                                     std::shared_ptr<ModificationToken> modification_token,\n                                     const LegSettingsPtr & leg_settings) :\n    m_id(id),\n    m_plugin(plugin),\n    m_ivid(new InstrumentVenueIdentification(ivid)),\n    m_leg_settings(leg_settings),\n    m_instrument(new Instrument()),\n    m_override_prices(new IPriceProvider::OverridePriceContainer()),\n    m_q(GetCalculationSettings().GetYield()),\n    m_today_values(new TimeValues()),\n    m_plugin_modify_version(plugin.GetPluginModifyVersion()),\n    m_snapshot_token(snapshot_token),\n    m_modification_token(modification_token)\n{\n    PDEBUGN(\"Create instrument pricing: \" << *m_ivid << \" row id = \" << GetRowIdentifier());\n\n    m_calculated_values_pool.reset(new CalculatedInstrumentValuesPool(plugin, *this));\n    PDEBUGN(\"Instrument size is \" << sizeof(*this) << \", pool size is \" << sizeof(*m_calculated_values_pool));\n\n    if (m_ivid->GetInstrumentIdentifier().Empty()) {\n        ResetSnapshotTokens();\n        m_snapshot_done = true;\n        return;\n    }\n\n    if (m_calculated_values_pool->GetValuesRequest().TimeGreeksIsActive()) {\n        m_today_close_values.reset(new TimeValues());\n        m_next_trading_open_values.reset(new TimeValues());\n        m_next_trading_day_values.reset(new TimeValues());\n    }\n\n    InitializeDefaultParameters();\n    InitializeCalculatedValues();\n\n    UpdateOverrides(m_plugin.GetFullCalculatedValuesRequest().GetOverrides());\n\n    UpdateExpirationTime();\n\n    RetainTimer();\n\n    InstrumentSubscriptionIdentification instrument_subscription_id(m_ivid->GetInstrumentIdentifier(),\n                                                                    GetStreamSettingsPtr()->GetParametersDateTime());\n    m_instrument_stream = m_plugin.GetStreamManager().SubscribeForInstrument(instrument_subscription_id, this);\n<fim-suffix><fim-middle>    InstrumentAggregateParameters::Stream::Options ip_options;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const<fim-suffix>void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void<fim-middle>tbricks::StrategyModifier &modifier) final;"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/stringbuffer.h> #include <third_party\/include\/rapidjson\/writer.h> #include <third_party\/include\/rapidjson\/pointer.h> namespace deribit { using namespace rapidjson; struct RapidDocument { Document msg; StringBuffer buffer; }; UpdateData::UpdateData() { m_doc = new RapidDocument(); } UpdateData::~UpdateData() { delete(m_doc); } std::string_view UpdateData::ToString() {<fim-suffix><fim-middle>m_doc->buffer.Clear(); Writer<StringBuffer> writer(m_doc->buffer);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive()<fim-suffix>const tbricks::DateTime& GetTimerLastFired() const { return m_timerLastFired; } private: IHandler& m_handler; tbricks::Timer m_startTimerEvent; tbricks::DateTime m_startTime; tbricks::Duration<fim-middle>{ return m_startTimerEvent.IsActive(); }"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_plugInStatusDescription.Clear();\n\n\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n\n    context.SendReply();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n<fim-suffix><fim-middle>    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to; return std::move(sstrm).str(); } public: BadPreferencesStorageCast(const PreferencesStorageKind from, const PreferencesStorageKind to) : Exception(PreferenceKindsToString(from, to)) {} }; template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage); template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage); #define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\ { \\ if (TB_UNLIKELY(!pPreferencesStorage)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY((pPreferencesStorage->GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\ throw BadPreferencesStorageCast(pPreferencesStorage->GetKind(), kind); \\ } \\ \\<fim-suffix><fim-middle>return reinterpret_cast<specifier type*>(pPreferencesStorage); \\"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <deribit\/DeribitInstrument.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0; virtual void HandleInstrumentManagerReady() = 0; virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0; virtual void HandleInstrumentError(const tbricks::String & error) = 0; }; explicit InstrumentManager(IHandler & handler); ~InstrumentManager() override; \/\/ Add instruments from Deribit void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Core functionality void Start(); void SyncInstruments(); void Clear(); bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); } protected: \/\/ Common stream callbacks void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const<fim-suffix>void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ Instrument::Stream callbacks void HandleInstrument(const tbricks::StreamIdentifier & stream, const tbricks::Instrument & instrument) override; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier &<fim-middle>tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#ifndef TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H #define TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H \/**<fim-suffix>* items like instrument parameters or calculated values that are<fim-middle>* This file is intended to introduce definitions of the customized metadata"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index; }; class Binary_ostream { public: Binary_ostream() { } void close() { m_data.Clear(); } const tbricks::Binary & GetBinary() { return m_data; } template <typename T> void write(const T & t) { tbricks::Binary vec; vec.Set(reinterpret_cast<const void *>(&t), sizeof(T)); write(vec); } void write(const std::string & s) { write(s.c_str(), s.size()); } void write(const char * p, size_t size) { m_data.Append(p, size); } private: tbricks::Binary m_data; }; template <typename T> Binary_istream & operator>>(Binary_istream & istm, T & val) { istm.read(val); return istm; } template <typename T> Binary_ostream & operator<<(Binary_ostream & ostm,<fim-suffix>{ ostm.write(val);<fim-middle>const T & val)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <deribit\/DeribitInstrument.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0; virtual void HandleInstrumentManagerReady() = 0; virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0; virtual void HandleInstrumentError(const tbricks::String & error) = 0; }; explicit InstrumentManager(IHandler & handler); ~InstrumentManager() override; \/\/ Add instruments from Deribit void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Core functionality void Start(); void SyncInstruments(); void Clear(); bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); } protected: \/\/ Common stream callbacks void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ Instrument::Stream callbacks void HandleInstrument(const tbricks::StreamIdentifier & stream, const tbricks::Instrument & instrument) override; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::InstrumentIdentifier & id) override; \/\/ IRequestReplyHandler callback void HandleRequestReply(const tbricks::Identifier & request_id, tbricks::Status status, const tbricks::String & status_text) override; private: \/\/ Helper functions void OpenInstrumentStream(); static tbricks::String GetInstrumentKey(const tbricks::Instrument & instrument); static tbricks::String GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument); void CreateInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); void ModifyInstrument(const tbricks::Instrument& instrument, const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Data storage std::map<tbricks::String, tbricks::Instrument> m_tbricksInstruments; std::map<tbricks::String, std::shared_ptr<DeribitInstrument>> m_deribitInstruments; \/\/ Stream tbricks::InstrumentStream m_instrumentStream; \/\/ Tracking create requests std::map<tbricks::Identifier, tbricks::String> m_pendingCreates; std::map<tbricks::Identifier, tbricks::String><fim-suffix>};<fim-middle>m_pendingModifications; IHandler & m_handler;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\" using namespace tbricks; InstrumentManager::InstrumentManager(IHandler& handler) : m_handler(handler) , m_instrumentStream(*this) , m_iapStream(*this) { TBDEBUG(__func__ << \" ctor\"); } InstrumentManager::~InstrumentManager() { TBDEBUG(__func__ << \" dtor\"); Stop(); } void InstrumentManager::Stop() { TBDEBUG(__func__); m_instrumentCache.clear(); m_underlyingCache.clear(); m_instrumentStream.Close(); } void InstrumentManager::Start() { TBDEBUG(__func__); Stop(); OpenInstrumentStream(); } void InstrumentManager::OpenInstrumentStream() { TBDEBUG(__func__); InstrumentStream::Options options; options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup())); m_instrumentStream.Open(Stream::SNAPSHOT, options); TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter()); } void InstrumentManager::OpenIAPStream() { TBDEBUG(__func__); tbricks::InstrumentAggregateParameters::Stream::Options options; for (const auto& [instId, _] : m_instrumentCache) { options.AddInstrument(instId); }<fim-suffix>TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options); } void InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" : \" << streamID); } void InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID) { TBWARNING(\"Instrument cache stream staled = \" << streamID); } void InstrumentManager::HandleStreamFailed(const StreamIdentifier& streamID) { m_handler.HandleInstrumentManagerFailed(\"Instrument stream failed\"); } void InstrumentManager::HandleSnapshotEnd(const StreamIdentifier& streamID) { TBDEBUG(__func__ << \" :<fim-middle>options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()}); m_iapStream.Close(); m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n<fim-suffix><fim-middle>    std::vector<std::string> reqChannels;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; explicit InstrumentManager(IHandler& handler); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const<fim-suffix>void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id)<fim-middle>tbricks::StreamIdentifier& stream) final;"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel volModelType) { switch(volModelType) { case VolatilityModelWing: return<fim-suffix>case VolatilityModelCCS:<fim-middle>std::make_unique<WingPreferencesStorage>();"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95; const int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally; const double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1; const double CCS_MODEL_MINIMAL_STRIKE = 1.0e-6; const double CCS_MODEL_MINIMAL_SMOOTHNESS = 0.0; const double CCS_MODEL_DEFAULT_SMOOTHNESS = 1.0; const int CCS_MODEL_MINIMAL_NUMBER_OF_CCS_POINTS = 2; const int CCS_MODEL_MAXIMAL_NUMBER_OF_CCS_POINTS = 30; const double CCS_MODEL_DEFAULT_SLOPE_LEFT = -0.05; const double CCS_MODEL_DEFAULT_SLOPE_RIGHT = 0.05; const double CCS_MODEL_DEFAULT_BREAKPOINT_SCALE_FACTOR = 1.0; const double CCS_MODEL_MINIMAL_BREAKPOINT_SCALE_FACTOR = 0.0; const int CCS_MODEL_DEFAULT_ABSCISSA = 0; const double CCS_MODEL_DEFAULT_SLOPE_MULT = 1; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER = 1.0; const double CCS_MODEL_DEFAULT_CCS_BASE_SMILE_WEIGHT = 1.0; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER_SMILE_WEIGHT = 0.0; const double CCS_MODEL_DEFAULT_MULTIPLIER_RATIO = 0.0; const double SVI_MODEL_DEFAULT_A = 0.04; const double SVI_MODEL_DEFAULT_B = 0.4; const double SVI_MODEL_DEFAULT_RHO = -0.4; const double SVI_MODEL_DEFAULT_M = 0.05; const double SVI_MODEL_DEFAULT_SIGMA = 0.1; \/* * Volatility managers need Forward price to fit volatility model parameters * so when there is empty volatility model initially, Pricing cannot calculate * Forward<fim-suffix>* for its calculation thus giving us so called chicken-and-egg problem. * 20% volatility is assumed to be a good starting point taking into account * that it does not influence significantly in most of the cases on the resulting Forward price. *\/ constexpr double EMPTY_MODEL_DEFAULT_REFERENCE_VOLATILITY = 0.2;<fim-middle>price for underlyings paying capped dividends because the reference volatility is required"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPluginHandlingModificationRequests.h\" #include \"tbricks_definitions.h\" #include <cstdlib> #include <set> using namespace tbricks; ExampleCalcAppPlugin2::ExampleCalcAppPlugin2(const PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin2::HandlePricingModifyRequest(const PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin2::Calculate(const RequestAndIVIDs & values, const CalculatedValuesRequestFull & request) { m_rows = values; for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app_handling_modification_requests::calculated_values::ExampleCalcValue2()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : m_rows) { Calculate(ivids_it.first, civ_it.GetColumnId(), x); } } else { TBERROR(\"System asked for calculation which the plugin does not support!\"); } } Send(); } void ExampleCalcAppPlugin2::Calculate(const tbricks::Uuid& rowId, const tbricks::Uuid& columnId, const tbricks::Double& x) { CalculatedValueIdentifier calc_id(rowId, columnId); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } bool ExampleCalcAppPlugin2::HandlePartialPricingModifyRequest(const CalculatedValuesRequestUpdate &update) { if (update.GetRowsBegin() != update.GetRowsEnd()) { return false; } for(auto it = update.GetColumnsBegin(), end = update.GetColumnsEnd(); it<fim-suffix><fim-middle>!= end; ++it) {"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const<fim-suffix><fim-middle>tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default: return {}; } } namespace deribit { typedef std::pair<DeribitMethod, std::string> Method; \/\/ Attempt to order by frequency static std::vector<Method> GetAvailableMethods() { return { {DeribitMethod::SUBSCRIPTION, Resolve(DeribitMethod::SUBSCRIPTION)}, {DeribitMethod::HEARTBEAT, Resolve(DeribitMethod::HEARTBEAT)}, {DeribitMethod::PUBLIC_Test, Resolve(DeribitMethod::PUBLIC_Test)}, {DeribitMethod::PUBLIC_Subscribe, Resolve(DeribitMethod::PUBLIC_Subscribe)}, {DeribitMethod::PRIVATE_Subscribe, Resolve(DeribitMethod::PRIVATE_Subscribe)}, {DeribitMethod::PUBLIC_Unsubscribe, Resolve(DeribitMethod::PUBLIC_Unsubscribe)}, {DeribitMethod::PRIVATE_Unsubscribe, Resolve(DeribitMethod::PRIVATE_Unsubscribe)}, {DeribitMethod::PUBLIC_SetHeartbeat, Resolve(DeribitMethod::PUBLIC_SetHeartbeat)}, {DeribitMethod::PUBLIC_Auth, Resolve(DeribitMethod::PUBLIC_Auth)}}; } } \/\/ namespace<fim-suffix><fim-middle>deribit"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n\nprivate:\n    std::string_view type;\n};\n\nclass subscriptions : public JsonCall\n{\npublic:\n    subscriptions(const std::string_view id, DeribitMethod method);\n\n    void AddChannel(const std::string & channel);\n};\n\nclass subscriptions_reply : public JsonReply\n{\npublic:\n    subscriptions_reply(JsonReply && base);\n<fim-suffix><fim-middle>    std::vector<std::string_view> GetChannels() const;\n};"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item,<fim-suffix>~DeribitModel() noexcept = default;<fim-middle>tbricks::DistributedValues::Stream::IHandler & handler);"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n<fim-suffix><fim-middle>        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected:<fim-suffix>}; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double<fim-middle>RapidDocument * m_doc;"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" #include \"MyCustomVolatilityModel.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return nullptr; #undef VOLATILITY_MODEL_WRAP } } SharedPointer<IVolatilityModel> VolatilityModelFactory::GetVolatilityModel(const VolatilityModel volatilityModelType) { return<fim-suffix>} std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilityCurveParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilityCurveParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ } switch(volatilityModelType) { #include \"VolatilityModelList.h\" default: return defs; #undef VOLATILITY_MODEL_WRAP } } std::vector<InstrumentParameterDefinition> VolatilityModelFactory::GetVolatilitySurfaceParametersDefinitions(const tbricks::VolatilityModel volatilityModelType) { std::vector<InstrumentParameterDefinition> defs; #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ { \\ volatility::GetVolatilitySurfaceParametersDefinitions<VolatilityModel##name>(defs); \\ return defs; \\ }<fim-middle>SharedPointer<IVolatilityModel>(VolatilityModelFactory::GetRawVolatilityModel(volatilityModelType));"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void<fim-suffix>void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override;<fim-middle>HandleStreamStale(const tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#include <strategy\/type\/InstrumentIdentifier.h>\n#include <strategy\/type\/InstrumentGroupIdentifier.h>\n#include <strategy\/instrument\/InstrumentGroupAggregateParameters.h>\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/stream\/PositionStream.h>\n#include <shared\/Macros.h>\n#include <shared\/VersionTracker.hpp>\n#include <shared\/volatility\/InterpolatedVolatilityModel.h>\n#include <shared\/Comparators.h>\n#include <shared\/smart_pointers\/SharedPointer.hpp>\n#include <shared\/smart_pointers\/WeakPointer.hpp>\n#include <shared\/sdk_definitions.h>\n#include <shared\/metaprogramming\/Badge.hpp>\n#include <bitset>\n#include \"UnderlyingTickRules.h\"\n#include \"..\/VolatilitySurfaceSubscriptionManager.h\"\n#include \"..\/plotting\/ZoomingSettings.h\"\n#include \"..\/historical_data_analysis\/ICalculationStreamWrapper.h\"\n#include \"..\/VolatilityPointsCollector.h\"\n\nTB_FORWARD_DECLARE_CLASS(InstrumentVolatilityData);\nclass ProductGroupCache;\n\nclass MaturityData\n{\npublic:\n    class IProvider\n    {\n    public:\n        virtual const InstrumentGroupIdentifier & GetProductGroupId() const = 0;\n        virtual void GetInstrumentVolatilityDataForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 std::vector<const InstrumentVolatilityData*> & data) const = 0;\n        virtual bool GetStrikeRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId, Price & minStrike,\n                                                    Price & maxStrike, const Price & strikeThreshold) const = 0;\n        virtual bool GetStrikesWithImpliedsRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 Price & minStrike, Price & maxStrike,\n                                                                 const Price & strikeThreshold) const = 0;\n        virtual const VolatilityModel GetVolatilityModelType() const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const InstrumentGroupIdentifier & groupId) const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const DateTime & maturityDate) const = 0;\n        virtual const TickRule * GetUnderlyingInstrumentTickRule(const InstrumentIdentifier & underlyingId) const = 0;\n        virtual std::pair<const MaturityData*,const MaturityData*> GetNeighboringMaturityData(const DateTime & maturityDate) const = 0;\n        virtual const MaturityData * FindMaturityData(const DateTime & maturityDate) const = 0;\n\n        virtual std::vector<InstrumentParameterDefinition> & GetVolatilitySurfaceTableDefinitionsMemCache() const = 0;\n\n        virtual const std::pair<DateTime, DateTime> & GetSampleDateTimePair() const = 0;\n\n        virtual const DateTime & GetValuationDate() const = 0;\n\n        virtual const Identifier & GetTargetContextId() const = 0;\n\n        virtual ~IProvider() {}\n    };\n\n    typedef VolatilitySurfaceSubscriptionManager::VolatilitySurfaceData     VolatilitySurfaceData;\n    typedef VolatilitySurfaceSubscriptionManager::VolatilitySurfaceDataPtr  VolatilitySurfaceDataPtr;\n<fim-suffix><fim-middle>    typedef smart_pointers::SharedPointer<volatility::IVolatilityModel> VolatilityModelPtr;\n    typedef smart_pointers::WeakPointer<const volatility::IVolatilityModel> VolatilityModelConstWeakPtr;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n<fim-suffix><fim-middle>void TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n<fim-suffix><fim-middle>        m_index += str.size();\n    }"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public:<fim-suffix>void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp();<fim-middle>UpdateData(); virtual ~UpdateData(); std::string_view ToString();"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem<fim-suffix>} void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)<fim-middle>& item) { TBDEBUG(__func__ << \", item = \" << item);"}
{"content":"<fim-prefix>#include \"PersistentPreferencesManagerCore.h\"\n#include \"PreferencesStorageFactory.h\"\n#include \"TreeNodeHelpers.h\"\n#include \"ConvertDeprecatedParam.h\"\n#include \"production\/calculation\/my_custom_pricing\/tbricks_definitions.h\"\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include \"PreferencesStorageCast.h\"\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <shared\/sdk_definitions.h>\n#include <strategy\/TreeNode.h>\n#include <strategy\/stream\/TreeNodeStreamOptions.h>\n#include <strategy\/stream_filter\/TreeNodeByTypeFilter.h>\n#include <strategy\/stream_filter\/TreeNodeDeletedFilter.h>\n#include <strategy\/stream_filter\/TreeNodeIsRootFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByParentFilter.h>\n#include <strategy\/stream_filter\/TreeNodeByIdentifierFilter.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\n#define DEFAULT_PREFERENCES_SCOPE (enumerations::VolatilityManagerPersistentPreferencesScopeMaturity)\n\nPersistentPreferencesManagerCore::PersistentPreferencesManagerCore(IProvider & provider, Mode mode) :\n    m_provider(provider),\n    m_notificationHandler(m_provider.GetNotificationHandler()),\n    m_pNonPersistentUserScopePreferences(),\n    m_pUserScopePreferencesStream(),\n    m_appConfigurationRootNodeId(),\n    m_userScopePreferencesRootNodeId(),\n    m_pUserScopePreferencesStorage(PreferencesStorageFactory::Create(m_provider.GetVolatilityModelType())),\n    m_pProductScopePreferencesStream(),\n    m_pPendingUserScopePreferencesUpdate(),\n    m_productGroupIdsByTreeNodeStreamIds(),\n    m_productNodeIdsByProductGroupIds(),\n    m_maturityScopePreferencesStreamsByProductGroupId(),\n    m_maturityNodeIdsByMaturityGroupIds(),\n    m_productScopePreferencesStorages(),\n    m_maturityScopePreferencesStorages(),\n    m_maturityScopePreferencesStoragesByProductGroupId(),\n    m_pendingProductScopePreferencesUpdate(),\n    m_pendingMaturityScopePreferencesUpdate(),\n    m_productGroupIdsPendingNodesDiscovery(),\n    m_pendingMaturityScopePreferencesUpdateByProductGroupId(),\n    m_scheduledProductScopePreferencesPersistenceFailureEventIdsWithProductGroupIds(),\n    m_scheduledMaturityScopePreferencesPersistenceFailureEventIdsWithGroupIds(),\n    m_lastFreeEventId(1),\n    m_snapshotDone(false),\n    m_persistentPreferencesManagerMode(mode),\n    m_createAppConfigurationRootNodeRequestId(),\n    m_createUserScopePreferencesNodeRequestId(),\n    m_userScopePreferencesPersistRequestIds(),\n    m_productScopePreferencesPersistRequestIds(),\n    m_createProductScopeNodeRequestIds(),\n    m_maturityScopePreferencesPersistRequestIds(),\n    m_createMaturityScopeNodeRequestIds(),\n    m_removeMaturityScopePreferencesRequestIds(),\n    m_subscribersHandler()\n{\n    m_userScopeSettingsNodeName = PrintVolModelType(m_provider.GetVolatilityModelType()) + \" Volatility manager\";\n\n    UserIdentifier userId = m_provider.GetUserIdentifier();\n    if (!userId.Empty()) {\n        m_userScopeSettingsNodeName += \" (\";\n        m_userScopeSettingsNodeName += userId.ToString();\n        m_userScopeSettingsNodeName += \")\";\n    }\n\n    SubscribeForAppConfigurationRootNode();\n}\n\nPersistentPreferencesManagerCore::~PersistentPreferencesManagerCore()\n{}\n\nvoid PersistentPreferencesManagerCore::AddHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.AddSubscriber(pHandler);\n}\n\nvoid PersistentPreferencesManagerCore::RemoveHandler(IHandler * pHandler)\n{\n    m_subscribersHandler.RemoveSubscriber(pHandler);\n}\n\nbool PersistentPreferencesManagerCore::IsSnapshotDone() const\n{\n    return m_snapshotDone;\n}\n\nconst PreferencesStorage & PersistentPreferencesManagerCore::GetUserScopePreferencesStorage() const\n{\n    if (!m_provider.IsPreferencesPersistenceDisabled()) {\n        return *m_pUserScopePreferencesStorage;\n    }\n    else {\n        return *m_pNonPersistentUserScopePreferences;\n    }\n}\n\nconst PreferencesStorage * PersistentPreferencesManagerCore::FindProductScopePreferencesStorage(const InstrumentGroupIdentifier & productGroupId) const\n{\n    if (m_provider.IsPreferencesPersistenceDisabled()) {\n        return nullptr;\n    }\n<fim-suffix><fim-middle>    auto it = m_productScopePreferencesStorages.find(productGroupId);\n    if (it == m_productScopePreferencesStorages.end()) {\n        return nullptr;\n    }"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary<fim-suffix><fim-middle>& out) { out = m_data;"}
{"content":"<fim-prefix>#pragma once #include <string> #include <string_view> #include <vector> enum class DeribitMethod { NONE, PUBLIC_Auth, PUBLIC_SetHeartbeat, PUBLIC_Test, PUBLIC_Subscribe, PUBLIC_Unsubscribe, PRIVATE_Subscribe, PRIVATE_Unsubscribe, SUBSCRIPTION, HEARTBEAT }; static std::string Resolve(DeribitMethod e) { switch (e) { case DeribitMethod::PUBLIC_Auth: return \"public\/auth\"; case DeribitMethod::PUBLIC_SetHeartbeat: return \"public\/set_heartbeat\"; case DeribitMethod::PUBLIC_Test: return \"public\/test\"; case DeribitMethod::PUBLIC_Subscribe: return \"public\/subscribe\"; case DeribitMethod::PUBLIC_Unsubscribe: return \"public\/unsubscribe\"; case DeribitMethod::PRIVATE_Subscribe: return \"private\/subscribe\"; case DeribitMethod::PRIVATE_Unsubscribe: return \"private\/unsubscribe\"; case DeribitMethod::SUBSCRIPTION: return \"subscription\"; case DeribitMethod::HEARTBEAT: return \"heartbeat\"; default: return {}; } } enum class DeribitSubscription { NONE, SUB_Ticker }; static std::string Resolve(DeribitSubscription e) { switch (e) { case DeribitSubscription::SUB_Ticker: return \"ticker\"; default: return {}; } } enum class DeribitInterval { NONE, SUB_100, SUB_RAW }; static std::string Resolve(DeribitInterval e) { switch (e) { case DeribitInterval::SUB_100: return \"100ms\"; case DeribitInterval::SUB_RAW: return \"raw\"; default: return {}; } } enum class DeribitCurrency { BTC, ETH, USDT }; static std::string Resolve(DeribitCurrency e) { switch (e) { case DeribitCurrency::BTC: return \"BTC\"; case DeribitCurrency::ETH: return \"ETH\"; case DeribitCurrency::USDT: return \"USDT\"; default: return {}; } } enum class DeribitKind { FUTURE, OPTION, ALL }; static std::string Resolve(DeribitKind e) { switch (e) { case DeribitKind::ALL: return \"*\"; case DeribitKind::FUTURE: return \"future\"; case DeribitKind::OPTION: return \"option\"; default:<fim-suffix><fim-middle>return {}; } }"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\" #include \"PositionsData.h\" #include \"tbricks_definitions.h\" #include \"execution\/TbOrderManager.h\" #include \"execution\/TbOrderMinion.h\" #include \"execution\/TbChildOrder.h\" #include <AsyncTask.h> #include <memory> using namespace tbricks; namespace sp = go_flat::strategy_parameters; GoFlatPlugin::GoFlatPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_portfolio(sp::Portfolio()) , m_statusText(sp::PlugInStatusDescription()) , m_executorType(execution::OrderExecutorType::ORDER_MANAGER) { TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered()); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); \/\/ Always<fim-suffix><fim-middle>start in paused mode     SetState(StrategyState::PAUSED);"}
{"content":"<fim-prefix>#include \"GoFlatPlugin.h\"\n#include \"PositionsData.h\"\n#include \"tbricks_definitions.h\"\n\n#include \"execution\/TbOrderManager.h\"\n#include \"execution\/TbOrderMinion.h\"\n#include \"execution\/TbChildOrder.h\"\n\n#include <AsyncTask.h>\n#include <memory>\n\nusing namespace tbricks;\n\nnamespace sp = go_flat::strategy_parameters;\n\nGoFlatPlugin::GoFlatPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_portfolio(sp::Portfolio())\n    , m_statusText(sp::PlugInStatusDescription())\n    , m_executorType(execution::OrderExecutorType::ORDER_MANAGER)\n{\n    TBSTATUS(\"Constructor: created=\" << std::boolalpha << reason.IsCreated() << \", duplicated=\" << reason.IsDuplicated() << \", recovered=\" << reason.IsRecovered());\n    TBDEBUG(\"Parameters: \" << parameters);\n\n<fim-suffix><fim-middle>    GetParameters().Merge(parameters);"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h> #include \"DeribitContributor.h\" #include \"tbricks_definitions.h\" using namespace tbricks; namespace sp = deribit_contributor::strategy_parameters; namespace dv = deribit_contributor::distributed_values; DeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters) : m_clientID(sp::ClientID()) , m_clientSecret(sp::ClientSecret()) , m_endpoint(sp::Endpoint()) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); m_supported_values.insert(dv::DeribitTicker().GetIdentifier()); m_supported_values.insert(dv::DeribitInstruments().GetIdentifier()); \/\/ Run if we were asked to if (GetTransactionOperation().IsRun()) { SetState(GetState()); HandleRunRequest(); } } void DeribitContributor::HandleRunRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN); if (m_clientID.Empty()) { FailWithReason(\"Missing client ID\"); } else if (m_clientSecret.Empty()) { FailWithReason(\"Missing client secret\"); } else if (m_endpoint.Empty()) { FailWithReason(\"Missing endpoint\"); } m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST); m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString()); } void DeribitContributor::HandlePauseRequest() { TBDEBUG(__func__); SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE); if (m_client) { m_client->Disconnect(); return; } else { SetState(StrategyState::PAUSED); } } void DeribitContributor::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier) { TBDEBUG(__func__ << \": \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void DeribitContributor::HandleValidateRequest(ValidationContext & context) { TBDEBUG(__func__ << \": \" << context); \/\/ No default validation so we just inform the frontend that validation is completed context.SendReply(); } void DeribitContributor::FailWithReason(const String & reason) { SetTransactionFail(reason, StrategyState::PAUSED); } void DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request) { TBDEBUG(__func__ << \": \" << request); DistributedValuesReply reply(request.GetIdentifier(), false); \/\/ Check that all objects are supported by<fim-suffix>for (const auto & object : request.GetObjects()) { auto & objParams = object.GetParameters(); if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency())) { \/\/ if instrument is not defined in the request TBDEBUG(\"Object missing required parameters:\\n\" << object << \"Rejecting request.\"); IDistributionApp::SendDistributedValuesReply(reply); return; } \/\/ Check instrument listed on venue Instrument i(instrumentId); auto [compatible, viid] = ExtractVIID(i); if (not compatible) { TBDEBUG(\"Instrument \" << i.GetShortName() <<<fim-middle>the app     InstrumentIdentifier instrumentId;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer& timer) override; void Update(const tbricks::StrategyParameters& strategyParameters); void Start(); void Stop(); bool IsActive() { return m_startTimerEvent.IsActive(); } const tbricks::DateTime& GetTimerLastFired() const<fim-suffix>private: IHandler& m_handler; tbricks::Timer<fim-middle>{ return m_timerLastFired; }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument);<fim-suffix>tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint; std::unique_ptr<DeribitClient> m_client;<fim-middle>"}
{"content":"<fim-prefix>#include \"TimerController.h\" #include \"tbricks_definitions.h\" using namespace tbricks; TimerController::TimerController(IHandler& handler) : m_handler(handler) , m_startTimerEvent(*this) { } void TimerController::HandleTimerEvent(Timer& timer) { TBDEBUG(__func__ ); m_timerLastFired = DateTime::Now(); if (timer == m_startTimerEvent) { m_handler.HandleTimerEventHit(); } } void TimerController::Update(const StrategyParameters& strategyParameters) { TBDEBUG(__func__); TBDUMP(strategyParameters); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime); strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency); } void TimerController::Start() { TBDEBUG(__func__); String status; if (m_frequency.Empty() and m_startTime.Empty()) { m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true); return; } if (m_frequency.Empty()) { \/\/ start with just the start time m_startTimerEvent.Start(m_startTime); status = \"Timer started, expires \" + m_startTime.ToString(); } else if (m_startTime.Empty()) { \/\/ start with just the frequency m_startTimerEvent.Start(m_frequency); status = \"Timer started, repeats \" + m_frequency.ToString(); } else<fim-suffix>}<fim-middle>{ m_startTimerEvent.Start(m_startTime, m_frequency); status = \"Timer started, starts \" + m_startTime.ToString() + \", repeats \" + m_frequency.ToString();"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler, visualization::Grid& instrumentsGrid)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n    , m_tasksDone(false)\n    , m_instrumentsGrid(instrumentsGrid)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n    m_tasksDone = false;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::OpenCIVStream()\n{\n    CalculatedInstrumentValues::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrumentVenueIdentification(InstrumentVenueIdentification(instId));\n    }\n    options.AddValue(calculated_values::UnderlyingPrice());\n\n    auto throttle = MaximumUpdateTimeThrottle(Duration::Seconds(5));\n    options.SetThrottle(throttle);\n    m_calculatedValuesStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened calculated instrument values stream : \" << m_calculatedValuesStream.GetIdentifier() << \" with options : \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n<fim-suffix><fim-middle>    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n<fim-suffix><fim-middle>    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate) HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight)<fim-suffix>HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price, Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed) VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double,<fim-middle>HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include \"TimerController.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler , public TimerController::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/<fim-suffix>void HandleRunRequest() final; void HandlePauseRequest() final;<fim-middle>Strategy methods     void HandleDeleteRequest() final;"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness, Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity) GREEK(wing_call_curvature_sensitivity, Double, WingCallCurvatureSensitivity) GREEK(wing_put_curvature_sensitivity, Double, WingPutCurvatureSensitivity) GREEK(ccs_left_slope_sensitivity, Double, CCS_LeftSlopeSensitivity) GREEK(ccs_right_slope_sensitivity, Double, CCS_RightSlopeSensitivity) GREEK(asian_average_fix, Double, AsianAverageFix) GREEK(delta_ytm, Double, DeltaYTM) GREEK(gamma_ytm, Double, GammaYTM) GREEK(fair_ytm, Double, FairYTM) GREEK(implicit_atm_forward, Double, ImplicitATM_Forward) GREEK(implicit_atm_volatility, Double, ImplicitATM_Volatility) GREEK(implicit_wing_atm_slope, Double, ImplicitWingATM_Slope) GREEK(equity_leg_override_price, Price, EquityLegOverridePrice) GREEK(yield, Double, Yield) GREEK(synthetic_yield, Double, SyntheticYield) GREEK(dividend_equivalent_yield, Double, DiscreteDividendEquivalentYield) GREEK(tenor_rate_sensitivity, Double, TenorRateSensitivity) GREEK(bond_duration, Double, BondDuration) GREEK(bond_dv01, Double, DV01) GREEK(cash_delta_base, Double, CashDeltaBase) GREEK(cash_gamma_base, Double, CashGammaBase) GREEK(cash_vega_base, Double, CashVegaBase) PRICE_INDEPENDENT_GREEK(exercise_boundary, Double, ExerciseBoundary) PRICE_INDEPENDENT_GREEK(exercise_boundary_div, Double, ExerciseBoundaryDiv) IMPL(implied_volatility, Double, ImpliedVolatility) IMPL(bid_implied_volatility, Double, BidImpliedVolatility) IMPL(ask_implied_volatility, Double, AskImpliedVolatility) IMPL(hedge_bid_implied_volatility, Double, HedgeBidImpliedVolatility) IMPL(hedge_ask_implied_volatility, Double, HedgeAskImpliedVolatility) IMPL(ask_implied_ytm, Double, AskImpliedYTM) IMPL(bid_implied_ytm, Double, BidImpliedYTM) IMPL(ask_implied_ytc, Double, AskImpliedYTC) IMPL(bid_implied_ytc, Double, BidImpliedYTC) IMPL(yield_to_average, Double, YieldToAverage) IMPL(bond_yield, Double, BondYield) IMPL(implied_financing_rate, Double, ImpliedFinancingRate) IMPL(ask_implied_financing_rate, Double, AskImpliedFinancingRate) IMPL(bid_implied_financing_rate, Double, BidImpliedFinancingRate) HIGHLIGHT(volatility_highlight, Integer, ImpliedVolatilityHighlight) HIGHLIGHT(bid_volatility_highlight, Integer, BidVolatilityHighlight) HIGHLIGHT(ask_volatility_highlight, Integer, AskVolatilityHighlight) HIGHLIGHT(hedge_bid_volatility_highlight, Integer, HedgeBidVolatilityHighlight) HIGHLIGHT(hedge_ask_volatility_highlight, Integer, HedgeAskVolatilityHighlight) VALUE(valuation_price, Price, ValuationPrice) VALUE(bid_implied_price, Price, BidUsed) VALUE(ask_implied_price, Price, AskUsed) VALUE(ask_volume_used, Volume, AskVolumeUsed) VALUE(bid_volume_used, Volume, BidVolumeUsed) VALUE(sum_of_dividends, Double, SumOfDividends) VALUE(next_dividend, Double, NextDividend) VALUE(next_dividend_date, Date, NextDividendDate) VALUE(underlying_settlement_date, Date, UnderlyingSettlementDateUsed) VALUE(final_settlement_date, Date, FinalSettlementDateUsed) VALUE(next_call_put_date, DateTime, NextCall_DIV_PutDate) VALUE(days_to_next_dividend, Integer, DaysToNextDividend) VALUE(trading_days_to_next_dividend, Integer, TradingDaysToNextDividend) VALUE(days_to_maturity, Integer, DaysToMaturity) VALUE(time_to_next_dividend, Double, TimeToNextDividend) VALUE(months_to_maturity, Double, MonthsToMaturity) VALUE(years_to_maturity, Double, YearsToMaturity) VALUE(longest_days_to_maturity, Integer, LongestDaysToMaturity) VALUE(longest_months_to_maturity, Double, LongestMonthsToMaturity) VALUE(longest_years_to_maturity, Double, LongestYearsToMaturity) VALUE(vol_days_to_maturity, Integer, VolatilityDaysToMaturity) VALUE(rate_days_to_maturity, Integer, RateDaysToMaturity) VALUE(expiration_time, Double, ExpirationTime) VALUE(rate_time, Double, RateTime) VALUE(volatility_time, Double, VolatilityTime) VALUE(rate, Double, FinancingRate) VALUE(rate_discount, Double, DiscountingRate) VALUE(present_value_adjustment_factor, Double, PresentValueAdjustmentFactor) VALUE(overnight_financing_factor, Double, OvernightFinancingFactor) VALUE(single_underlying, Boolean, SingleUnderlying) VALUE(version, Integer, ParameterVersion) VALUE(volatility_settings_changeset_used_1, Integer, VolatilitySettingsChangesetUsed1) VALUE(volatility_settings_changeset_used_2, Integer, VolatilitySettingsChangesetUsed2) VALUE(pricing_model_used, Integer, PricingModelUsed) VALUE(valuation_price_source_used, Integer, ValuationPriceSourceUsed) VALUE(accrued_interest, Price, AccruedInterest) VALUE(sink_factor, Double, SinkFactor) VALUE(rate_amount, Double,<fim-suffix><fim-middle>RateAmount) VALUE(ytm, Double, YTM)"}
{"content":"<fim-prefix>#include \"DeribitSubscriptionUpdates.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/stringbuffer.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n#include <third_party\/include\/rapidjson\/pointer.h>\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nstruct RapidDocument\n<fim-suffix><fim-middle>{\n    Document msg;\n    StringBuffer buffer;\n};"}
{"content":"<fim-prefix>#include <optional> #include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model = DeribitModel(item, *this); m_models.emplace(instrument_id, model); m_streams.emplace(model.GetStreamId(), instrument_id); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); auto model_opt = GetModel(instrument_id); if (model_opt) { auto * model = *model_opt; m_streams.erase(model->GetStreamId()); m_models.erase(instrument_id); } } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return true; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty()) { { diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey(); } } diagnostics.GetDebugStream() << std::endl; } void DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \"<fim-suffix>{ TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream) { TBDEBUG(__func__ << \": \" << stream); } void DeribitMdp::HandleDistributedValues(const StreamIdentifier & stream, const DistributedValues::Update & update) { TBDEBUG(__func__ << \": \" << stream); TBDUMP(update); } std::optional<DeribitModel *> DeribitMdp::GetModel(const StreamIdentifier & stream) { auto it_streams = m_streams.find(stream); if (it_streams ==<fim-middle><< stream); } void DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"PositionRetriever.h\" #include \"PositionReverser.h\" class ReversalManager : public PositionRetriever::IHandler, public tbricks::ITimerEventHandler { public: class IHandler; ReversalManager(IHandler& callback); ~ReversalManager() = default; void<fim-suffix>const tbricks::Integer& priceSource, const tbricks::Time& startTime); void Stop(); \/\/ Timer handler. void HandleTimerEvent(tbricks::Timer & timer) override; \/\/ PositionRetriever handler void HandleError(const tbricks::String& error) override; void HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions) override; private: IHandler&<fim-middle>Start( const tbricks::PortfolioIdentifier& portfolioId,"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier& streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier& streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier& streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier& streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, enriching...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier& streamID, const Instrument& instrument)\n{\n    TBDEBUG(__func__ << \" : stream = \" << streamID << \", instrument ID = \" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream id = \" << streamID << \", instrument id = \" << instrumentID << \", update = \" << update);\n<fim-suffix><fim-middle>    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->Reset();\n    }\n    else\n    {\n        TBDEBUG(\"Unknown stream\");\n    }\n}\n<fim-suffix><fim-middle>void DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override<fim-suffix><fim-middle>= default; protected: \/\/ MarketDataProvider     void HandleSubscribe(tbricks::MarketDataItem & item) override;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { Price emptyPrice; Volume emptyVolume {0}; iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); deribit::ticker_update update(value); \/\/ Handle the trading phase if (update.IsOpen()) { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed); } else { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed); } \/\/ BBO bbo.SetAskPrice(update.GetAsk()); bbo.SetBidPrice(update.GetBid()); bbo.SetAskVolume(update.GetAskVolume()); bbo.SetBidVolume(update.GetBidVolume()); auto millis = update.GetTimestamp(); DateTime timestamp = DateTime::Now(); if (millis > 0) { timestamp = DateTime::Create(millis \/ 1000); } bbo.SetExchangeModifiedDatetime(timestamp); \/\/ Statistics stats.SetLastPrice(update.GetLastPrice()); stats.SetOpenInterest(update.GetOpenInterest()); stats.SetDailySettlementPrice(update.GetSettlementPrice()); stats.SetHighPrice(update.GetMaxPrice()); stats.SetLowPrice(update.GetMinPrice()); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void<fim-suffix>{ InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::SendSnapshotDoneIfNeeded() { TBDEBUG(__func__);<fim-middle>DeribitModel::Fail()"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(\"HandleRunRequest\");\n    SetState(StrategyState::RUNNING);\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(\"HandlePauseRequest\");\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(\"HandleDeleteRequest\");\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(\"Modify request: \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context)\n<fim-suffix><fim-middle>{\n    TBDEBUG(\"HandleValidateRequest: \" << context);"}
{"content":"<fim-prefix>#include <third_party\/include\/rapidjson\/document.h>\n#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n    m_supported_values.insert(dv::DeribitInstruments().GetIdentifier());\n<fim-suffix><fim-middle>    if (GetTransactionOperation().IsRun())\n    {\n        SetState(GetState());"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream);<fim-suffix>private: std::map<tbricks::StreamIdentifier,<fim-middle>std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument);"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n<fim-suffix><fim-middle>    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\"\n\ntemplate <>\nBinary_istream & operator>>(Binary_istream & istm, std::string & val)\n{\n    int size = 0;\n    istm.read(size);\n\n    if (size <= 0)\n        return istm;\n\n    istm.read(val, size);\n\n    return istm;\n}\n\ntemplate <>\nvoid Binary_istream::read(tbricks::Binary & out)\n{\n    out = m_data;\n}\n\ntemplate <>\nvoid Binary_ostream::write(const tbricks::Binary & in)\n{\n    m_data.Append(in);\n}\n<fim-suffix><fim-middle>template <>\nBinary_ostream & operator<<(Binary_ostream & ostm, const std::string & val)\n{\n    if (val.size() <= 0)"}
{"content":"<fim-prefix>#pragma once #include <strategy\/test\/TestEngine.h> using namespace tbricks; using namespace tbricks::test; #ifndef TIMEOUT #define TIMEOUT tbricks::Duration::Seconds(5) #endif void Test(TestEngine &te); tbricks::String get_current_root(); tbricks::String get_apps_relative(); int main(int \/*argc*\/, char<fim-suffix>TestEngine te(\"..\/system.xml\", \"..\/engine.xml\"); te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\"); te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString()); te.RunTest(Test, TIMEOUT); return 0; } namespace go_flat { tbricks::VenueIdentifier GetTestVenueId() { return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"}; } tbricks::PortfolioIdentifier GetPortfolioId() { return {\"2eb2249c-bc89-11ee-a950-d946a31b499d\"}; } } \/\/ namespace go_flat #include <filesystem> namespace fs = std::filesystem; tbricks::String get_current_root() { fs::path current(fs::current_path()); fs::path apps; if<fim-middle>* \/*argv*\/[]) {"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5;<fim-suffix>const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE<fim-middle>const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n<fim-suffix><fim-middle>void TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/test\/TestEngine.h> using namespace tbricks; using namespace tbricks::test; #ifndef TIMEOUT #define TIMEOUT tbricks::Duration::Seconds(5) #endif void Test(TestEngine &te); tbricks::String get_current_root(); tbricks::String get_apps_relative(); int main(int \/*argc*\/, char * \/*argv*\/[]) { TestEngine te(\"..\/system.xml\", \"..\/engine.xml\"); te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\"); te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString()); te.RunTest(Test, TIMEOUT); return 0; } namespace go_flat { tbricks::VenueIdentifier GetTestVenueId() {<fim-suffix>} tbricks::PortfolioIdentifier GetPortfolioId() { return {\"2eb2249c-bc89-11ee-a950-d946a31b499d\"}; } } \/\/<fim-middle>return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"};"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/test\/TestEngine.h>\n\nusing namespace tbricks;\nusing namespace tbricks::test;\n\n#ifndef TIMEOUT\n#define TIMEOUT tbricks::Duration::Seconds(5)\n#endif\n\nvoid Test(TestEngine &te);\ntbricks::String get_current_root();\ntbricks::String get_apps_relative();\n\nint main(int  \/*argc*\/, char * \/*argv*\/[])\n{\n    TestEngine te(\"..\/system.xml\", \"..\/engine.xml\");\n    te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\");\n    te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString());\n    te.RunTest(Test, TIMEOUT);\n\n    return 0;\n}\n\nnamespace go_flat {\n\ntbricks::VenueIdentifier GetTestVenueId()\n{\n<fim-suffix><fim-middle>    return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"};\n}"}
{"content":"<fim-prefix>#pragma once\n\n#include <string>\n#include <string_view>\n#include <vector>\n\nenum class DeribitMethod\n{\n    NONE,\n    PUBLIC_Auth,\n    PUBLIC_SetHeartbeat,\n    PUBLIC_Test,\n    HEARTBEAT\n};\n\nstatic std::string Resolve(DeribitMethod e)\n{\n    switch (e)\n    {\n    case DeribitMethod::PUBLIC_Auth:\n        return \"public\/auth\";\n    case DeribitMethod::PUBLIC_SetHeartbeat:\n        return \"public\/set_heartbeat\";\n    case DeribitMethod::PUBLIC_Test:\n        return \"public\/test\";\n    case DeribitMethod::HEARTBEAT:\n        return \"heartbeat\";\n    default:\n        return {};\n    }\n}\n<fim-suffix><fim-middle>namespace deribit {"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());\n    msg.AddMember(\"id\", v, allocator);\n\n    auto m = Resolve(method);\n    v.SetString(m.data(), m.size(), msg.GetAllocator());\n    msg.AddMember(\"method\", v, allocator);\n\n    v.Clear();\n    v.SetObject();\n    msg.AddMember(\"params\", v, allocator);\n}\n\nJsonReply::JsonReply(std::string_view json)\n    : Json()\n{\n    msg.Clear();\n    Parse(json);\n\n    if (msg.HasMember(\"error\"))\n    {\n        isError = true;\n        auto errp = Pointer(\"\/error\").Get(msg);\n        if (errp->HasMember(\"code\"))\n        {\n            err.code = Pointer(\"\/error\/code\").Get(msg)->GetInt();\n        }\n        if (errp->HasMember(\"message\"))\n        {\n            err.message = Pointer(\"\/error\/message\").Get(msg)->GetString();\n        }\n        if (errp->HasMember(\"data\"))\n        {\n            err.data = Value(Pointer(\"\/error\/data\").Get(msg)->GetObject());\n        }\n    }\n\n    auto test = msg.FindMember(\"testnet\");\n    if (test != msg.MemberEnd())\n    {\n        isTest = test->value.GetBool();\n    }\n}\n\nJsonReply::JsonReply(std::string_view json, const std::vector<Method> & methods)\n    : JsonReply(json)\n{\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                jrpcMethod = method.first;\n                break;\n            }\n        }\n    }\n}\n\nJsonReply::JsonReply(JsonReply && o)\n    : Json(std::move(o))\n    , err(std::move(o.err))\n    , isTest(o.isTest)\n    , isError(o.isError)\n    , jrpcMethod(o.jrpcMethod)\n{\n}\n\nbool JsonReply::IsError() const\n{\n    return isError;\n}\n\nconst JsonReply::Error & JsonReply::GetError() const\n{\n    return err;\n}\n\nbool JsonReply::IsTest() const\n{\n    return isTest;\n}\n\nconst Value & JsonReply::GetResult()\n{\n    return msg.FindMember(\"result\")->value;\n}\n\nstd::string_view JsonReply::GetResultString()\n{\n    Writer<StringBuffer> writer(buffer);\n    msg[\"result\"].Accept(writer);\n<fim-suffix><fim-middle>    return {buffer.GetString()};\n}"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionReverser : public tbricks::IRequestReplyHandler { public: PositionReverser() = default; ~PositionReverser() = default; void ReversePosition( const tbricks::Position& position, const tbricks::Price& atPrice); \/\/ IRequestReplyHandler method void HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) final; private: std::map<tbricks::Identifier,<fim-suffix><fim-middle>tbricks::Identifier> m_reversedPositions; };"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n    \n    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);\n<fim-suffix><fim-middle>    if (read > 0 && read < m_buffer.GetSize())\n    {\n        Binary fragment(&static_cast<char *>(m_buffer.GetData())[read], "}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> #include <shared\/volatility\/MyCustomVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility model types template <class ModelTypePtr> ModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel); template <class ModelTypePtr> ModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel); template <class ModelTypeRef> ModelTypeRef vol_model_cast(volatility::IVolatilityModel & model); template <class ModelTypeRef> ModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model); #define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\ { \\ if (TB_UNLIKELY(!pModel)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model*>(pModel); \\ } #define VOL_MODEL_REF_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model & vol_model_cast(specifier volatility::IVolatilityModel & rModel) \\ { \\ if (TB_UNLIKELY(rModel.GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << rModel.GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(rModel.GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model&>(rModel); \\ } #define VOL_MODEL_CAST_IMPL(specifier, model, type) \\ VOL_MODEL_PTR_CAST_IMPL(specifier, model, type)<fim-suffix>VOL_MODEL_CAST_IMPL(const, ClampedCubicSpline, VolatilityModelCCS) VOL_MODEL_CAST_IMPL(, ClampedCubicSpline, VolatilityModelCCS) VOL_MODEL_CAST_IMPL(const, StochasticVolatilityInspired, VolatilityModelSVI) VOL_MODEL_CAST_IMPL(, StochasticVolatilityInspired, VolatilityModelSVI) VOL_MODEL_CAST_IMPL(const, WingVolatilityModel, VolatilityModelWing) VOL_MODEL_CAST_IMPL(, WingVolatilityModel, VolatilityModelWing) VOL_MODEL_CAST_IMPL(const, MyCustomVolatilityModel, volatility::VolatilityModelMyCustom) VOL_MODEL_CAST_IMPL(, MyCustomVolatilityModel, volatility::VolatilityModelMyCustom) #undef<fim-middle>\\ VOL_MODEL_REF_CAST_IMPL(specifier, model, type)"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template<fim-suffix>{ m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0)<fim-middle><> void Binary_ostream::write(const tbricks::Binary & in)"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters &<fim-suffix>protected: \/\/<fim-middle>parameters); ~DeribitContributor() noexcept override = default;"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n\nclass InstrumentEnricherPlugin : public tbricks::Strategy\n{\npublic:\n    InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);\n\n    void HandleDeleteRequest() final;\n    void HandleRunRequest() final;\n    void HandlePauseRequest() final;\n    void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final;\n    void HandleValidateRequest(tbricks::ValidationContext &context) final;\n\nprivate:\n<fim-suffix><fim-middle>    tbricks::ParameterDefinition \/*InstrumentGroup*\/   m_instrumentGroup;\n    tbricks::DateTimeParameter                         m_maturityDate;\n    tbricks::StringParameter                           m_plugInStatusDescription;"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) {<fim-suffix>return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume {0}; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail() { InstrumentStatus<fim-middle>iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\");"}
{"content":"<fim-prefix>#pragma once\n<fim-suffix><fim-middle>#include \"OrderExecutor.h\""}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n<fim-suffix><fim-middle>{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n<fim-suffix><fim-middle>void DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"PositionRetriever.h\" #include \"PositionReverser.h\" class ReversalManager : public PositionRetriever::IHandler, public tbricks::ITimerEventHandler { public: class IHandler; ReversalManager(IHandler& callback); ~ReversalManager() = default; void Start( const tbricks::PortfolioIdentifier& portfolioId, const tbricks::Integer& priceSource, const tbricks::Time& startTime); void Stop(); \/\/ Timer handler. void HandleTimerEvent(tbricks::Timer & timer) override; \/\/ PositionRetriever handler void HandleError(const tbricks::String& error) override; void HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>&<fim-suffix>private: IHandler& m_callback; tbricks::Timer<fim-middle>positions) override;"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method = DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply; std::vector<std::string> reqChannels; friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t); }; class DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; \/\/ Status virtual void HandleDeribitConnected() = 0; virtual void HandleDeribitDisconnected() = 0; \/\/ Updates virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0; }; public: DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE); ~DeribitClient(); void Connect(const tbricks::String & userId, const tbricks::String & secret); void Disconnect(); void SetHeartbeat(int seconds); void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true); protected: \/\/ IWebsocketHandler void HandleWebsocketConnected() final; void HandleWebsocketDisconnected(const tbricks::String & reason) final; void HandleError(const tbricks::String & error) final; void HandleMessage(std::string_view message) final; \/\/ ITimerEventHandler void HandleTimerEvent(tbricks::Timer & timer) final; void Login(); void TryRemoteCall(deribit::JsonReply & incoming); void TryError(SingleTransaction & t); void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled); protected: struct Session : public tbricks::Printable { \/\/ Deribit session tbricks::String token; tbricks::String refresh; tbricks::Integer expires; tbricks::DateTime expires_datetime; \/\/ Parameters tbricks::String<fim-suffix>bool connected = false; bool logged_in = false;<fim-middle>userId; tbricks::String secret; tbricks::String host_port_path;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid) { TBDEBUG(__func__ << \", ivid = \" << ivid); return false; } void DeribitMdp::GetDiagnostics(Diagnostics & diagnostics) { diagnostics.GetDebugStream() << \"Market aggregator diagnostic \"; if (!diagnostics.GetDiagnosticKey().empty())<fim-suffix>diagnostics.GetDebugStream() << \"for<fim-middle>{ {"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return (m_models.size() < MAX_INSTRUMENTS);\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";\n\n    if (!diagnostics.GetDiagnosticKey().empty())\n    {\n        {\n            diagnostics.GetDebugStream() << \"for instrument \" << diagnostics.GetDiagnosticKey();\n        }\n    }\n\n    diagnostics.GetDebugStream() << std::endl;\n}\n\nvoid DeribitMdp::HandleStreamOpen(const StreamIdentifier & stream)\n{\n    TBDEBUG(__func__ << \": \" << stream);\n}\n\nvoid DeribitMdp::HandleStreamStale(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->Reset();\n    }\n    else\n    {\n        TBDEBUG(\"Unknown stream\");\n    }\n}\n\nvoid DeribitMdp::HandleStreamFailed(const StreamIdentifier & stream)\n{\n    TBWARNING(__func__ << \": \" << stream);\n\n    auto model_opt = GetModel(stream);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        model->Fail();\n    }\n    else\n    {\n        TBDEBUG(\"Unknown stream\");\n    }\n}\n\nvoid DeribitMdp::HandleSnapshotEnd(const StreamIdentifier & stream)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \": \" << stream);\n}"}
{"content":"<fim-prefix>#include \"ExampleCalcAppPlugin.h\" #include \"tbricks_definitions.h\" #include <cstdlib> using namespace tbricks; ExampleCalcAppPlugin::ExampleCalcAppPlugin(const tbricks::PricingRequest& request) : Pricing(request) { srand (time(NULL)); \/\/ Initialize random seed. RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); SnapshotDone(); } void ExampleCalcAppPlugin::HandlePricingModifyRequest(const tbricks::PricingModifyRequest& request) { RequestAndIVIDs IVIDs; request.GetIVIDs(IVIDs); Calculate(IVIDs, request.GetFullCalculatedValuesRequest()); } void ExampleCalcAppPlugin::Calculate(const RequestAndIVIDs & values, const tbricks::CalculatedValuesRequestFull & request) { for (const auto & civ_it : request.GetColumns()) { if( civ_it.GetColumnInfo().GetDefinition() == example_calc_app::calculated_values::ExampleCalcValue()) { Double x; StrategyParameters parameters; civ_it.GetColumnInfo().GetParameters(parameters); parameters.GetParameter(strategy_parameters::X(), x); for (const auto & ivids_it : values) { CalculatedValueIdentifier calc_id(ivids_it.first, civ_it.GetColumnId()); Double result; if( x.Empty() ) result.SetError(\"Missing X parameter\"); else result = x + (double)std::rand() \/ (double)RAND_MAX - 0.5; Update(calc_id, result); } } else { \/\/ do nothing, this will be most likely picked up<fim-suffix><fim-middle>by another calc app                         \/\/ the engine was just checking if we responded to it"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class InstrumentEnricherPlugin : public tbricks::Strategy { public:<fim-suffix>\/\/ Strategy methods void HandleDeleteRequest()<fim-middle>InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void * data, size_t size) { m_data.Clear(); m_data.Set(data, size); } template <typename T> void read(T & t) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + sizeof(T)) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T)); m_index += sizeof(T); } void read(char * p, size_t size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + size) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\"); auto data = static_cast<char *>(m_data.GetData()); std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size); m_index += size; } void read(std::string & str, const unsigned int size) { if (eof()) throw std::runtime_error(\"Premature end of array!\"); if ((m_index + str.size()) > m_data.GetSize()) throw std::runtime_error(\"Premature end of array!\");<fim-suffix>str.assign(&data[m_index], size); m_index += str.size(); } private: tbricks::Binary m_data; size_t m_index;<fim-middle>auto data = static_cast<char *>(m_data.GetData());"}
{"content":"<fim-prefix>#include \"VolatilityModelFactory.h\" #include \"StochasticVolatilityInspired.h\" #include \"ClampedCubicSpline.h\" #include \"WingVolatilityModel.h\" #include \"ConstantVolatility.h\" using namespace tbricks; using namespace volatility; IVolatilityModel * VolatilityModelFactory::GetRawVolatilityModel(const VolatilityModel volatilityModelType) { #define VOLATILITY_MODEL_WRAP(name, type) \\ case VolatilityModel##name: \\ return new type; switch(volatilityModelType) { #include \"VolatilityModelList.h\" default:<fim-suffix><fim-middle>return nullptr;"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update :<fim-suffix><fim-middle>public UpdateData { public:"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected()<fim-suffix><fim-middle>= 0;"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument);<fim-suffix><fim-middle>private: std::map<tbricks::StreamIdentifier, tbricks::InstrumentIdentifier> m_streams;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n    if (length >= 126)\n    {\n        std::size_t num_bytes;\n        if (length > 0xffff)\n        {\n            num_bytes = 8;\n            out_header_and_message << static_cast<char>(127 + 128);\n        }\n        else\n        {\n            num_bytes = 2;\n            out_header_and_message << static_cast<char>(126 + 128);\n        }\n\n        for (std::size_t c = num_bytes - 1; c != static_cast<std::size_t>(-1); c--)\n            out_header_and_message << static_cast<char>((static_cast<unsigned long long>(length) >> (8 * c)) % 256);\n    }\n    else\n        out_header_and_message << static_cast<char>(length + 128);\n\n    for (std::size_t c = 0; c < 4; c++)\n        out_header_and_message << static_cast<char>(mask[c]);\n\n    auto cursor = static_cast<const char *>(buffer.GetData());\n    for (std::size_t c = 0; c < length; c++)\n    {\n        out_header_and_message << static_cast<char>(*cursor ^ mask[c % 4]);\n        cursor++;\n    }\n\n    TBDUMP(__func__ << \" : \" << out_header_and_message.GetBinary());\n\n    if (m_tcp.IsOpen())\n    {\n        m_tcp.Send(out_header_and_message.GetBinary());\n    }\n}\n\nvoid TbWebsocketClient::SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode)\n{\n    Binary temp(out_message_str.data(), out_message_str.size());\n    SendWs(temp, fin_rsv_opcode);\n}\n\nvoid TbWebsocketClient::SendCloseWs(int status, const std::string & reason)\n{\n    if (not m_tcp.IsOpen())\n        return;\n\n    Binary out;\n    char first(status >> 8);\n    char second(status % 256);\n    out.Append(&first, sizeof(char));\n    out.Append(&second, sizeof(char));\n    out.Append(reason.c_str(), reason.size());\n\n    TBDUMP(__func__ << \" : \" << out);\n    SendWs(out, 136);\n}\n\nvoid TbWebsocketClient::HandleData(TCPStream & stream, const Binary & data)\n{\n    TBDUMP(__func__ << \" : \" << data);\n    if (not m_handshake_done)\n    {\n        ParseHttpReply(data);\n        return;\n    }\n\n    m_buffer << data;\n    \n    MemStream buffer(m_buffer);\n    std::size_t read = ReadWsReply(buffer);\n    \n    if (read > 0 && read < m_buffer.GetSize())\n    {\n        Binary fragment(&static_cast<char *>(m_buffer.GetData())[read], \n                       m_buffer.GetSize() - read);\n        m_buffer = fragment;\n    }\n    else if (read == m_buffer.GetSize())\n    {\n        m_buffer.Clear();\n    }\n}\n\nvoid TbWebsocketClient::HandleStreamOpen(TCPStream & stream)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__);\n    UpgradeWs();\n}"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n<fim-suffix><fim-middle>void DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::CalculatedInstrumentValues::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; explicit InstrumentManager(IHandler& handler); ~InstrumentManager() noexcept override; void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {}; \/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ CalculatedInstrumentValues::Stream::IHandler interface void HandleCalculatedInstrumentValues(const tbricks::StreamIdentifier & streamId, const tbricks::CalculatedInstrumentValues::Update & update) final; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final; private: void OpenInstrumentStream(); void OpenIAPStream(); void OpenCIVStream(); void EnrichInstruments(); void ModifyGroup(); void CheckResolutionStatus(); void CheckModificationStatus(); struct InstrumentDetails { tbricks::Instrument instrument; tbricks::DateTime maturityDate; tbricks::InstrumentIdentifier underlyingInstrument; tbricks::Price underlyingPrice; }; using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, InstrumentDetails>; IHandler& m_handler; tbricks::InstrumentStream m_instrumentStream; tbricks::InstrumentAggregateParameters::Stream m_iapStream; tbricks::CalculatedInstrumentValues::Stream m_calculatedValuesStream; InstrumentCache m_instrumentCache; int m_failed; bool m_tasksDone; std::map<tbricks::Identifier, tbricks::InstrumentGroupIdentifier> m_groupModifyRequests; std::map<tbricks::Identifier, tbricks::InstrumentIdentifier> m_instrumentModifyRequests;<fim-suffix><fim-middle>};"}
{"content":"<fim-prefix>#include \"DeribitModel.h\"\n#include \"tbricks_definitions.h\"\n#include <deribit\/DeribitSubscriptionUpdates.h>\n\nusing namespace tbricks;\n\nDeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler)\n    : m_stream(handler)\n    , m_mdItem(item)\n{\n    DistributedValues::Stream::Options options;\n    StrategyParameters objectParams;\n    InstrumentStatus status;\n\n    auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id);\n    options.AddObject(objectParams);\n    m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {});\n\n    m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options);\n\n    status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown);\n    status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\");\n    status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown);\n    m_mdItem.PartialUpdate(status);\n\n    m_mdItem.Flush();\n}\n\nvoid DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update)\n{\n    TBDUMP(update);\n    BestPrice bbo;\n    InstrumentStatus status;\n    Statistics stats;\n<fim-suffix><fim-middle>    for (auto i = update.begin(); i != update.end(); ++i)\n    {\n        ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats);\n    }"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n<fim-suffix><fim-middle>        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/order_minion\/OrderMinionController.h\" #include \"shared\/order_minion\/OrderMinionRequest.h\" namespace execution { class TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler { public: TbOrderMinion(IExecutionHandler& handler, tbricks::Strategy& app, const tbricks::InitializationReason& reason, const tbricks::StrategyParameters& parameters); ~TbOrderMinion(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; void MonitorInstrument(const tbricks::InstrumentVenueIdentification& ivid); protected: \/\/ OrderMinionRequest::IHandler void HandleOrderMinionUpdate( const OrderMinionUpdate& update<fim-suffix>private: void UpdateStats(const OrderMinionUpdate& update, const OrderMinionRequest& request); private:<fim-middle>) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n{\npublic:\n    public_test(const std::string_view id);\n};\n\nclass heartbeat : public JsonReply\n{\npublic:\n    heartbeat(JsonReply && base);\n\n    std::string_view GetType() const;\n    bool IsTestRequest() const;\n\nprivate:\n    std::string_view type;\n};\n\nclass subscriptions : public JsonCall\n<fim-suffix><fim-middle>{\npublic:\n    subscriptions(const std::string_view id, DeribitMethod method);"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/MDTracker.h\" namespace execution { class TbOrderManager : public OrderExecutor, public tbricks::OrderManager, public tbricks::IRequestReplyHandler, public MDTracker::IHandler { public: TbOrderManager(IExecutionHandler& handler); ~TbOrderManager(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative for sell const tbricks::PortfolioIdentifier& portfolio) override; protected: \/\/ OrderManager void HandleOrderUpdate(const tbricks::Order::Update& update) override; void HandleRecoveryCompleted() override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) override; \/\/ MDTracker::IHandler void HandleBBOUpdate( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::BestPrice& before, const tbricks::BestPrice& change ) override; void HandleSnapshotEnd(const tbricks::InstrumentVenueIdentification& ivid) override; private: void EmergencyStop(); void DeleteSingleOrder(const tbricks::OrderIdentifier&<fim-suffix>const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, const tbricks::Price& price, const tbricks::Side& side, const tbricks::PortfolioIdentifier& portfolio); tbricks::Price RoundPriceToTicks(const tbricks::Price& price, const tbricks::Side& side, const tbricks::InstrumentVenueIdentification& ivid); void UpdateStats(const tbricks::Order::Update& update, const tbricks::Order& current);<fim-middle>id); void CreateSingleOrder("}
{"content":"<fim-prefix>#include \"ReversalManager.h\" #include \"tbricks_definitions.h\" #include <map> using namespace tbricks; ReversalManager::ReversalManager(IHandler& callback) : m_callback(callback) , m_scheduledTimer(*this) , m_positionRetriever(*this) { } void ReversalManager::Start( const PortfolioIdentifier& portfolioId, const Integer& priceSource, const Time& startTime) { m_portfolioId = portfolioId; m_priceSource = priceSource; m_scheduledTimer.Start(startTime); } void ReversalManager::Stop() { m_scheduledTimer.Stop(); m_positionRetriever.Stop(); } void ReversalManager::HandleTimerEvent(Timer & timer) { TBDEBUG(__func__); m_positionRetriever.RetreivePositions(m_portfolioId); } void ReversalManager::HandleError(const tbricks::String& error) { m_callback.HandleError(error); } void ReversalManager::HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions) { for (const auto& [_, position] :<fim-suffix><fim-middle>positions) {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0;<fim-suffix><fim-middle>virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0;"}
{"content":"<fim-prefix>#include \"PositionRetriever.h\" #include \"tbricks_definitions.h\" #include <sstream> #include <string> using namespace tbricks; PositionRetriever::PositionRetriever(IHandler& callback) : m_callback(callback) , m_positionStream(*this) { } void PositionRetriever::RetreivePositions(const PortfolioIdentifier& portfolioId) { TBDEBUG(__func__ << \" portfolio: \" << portfolioId); m_positions.clear(); m_wasStreamStale = false; TBDEBUG(__func__); if (m_positionStream.IsOpen()) { m_positionStream.Close(); } m_positionStream.Open( Stream::SNAPSHOT, portfolioId, Position::AGGREGATE_POSITIONS_BY_INSTRUMENT_AND_MARKET, AnyPositionFilter()); } void PositionRetriever::Stop() { m_positionStream.Close(); m_positions.clear(); } void PositionRetriever::HandleStreamOpen(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { if (not m_wasStreamStale) { TBDEBUG(__func__ << \" Stream opened: \" << stream_id); } else { TBNOTICE(\"Stream reconnected\"); m_wasStreamStale = false; } } else { TBDEBUG(__func__ << \" Unknown opened stream: \" << stream_id); } } void PositionRetriever::HandleStreamStale(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { TBWARNING(__func__ << \" Stream became stale: \" << stream_id); m_wasStreamStale = true; } else { TBWARNING(__func__ << \" Unknown stale stream: \" << stream_id); } } void PositionRetriever::HandleStreamFailed(const StreamIdentifier& stream_id) { if (m_positionStream.GetIdentifier() == stream_id) { std::stringstream error; error << \"Stream failed: \" << stream_id; m_callback.HandleError(error.str()); } else { TBWARNING(__func__ << \" Unknown failed stream: \" << stream_id); } } void PositionRetriever::HandleSnapshotEnd(const StreamIdentifier& stream_id) {<fim-suffix><fim-middle>if (m_positionStream.GetIdentifier() == stream_id)"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected:<fim-suffix>void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool<fim-middle>"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129); void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final; void HandleStreamOpen(tbricks::TCPStream & stream) final; void HandleStreamClose(tbricks::TCPStream & stream)<fim-suffix>std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept; void ParseHttpReply(const tbricks::Binary & data); std::size_t ReadWsReply(std::istream & data); void ParseWsReply(std::istream & buffer,<fim-middle>final; void UpgradeWs(); private:"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/String.h> #include <strategy\/type\/Volume.h> namespace execution { struct Stats { tbricks::Volume bought; tbricks::Volume sold; tbricks::Double valueBought; tbricks::Double valueSold; }; enum class OrderExecutorType { ORDER_MANAGER, CHILD_ORDER, ORDER_MINION }; class IExecutionHandler { public: ~IExecutionHandler()<fim-suffix><fim-middle>= default;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"WingPreferencesStorage.h\"\n#include \"CCSPreferencesStorage.h\"\n#include \"SVIPreferencesStorage.h\"\n#include <shared\/Macros.h>\n#include <shared\/SuppressSfApiClangWarnings.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/Exception.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\nusing namespace tbricks;\n\nclass BadPreferencesStorageCast: public Exception\n{\nprivate:\n    static String PreferenceKindsToString(const PreferencesStorageKind from,\n                                          const PreferencesStorageKind to)\n    {\n        std::stringstream sstrm;\n        sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to;\n        return std::move(sstrm).str();\n    }\n\npublic:\n    BadPreferencesStorageCast(const PreferencesStorageKind from,\n                              const PreferencesStorageKind to) :\n        Exception(PreferenceKindsToString(from, to))\n    {}\n};\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage);\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage);\n<fim-suffix><fim-middle>template <class PreferencesStorageRef>\nPreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage);"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return true;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n<fim-suffix><fim-middle>{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n<fim-suffix><fim-middle>        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler, public InstrumentManager::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const<fim-suffix>void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void<fim-middle>tbricks::DistributedValuesRequest & request) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n<fim-suffix><fim-middle>struct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler & handler)\n    : m_instrumentStream(*this)\n    , m_handler(handler)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Clear()\n{\n    m_tbricksInstruments.clear();\n    m_deribitInstruments.clear();\n    m_pendingCreates.clear();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n    \n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByVenueFilter(m_handler.GetVenueIdentifier()) && InstrumentStream::Filters::DeletedFilter(\/*deleted=*\/false));\n    m_instrumentStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n    \n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() \n            << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    String key = GetInstrumentKey(deribitInstrument);\n    m_deribitInstruments[key] = deribitInstrument;\n}\n\nString InstrumentManager::GetInstrumentKey(const Instrument & instrument)\n{\n    return instrument.GetShortName();\n}\n\nString InstrumentManager::GetInstrumentKey(const std::shared_ptr<DeribitInstrument> & deribitInstrument)\n{\n    return deribitInstrument->instrument_name;\n}\n\nvoid InstrumentManager::Start()\n{\n    Clear();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::SyncInstruments()\n{\n    TBDEBUG(__func__ << \": Comparing \" << m_tbricksInstruments.size() \n            << \" Tbricks instruments with \" << m_deribitInstruments.size() \n            << \" Deribit instruments\");\n<fim-suffix><fim-middle>    for (const auto & [key, deribitInst] : m_deribitInstruments)\n    {\n        auto tbricks_it = m_tbricksInstruments.find(key);\n        if (tbricks_it == m_tbricksInstruments.end())"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp { public: DeribitContributor(const tbricks::InitializationReason & reason,<fim-suffix>~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void<fim-middle>const tbricks::StrategyParameters & parameters);"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitModel.h\"\n#include <shared\/API.h>\n\nclass DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler\n{\npublic:\n    DeribitMdp();\n    ~DeribitMdp() noexcept override = default;\n<fim-suffix><fim-middle>protected:\n    void HandleSubscribe(tbricks::MarketDataItem & item) override;\n    void HandleUnsubscribe(tbricks::MarketDataItem & item) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n    void HandleTimerEvent(tbricks::Timer & timer) final;\n\n    void Login();\n    void TryRemoteCall(deribit::JsonReply & incoming);\n    void TryError(SingleTransaction & t);\n    void ManageSubscription(const std::vector<tbricks::String> & tickers, DeribitMethod method, DeribitSubscription s, bool throttled);\n\nprotected:\n    struct Session : public tbricks::Printable\n    {\n<fim-suffix><fim-middle>        tbricks::String token;\n        tbricks::String refresh;\n        tbricks::Integer expires;"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE =<fim-suffix>const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE<fim-middle>0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/String.h> #include <strategy\/type\/Volume.h> namespace execution { struct Stats { tbricks::Volume bought; tbricks::Volume sold; tbricks::Double valueBought; tbricks::Double valueSold; }; enum class OrderExecutorType { ORDER_MANAGER, CHILD_ORDER, ORDER_MINION }; class IExecutionHandler { public: ~IExecutionHandler() = default; virtual void AllDone(const Stats& stats) =<fim-suffix>}; } \/\/ namespace execution<fim-middle>0; virtual void PanicStop(const tbricks::String& msg) = 0;"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item<fim-suffix>} void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item =<fim-middle>= \" << item);"}
{"content":"<fim-prefix>#pragma once #include \"IExecutionHandler.h\" #include \"shared\/API.h\" namespace execution { class OrderExecutor { public: virtual ~OrderExecutor() = default; OrderExecutor(IExecutionHandler& handler) : m_handler(handler) { m_stats.bought = 0.0; m_stats.sold = 0.0; m_stats.valueBought = 0.0; m_stats.valueSold = 0.0; } virtual void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume,<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) { m_data.Append(in); } template <> Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm;<fim-suffix>{<fim-middle>} Binary_ostream & operator<<(Binary_ostream & ostm, const char * val)"}
{"content":"<fim-prefix>#pragma once\n\n#include \"DeribitMethods.h\"\n#include <third_party\/include\/rapidjson\/document.h>\n#include <third_party\/include\/rapidjson\/writer.h>\n\nnamespace deribit {\n\nclass Json\n{\npublic:\n    virtual ~Json() = default;\n    Json();\n    Json(Json &&);\n\n    std::string_view ToString();\n    std::string_view GetId();\n\n    void Parse(std::string_view str);\n    DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods);\n\nprotected:\n    rapidjson::Document msg;\n    rapidjson::StringBuffer buffer;\n};\n\nclass JsonCall : public Json\n{\npublic:\n    virtual ~JsonCall() = default;\n\n    JsonCall(const std::string_view id, DeribitMethod method);\n};\n\nclass JsonReply : public Json\n{\npublic:\n    struct Error\n    {\n        int code = 0;\n        std::string_view message;\n        rapidjson::Value data;\n    };\n\npublic:\n    virtual ~JsonReply() = default;\n\n    JsonReply(std::string_view json);\n    JsonReply(std::string_view json, const std::vector<Method> & methods);\n    JsonReply(JsonReply &&);\n\n    bool IsError() const;\n    const Error & GetError() const;\n\n    bool IsTest() const;\n\n    const rapidjson::Value & GetResult();\n    std::string_view GetResultString();\n    const DeribitMethod GetMethod() const;\n\nprivate:\n    Error err;\n    bool isTest = true;\n    bool isError = false;\n    DeribitMethod jrpcMethod = DeribitMethod::NONE;\n};\n\nclass public_auth : public JsonCall\n{\npublic:\n    enum class GrantType\n    {\n        CLIENT_CREDENTIALS,\n        CLIENT_SIGNATURE,\n        REFRESH_TOKEN\n    };\n\npublic:\n    public_auth(const std::string_view id);\n\n    void SetGrantType(GrantType type);\n    void SetClientId(const std::string_view val);\n    void SetClientSecret(const std::string_view val);\n    void SetRefreshToken(const std::string_view val);\n};\n\nclass public_set_heartbeat : public JsonCall\n{\npublic:\n    public_set_heartbeat(const std::string_view id);\n\n    void SetInterval(int seconds);\n};\n\nclass public_test : public JsonCall\n<fim-suffix><fim-middle>{\npublic:\n    public_test(const std::string_view id);\n};"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const<fim-suffix><fim-middle>tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); }"}
{"content":"<fim-prefix>#include <strategy\/type\/InstrumentIdentifier.h>\n#include <strategy\/type\/InstrumentGroupIdentifier.h>\n#include <strategy\/instrument\/InstrumentGroupAggregateParameters.h>\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/stream\/PositionStream.h>\n#include <shared\/Macros.h>\n#include <shared\/VersionTracker.hpp>\n#include <shared\/volatility\/InterpolatedVolatilityModel.h>\n#include <shared\/Comparators.h>\n#include <shared\/smart_pointers\/SharedPointer.hpp>\n#include <shared\/smart_pointers\/WeakPointer.hpp>\n#include <shared\/sdk_definitions.h>\n#include <shared\/metaprogramming\/Badge.hpp>\n#include <bitset>\n#include \"UnderlyingTickRules.h\"\n#include \"..\/VolatilitySurfaceSubscriptionManager.h\"\n#include \"..\/plotting\/ZoomingSettings.h\"\n#include \"..\/historical_data_analysis\/ICalculationStreamWrapper.h\"\n#include \"..\/VolatilityPointsCollector.h\"\n\nTB_FORWARD_DECLARE_CLASS(InstrumentVolatilityData);\nclass ProductGroupCache;\n\nclass MaturityData\n{\npublic:\n    class IProvider\n    {\n    public:\n        virtual const InstrumentGroupIdentifier & GetProductGroupId() const = 0;\n        virtual void GetInstrumentVolatilityDataForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 std::vector<const InstrumentVolatilityData*> & data) const = 0;\n        virtual bool GetStrikeRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId, Price & minStrike,\n                                                    Price & maxStrike, const Price & strikeThreshold) const = 0;\n        virtual bool GetStrikesWithImpliedsRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 Price & minStrike, Price & maxStrike,\n                                                                 const Price & strikeThreshold) const = 0;\n        virtual const VolatilityModel GetVolatilityModelType() const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const InstrumentGroupIdentifier & groupId) const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const DateTime & maturityDate) const = 0;\n        virtual const TickRule * GetUnderlyingInstrumentTickRule(const InstrumentIdentifier & underlyingId) const = 0;\n        virtual std::pair<const MaturityData*,const MaturityData*> GetNeighboringMaturityData(const DateTime & maturityDate) const = 0;\n        virtual const MaturityData * FindMaturityData(const DateTime & maturityDate) const = 0;\n\n        virtual std::vector<InstrumentParameterDefinition> & GetVolatilitySurfaceTableDefinitionsMemCache() const = 0;\n\n        virtual const std::pair<DateTime, DateTime> & GetSampleDateTimePair() const = 0;\n\n        virtual const DateTime & GetValuationDate() const = 0;\n\n        virtual const Identifier & GetTargetContextId() const = 0;\n\n        virtual ~IProvider() {}\n    };\n\n    typedef VolatilitySurfaceSubscriptionManager::VolatilitySurfaceData     VolatilitySurfaceData;\n    typedef VolatilitySurfaceSubscriptionManager::VolatilitySurfaceDataPtr  VolatilitySurfaceDataPtr;\n\n    typedef smart_pointers::SharedPointer<volatility::IVolatilityModel> VolatilityModelPtr;\n    typedef smart_pointers::WeakPointer<const volatility::IVolatilityModel> VolatilityModelConstWeakPtr;\n\n    typedef smart_pointers::SharedPointer<InstrumentGroupAggregateParametersStream> InstrumentGroupParametersStreamPtr;\n    typedef smart_pointers::SharedPointer<ICalculationStreamWrapper> CalculationStreamWrapperPtr;\n    typedef smart_pointers::SharedPointer<PositionStream> PositionStreamPtr;\n\npublic:\n    MaturityData(const IProvider & manager,\n                 const InstrumentGroupIdentifier & groupId = InstrumentGroupIdentifier(),\n                 const DateTime & maturityDate = DateTime(),\n                 const String & groupName = String());\n    MaturityData(MaturityData && maturityData) = default;\n    ~MaturityData();\n\n    String GetName() const;\n\n    const String & GetGroupName() const { return m_groupName; }\n    void SetGroupName(const String & groupName) { m_groupName = groupName; }\n\n    const InstrumentGroupIdentifier & GetGroupIdentifier() const { return m_groupId; }\n    void SetGroupIdentifier(const InstrumentGroupIdentifier & groupId) { m_groupId = groupId; }\n\n    const InstrumentGroupIdentifier & GetProductGroupIdentifier() const { return m_provider.GetProductGroupId(); }\n\n    const DateTime & GetMaturityDate() const { return m_maturityDate; }\n    void SetMaturityDate(const DateTime & maturityDate) { m_maturityDate = maturityDate; }\n\n    \/**\n     * Returns maturity date with zero time\n     *\n     * DateTime object with non-empty Time must be used for parsing volatility surface\n     * tables because that's how it is applied. The reason is that it's impossible\n     * to create a DateTime object with empty Time from the front-end, so ANY manual\n     * interference with the volatility surfaces tables can fool volatility managers\n     * into taking rows corresponding to wrong DateTimes\n     *\/\n    DateTime GetMaturityDateWithZeroTime() const\n    { return DateTime::Convert(m_maturityDate, DateTime::DATE_TIME, TimeZone::GetUTC()); }\n\n    const InstrumentGroupIdentifier & GetVolatilityGroupId() const { return m_volatilityGroupId; }\n    void SetVolatilityGroupId(const InstrumentGroupIdentifier & volatilityGroupId) { m_volatilityGroupId = volatilityGroupId; }\n\n    const Double & GetVolatilityTimeToMaturity() const { return m_volatilityTime; }\n    void SetVolatilityTimeToMaturity(const Double & volatilityTime) { m_volatilityTime = volatilityTime; }\n\n    const InstrumentIdentifier & GetUnderlyingId() const { return m_underlyingId; }\n    void SetUnderlyingId(const InstrumentIdentifier & underlyingId) { m_underlyingId = underlyingId; }\n<fim-suffix><fim-middle>    const Double & GetATMVolShift() const { return m_ATMVolShift; }\n    void SetATMVolShift(const Double & ATMVolShift) { m_ATMVolShift = ATMVolShift; }"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n<fim-suffix><fim-middle>        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n\nusing namespace rapidjson;\n\nJson::Json()\n{\n    msg.SetObject();\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(\"2.0\");\n    msg.AddMember(\"jsonrpc\", v, allocator);\n}\n\nJson::Json(Json && o)\n    : msg(std::move(o.msg))\n{\n}\n\nstd::string_view Json::ToString()\n{\n    buffer.Clear();\n    Writer<StringBuffer> writer(buffer);\n    msg.Accept(writer);\n    return {buffer.GetString()};\n}\n\nstd::string_view Json::GetId()\n{\n    assert(msg[\"id\"].IsString());\n    return {msg[\"id\"].GetString()};\n}\n\nvoid Json::Parse(std::string_view str)\n{\n    msg.Clear();\n    StringStream s(str.data());\n    msg.ParseStream(s);\n}\n\nDeribitMethod Json::Parse(std::string_view str, const std::vector<Method> & methods)\n{\n    Parse(str);\n    if (msg.HasMember(\"method\"))\n    {\n        std::string_view m(msg[\"method\"].GetString());\n        for (auto & method : methods)\n        {\n            if (method.second == m)\n            {\n                return method.first;\n            }\n        }\n    }\n    return DeribitMethod::NONE;\n}\n\nJsonCall::JsonCall(const std::string_view id, DeribitMethod method)\n    : Json()\n<fim-suffix><fim-middle>{\n    auto & allocator = msg.GetAllocator();\n    Value v;\n    v.SetString(id.data(), id.size(), msg.GetAllocator());"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n\n    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;\n\n    bool ParallelVerticalShift() const;\n\n    const InstrumentGroup & GetCurrentProductGroup() const { return m_instrumentGroup.GetInstrumentGroup(); }\n    const InstrumentGroup & GetReferenceInstrumentGroup() const { return m_refInstrumentGroup.GetInstrumentGroup(); }\n\n    const InstrumentIdentifier & GetFocusInstrumentIdentifier() const { return m_followedInstrumentId.GetInstrumentIdentifier(); }\n    const Integer & GetFocusInstrumentGroupType() const { return m_instrumentGroupType.GetInteger(); }\n\n    bool NoLayoutInterfaceMode() const { return !m_noLayoutInterfaceMode.Empty() && m_noLayoutInterfaceMode.GetBoolean(); }\n\n    bool GlobalAutoApplyManualFit() const { return !m_globalAutoApplyManualFit.Empty() && m_globalAutoApplyManualFit.GetBoolean(); }\n\n    bool GlobalAutoSuggest() const { return !m_globalAutoSuggest.Empty() && m_globalAutoSuggest.GetBoolean(); }\n\n    int CurveShiftUnits() const;\n\n    bool UseExoticOptions() const { return m_currentProductCommonValuesHandler.UseExoticOptions(); }\n    const CalculatedPropertyFilter & GetInstrumentFilter() const { return m_currentProductCommonValuesHandler.GetInstrumentFilter(); }\n\n    bool IsLiveFeedDisabled() const { return !m_disableLiveFeed.Empty() && m_disableLiveFeed.GetBoolean(); }\n\n    const Integer & GetForegroundCalculationThrottlingMilliseconds() { return m_calculationStreamThrottlingMilliseconds.GetInteger(); }\n\n    bool PreserveZooming() const { return !m_preserveZooming.Empty() && m_preserveZooming.GetBoolean(); }\n<fim-suffix><fim-middle>    bool SafetyCheckEnabled() const { return !m_volatilityCurveSafetyCheckEnabled.Empty() && m_volatilityCurveSafetyCheckEnabled.GetBoolean(); }"}
{"content":"<fim-prefix>#include \"TimerController.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nTimerController::TimerController(IHandler& handler)\n    : m_handler(handler)\n    , m_startTimerEvent(*this)\n{\n}\n\nvoid TimerController::HandleTimerEvent(Timer& timer)\n{\n    TBDEBUG(__func__ );\n    m_timerLastFired = DateTime::Now();\n\n    if (timer == m_startTimerEvent)\n    {\n        m_handler.HandleTimerEventHit();\n    }\n}\n\nvoid TimerController::Update(const StrategyParameters& strategyParameters)\n{\n    TBDEBUG(__func__);\n    TBDUMP(strategyParameters);\n\n    strategyParameters.GetParameter(instrument_enricher::strategy_parameters::StartTime(), m_startTime);\n    strategyParameters.GetParameter(instrument_enricher::strategy_parameters::ImportFrequency(), m_frequency);\n}\n\nvoid TimerController::Start()\n{\n    TBDEBUG(__func__);\n    String status;\n\n    if (m_frequency.Empty() and m_startTime.Empty())\n    {\n<fim-suffix><fim-middle>        m_handler.HandleTimerControllerUpdate(\"Start timer not configured, cannot start\", \/*error =*\/ true);\n        return;\n    }"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem &<fim-suffix>void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem<fim-middle>item) override;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext &<fim-suffix>void HandleDistributedValuesRequest(const<fim-middle>context) override;"}
{"content":"<fim-prefix>#include \"DeribitContributor.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace sp = deribit_contributor::strategy_parameters;\nnamespace dv = deribit_contributor::distributed_values;\n\nDeribitContributor::DeribitContributor(const InitializationReason & reason, const StrategyParameters & parameters)\n    : m_clientID(sp::ClientID())\n    , m_clientSecret(sp::ClientSecret())\n    , m_endpoint(sp::Endpoint())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    m_supported_values.insert(dv::DeribitTicker().GetIdentifier());\n\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n\n    if (m_clientID.Empty())\n    {\n        FailWithReason(\"Missing client ID\");\n    }\n    else if (m_clientSecret.Empty())\n    {\n        FailWithReason(\"Missing client secret\");\n    }\n    else if (m_endpoint.Empty())\n    {\n        FailWithReason(\"Missing endpoint\");\n    }\n\n    m_client = std::make_unique<DeribitClient>(*this, m_endpoint.GetString(), DeribitHost::DERIBIT_TEST);\n    m_client->Connect(m_clientID.GetString(), m_clientSecret.GetString());\n}\n\nvoid DeribitContributor::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_PAUSE);\n    if (m_client)\n    {\n        m_client->Disconnect();\n        return;\n    }\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid DeribitContributor::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBDEBUG(__func__ << \": \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid DeribitContributor::HandleValidateRequest(ValidationContext & context)\n{\n    TBDEBUG(__func__ << \": \" << context);\n\n    context.SendReply();\n}\n\nvoid DeribitContributor::FailWithReason(const String & reason)\n{\n    SetTransactionFail(reason, StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleDistributedValuesRequest(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n    DistributedValuesReply reply(request.GetIdentifier(), false);\n    InstrumentIdentifier instrumentId;\n\n    for (const auto & object : request.GetObjects())\n    {\n        auto & objParams = object.GetParameters();\n        if (not objParams.GetParameter(strategy_parameters::Instrument(), instrumentId) and not objParams.HasParameter(sp::DeribitCurrency()))\n        {\n            TBDEBUG(\"Object missing required parameters:\\n\"\n                    << object << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n        Instrument i(instrumentId);\n        auto [compatible, viid] = ExtractVIID(i);\n        if (not compatible)\n        {\n            TBDEBUG(\"Instrument \" << i.GetShortName() << \" (\" << instrumentId << \") not listed on Deribit\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    for (const auto & value : request.GetValues())\n    {\n        if (m_supported_values.find(value.GetDefinition().GetIdentifier()) == m_supported_values.end())\n        {\n            TBDEBUG(\"Unsupported value:\\n\"\n                    << value << \"Rejecting request.\");\n            IDistributionApp::SendDistributedValuesReply(reply);\n            return;\n        }\n    }\n\n    if (GetState() == StrategyState::PAUSED)\n    {\n        TBDEBUG(\"Request cannot be answered immediately. App is paused.\");\n        return;\n    }\n\n    reply.SetSupported(true);\n    IDistributionApp::SendDistributedValuesReply(reply);\n}\n\nvoid DeribitContributor::HandleDistributedValuesSubscription(const DistributedValuesRequest & request)\n{\n    TBDEBUG(__func__ << \": \" << request);\n\n    InstrumentIdentifier instrumentId;\n    const auto & request_id = request.GetIdentifier();\n    for (const auto & object : request.GetObjects())\n    {\n        if (object.GetParameters().GetParameter(strategy_parameters::Instrument(), instrumentId))\n        {\n            auto [compatible, viid] = ExtractVIID({instrumentId});\n            if (m_client and compatible)\n            {\n                SparseHash<String, String> keys;\n                viid.GetKeys(keys);\n                auto & id = keys[\"symbol\"];\n                for (const auto & v : request.GetValues())\n                {\n                    TBSTATUS(\"Subscribing to ticker: \" << id);\n                }\n                m_requestMap[instrumentId] = request;\n                m_symbolMap[id] = instrumentId;\n            }\n            else\n            {\n                TBWARNING(\"Request id-\" << request.GetIdentifier() << \" can't be subscribed. Instrument \" << instrumentId);\n            }\n        }\n    }\n    IDistributionApp::SnapshotDone(request_id);\n}\n\nvoid DeribitContributor::HandleDeribitConnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::RUNNING);\n    m_client->SetHeartbeat(30);\n}\n\nvoid DeribitContributor::HandleDeribitDisconnected()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid DeribitContributor::HandleTickerUpdate(const String & ticker, const std::string_view & json)\n{\n    auto & id = m_symbolMap[ticker];\n    if (id.Empty())\n    {\n        TBWARNING(\"Received unknown instrument ticker: \" << ticker);\n        return;\n    }\n    auto request = m_requestMap.find(id);\n    if (request != m_requestMap.end())\n<fim-suffix><fim-middle>    {\n        for (const auto & object : request->second.GetObjects())\n        {\n            InstrumentIdentifier instrument;"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;\n    }\n}\n\nvoid InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n    {\n        const int total = m_instrumentCache.size();\n\n        std::stringstream result;\n        result << \"Total instruments = \" << total << \", successful = \" << total - m_failed\n               << \", failed = \" << m_failed;\n\n        m_handler.HandleImportComplete(result.str());\n    }\n}\n\nvoid InstrumentManager::EnrichInstruments()\n{\n    TBDEBUG(__func__);\n\n    for (const auto& [instID, instrument] : m_instrumentCache)\n    {\n        InstrumentModifier instrumentModifier(instID);\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        if (tbMaturityDate != m_handler.GetMaturityDate())\n        {\n            InstrumentAttributes attributes;\n            attributes.SetAttribute(instrument_attributes::MaturityDate(), m_handler.GetMaturityDate());\n            instrumentModifier.SetAttributes(attributes);\n            Instrument::RequestResult result = Instrument::SendModifyRequest(instrumentModifier, *this);\n            m_instrumentModifyRequests.emplace(result.GetRequestIdentifier(), instID);\n        }\n    }\n<fim-suffix><fim-middle>    ModifyGroup();\n    CheckModificationStatus();\n}"}
{"content":"<fim-prefix>#include \"shared\/API.h\"\n#include \"InstrumentPricing.h\"\n#include \"util\/Log.h\"\n#include \"PricingPlugin.h\"\n#include \"InstrumentFilterSubscriber.h\"\n#include \"Underlying.h\"\n#include \"payments\/DividendInstrument.h\"\n#include \"payments\/PaymentInstrument.h\"\n#include \"UnderlyingComponentsManager.h\"\n#include \"price_providers\/BarrierInstrument.h\"\n#include \"models\/ModelCalculatorFactory.h\"\n#include \"models\/TurboOptionModelCalculator.h\"\n#include \"models\/TurboOptionWithDividendsModelCalculator.h\"\n#include \"models\/MiniFutureModelCalculator.h\"\n#include \"models\/CallableBullBearContractModelCalculator.h\"\n#include \"models\/CBBCWithDividendsModelCalculator.h\"\n#include \"models\/CBBCBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/CBBCWithDividendsBarrierInstrumentMDAgnosticModelCalculator.h\"\n#include \"models\/BondModelCalculator.h\"\n#include \"models\/EquityReturnModelCalculator.h\"\n#include \"price_providers\/PriceProviderEmpty.h\"\n#include \"price_providers\/PriceProviderSingle.h\"\n#include \"price_providers\/PriceProviderQuote.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/interest_rate\/YieldCurveWrapper.h\"\n#include \"UserPreferencesSubscriber.h\"\n#include \"time\/TimeOptions.h\"\n#include \"time\/TimeValues.h\"\n#include \"time\/VolatilityTimeWeights.h\"\n#include \"time\/CalendarUtils.h\"\n#include <cmath>\n#include <algorithm>\n#include <type_traits>\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include \"shared\/combination\/ICombinationModel.h\"\n#include \"shared\/Macros.h\"\n#include <shared\/instrument_types\/InstrumentTypes.h>\n#include <shared\/metaprogramming\/Defer.hpp>\n\n#include \"util\/Tokens.h\"\n\n#include \"models\/EquityModelCalculator.h\"\n#include \"models\/ExternalModelCalculator.h\"\n#include \"models\/ExternalTaylorModelCalculator.h\"\n#include \"models\/ExternalModelDistributionCalculator.h\"\n\n#include \"models\/PricingCombinationModel.h\"\n#include \"models\/util\/MiscCalculations.h\"\n#include \"models\/util\/DividendsUtil.h\"\n\n#include \"shared\/datetime_helpers\/DateTimeHelpers.h\"\n#include \"shared\/smart_pointers\/IntrusiveWeakPointer.hpp\"\n\n#include <shared\/time\/TimeParser.h>\n#include <shared\/StateRestorer.hpp>\n\n#include \"tbricks_definitions.h\"\n#include \"shared\/pricing\/tbricks_constants.h\"\n\nusing namespace tbricks;\n\nstd::ostream & operator<<(std::ostream & os, const RelativeValuationTime val_time)\n{\n    using RVT = RelativeValuationTime;\n    switch (val_time) {\n    case RVT::NOW:                 return os << \"Now\";\n    case RVT::TODAY_CLOSE:         return os << \"Today close\";\n    case RVT::NEXT_OPEN:           return os << \"Next open\";\n    case RVT::NEXT_DAY:            return os << \"Next day\";\n    default:                       return os << \"Unrecognized valuation time\";\n    }\n}\n\nInstrumentPricing::InstrumentPricing(PricingPlugin & plugin, const InstrumentIdentification & id,\n                                     const InstrumentVenueIdentification & ivid,\n                                     std::shared_ptr<SnapshotToken> snapshot_token,\n                                     std::shared_ptr<ModificationToken> modification_token,\n                                     const LegSettingsPtr & leg_settings) :\n    m_id(id),\n    m_plugin(plugin),\n    m_ivid(new InstrumentVenueIdentification(ivid)),\n    m_leg_settings(leg_settings),\n    m_instrument(new Instrument()),\n    m_override_prices(new IPriceProvider::OverridePriceContainer()),\n    m_q(GetCalculationSettings().GetYield()),\n    m_today_values(new TimeValues()),\n    m_plugin_modify_version(plugin.GetPluginModifyVersion()),\n    m_snapshot_token(snapshot_token),\n    m_modification_token(modification_token)\n{\n    PDEBUGN(\"Create instrument pricing: \" << *m_ivid << \" row id = \" << GetRowIdentifier());\n\n    m_calculated_values_pool.reset(new CalculatedInstrumentValuesPool(plugin, *this));\n    PDEBUGN(\"Instrument size is \" << sizeof(*this) << \", pool size is \" << sizeof(*m_calculated_values_pool));\n\n    if (m_ivid->GetInstrumentIdentifier().Empty()) {\n        ResetSnapshotTokens();\n        m_snapshot_done = true;\n        return;\n    }\n\n    if (m_calculated_values_pool->GetValuesRequest().TimeGreeksIsActive()) {\n        m_today_close_values.reset(new TimeValues());\n        m_next_trading_open_values.reset(new TimeValues());\n        m_next_trading_day_values.reset(new TimeValues());\n    }\n\n    InitializeDefaultParameters();\n    InitializeCalculatedValues();\n\n    UpdateOverrides(m_plugin.GetFullCalculatedValuesRequest().GetOverrides());\n\n    UpdateExpirationTime();\n\n    RetainTimer();\n\n    InstrumentSubscriptionIdentification instrument_subscription_id(m_ivid->GetInstrumentIdentifier(),\n                                                                    GetStreamSettingsPtr()->GetParametersDateTime());\n    m_instrument_stream = m_plugin.GetStreamManager().SubscribeForInstrument(instrument_subscription_id, this);\n\n    InstrumentAggregateParameters::Stream::Options ip_options;\n\n    pricing::StreamOptionsCache::IAPSetup iap_setup;\n    if (id.GetStreamSettingsPtr()->GetVolatilityDateTime() == id.GetStreamSettingsPtr()->GetParametersDateTime()) {\n        iap_setup.with_vol = true;\n        ip_options.SetParameterSource(true);\n    } else {\n        InstrumentAggregateParameters::Stream::Options vol_options;\n        vol_options.SetInstrument(m_ivid->GetInstrumentIdentifier());\n        vol_options.SetThrottle(plugin.GetInstrumentParametersThrottle());\n        vol_options.SetParameterDefinitions(m_plugin.GetInstrumentPricingVolatilityDefinitions());\n        vol_options.SetSnapshotDateTime(id.GetStreamSettingsPtr()->GetVolatilityDateTime());\n        vol_options.SetContextIdentifier(id.GetStreamSettingsPtr()->GetParameterContext());\n        vol_options.SetRankingIdentifier(id.GetStreamSettingsPtr()->GetParameterContextRanking());\n        vol_options.SetUserIdentifier(id.GetStreamSettingsPtr()->GetParameterUserIdentifier());\n        vol_options.SetPortfolioIdentifier(id.GetStreamSettingsPtr()->GetParameterPortfolioIdentifier());\n        vol_options.SetParameterSource(true);\n<fim-suffix><fim-middle>        m_volatility_stream.reset(new InstrumentAggregateParameters::Stream(*this));\n        m_volatility_stream->Open(m_plugin.GetSubscriptionType(), vol_options);\n        PDEBUGN(\"Opened volatility parameters stream: \" << *m_volatility_stream);\n        PDUMPN(\"Volatility parameters stream options: \" << vol_options);"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrument_enricherAppAction(instrument_enricher::strategy_parameters::instrument_enricherAppAction())\n    , m_importFrequency(instrument_enricher::strategy_parameters::ImportFrequency())\n    , m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_startTime(instrument_enricher::strategy_parameters::StartTime())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_importOnce(false)\n    , m_instrumentManager(*this)\n    , m_timerController(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        ImportNow();\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier& modifier)\n{\n    TBSTATUS(__func__ << \" : \" << modifier);\n    const StrategyParameters& parameters = modifier.GetParameters();\n\n    GetParameters().Merge(parameters);\n    MergeAttributes(modifier.GetAttributes());\n\n    if (parameters.HasParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction()))\n    {\n        Integer action;\n        parameters.GetParameter(instrument_enricher::strategy_parameters::instrument_enricherAppAction(), action);\n\n        HandleAction(action);\n    }\n\n    if (parameters.GetParameter(m_startTime) or\n        parameters.GetParameter(m_importFrequency))\n    {\n        m_timerController.Update(parameters);\n    }\n\n    m_instrument_enricherAppAction.Clear();\n}\n\nvoid InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext& context)\n{\n    TBDEBUG(__func__ << \" : \" << context);\n\n    auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT;\n    context.GetItem(m_instrumentGroup).SetDirection(direction);\n    context.GetItem(m_underlyingInstrument).SetDirection(direction);\n    context.GetItem(m_maturityDate).SetDirection(direction);\n    context.GetItem(m_instrument_enricherAppAction).SetDirection(direction);\n\n    auto &action_vi = context.GetItem(m_instrument_enricherAppAction);\n    std::vector<Integer> allowed_actions;\n    if (GetState().IsRunning())\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer);\n    }\n    else\n    {\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer);\n        allowed_actions.emplace_back(instrument_enricher::enumerations::instrument_enricherAppActionsRunNow);\n    }\n    action_vi.SetValidValues(allowed_actions);\n    action_vi.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n\n    if (not GetState().IsRunning())\n    {\n        auto& freqValidationItem = context.GetItem(m_importFrequency);\n        Duration frequency;\n        freqValidationItem.GetValue(frequency);\n        if (not frequency.Empty() and frequency < Duration::Seconds(1))\n        {\n            freqValidationItem.SetValue(Duration::Seconds(1));\n            m_plugInStatusDescription = \"Import frequency cannot be less than 1 second\";\n        }\n        freqValidationItem.SetDirection(ParameterDefinition::INPUT_OUTPUT);\n    }\n\n    context.SendReply();\n}\n\nbool InstrumentEnricherPlugin::CheckRunningRequirement()\n{\n    TBDEBUG(__func__);\n    if (m_instrumentGroup.Empty())\n    {\n        m_plugInStatusDescription = \"Instrument group is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_maturityDate.Empty())\n    {\n        m_plugInStatusDescription = \"Maturity date is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    if (m_underlyingInstrument.Empty())\n    {\n        m_plugInStatusDescription = \"Underlying instrument is empty\";\n        TBWARNING(m_plugInStatusDescription.GetString());\n        return false;\n    }\n\n    return true;\n}\n\nvoid InstrumentEnricherPlugin::HandleAction(const Integer & action)\n{\n    TBDEBUG(__func__ << \" : \" << action);\n\n    if(TB_UNLIKELY(action.Empty()))\n    {\n       TBDEBUG(\"Action is empty, skipping\");\n    }\n\n    switch (action.GetInt())\n    {\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStartTimer:\n       Start();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsStopTimer:\n       Stop();\n       break;\n    case instrument_enricher::enumerations::instrument_enricherAppActionsRunNow:\n       m_importOnce = true;\n       ImportNow();\n       break;\n    default:\n       TBDEBUG(\"Unknown action\");\n       break;\n    }\n}\n\nvoid InstrumentEnricherPlugin::Start()\n{\n    TBDEBUG(__func__);\n<fim-suffix><fim-middle>    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public<fim-suffix>{ public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item)<fim-middle>tbricks::MarketDataProvider"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"WingPreferencesStorage.h\"\n#include \"CCSPreferencesStorage.h\"\n#include \"SVIPreferencesStorage.h\"\n#include <shared\/Macros.h>\n#include <shared\/SuppressSfApiClangWarnings.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/Exception.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\nusing namespace tbricks;\n\nclass BadPreferencesStorageCast: public Exception\n{\nprivate:\n    static String PreferenceKindsToString(const PreferencesStorageKind from,\n                                          const PreferencesStorageKind to)\n    {\n        std::stringstream sstrm;\n        sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to;\n        return std::move(sstrm).str();\n    }\n\npublic:\n    BadPreferencesStorageCast(const PreferencesStorageKind from,\n                              const PreferencesStorageKind to) :\n        Exception(PreferenceKindsToString(from, to))\n    {}\n};\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage);\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage);\n\ntemplate <class PreferencesStorageRef>\nPreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage);\n\ntemplate <class PreferencesStorageRef>\nPreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage);\n\n#define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\\n    template <> \\\n    inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\\n    { \\\n        if (TB_UNLIKELY(!pPreferencesStorage)) { \\\n            return nullptr; \\\n        } \\\n        \\\n        if (TB_UNLIKELY((pPreferencesStorage->GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\\n            throw BadPreferencesStorageCast(pPreferencesStorage->GetKind(), kind); \\\n        } \\\n        \\\n        return reinterpret_cast<specifier type*>(pPreferencesStorage); \\\n    }\n\n#define PREFERENCES_STORAGE_REF_CAST_IMPL(specifier, type, kind) \\\n    template <> \\\n    inline specifier type & pref_storage_cast(specifier PreferencesStorage & preferencesStorage) \\\n    { \\\n        if (TB_UNLIKELY((preferencesStorage.GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\\n            throw BadPreferencesStorageCast(preferencesStorage.GetKind(), kind); \\\n        } \\\n        \\\n        return reinterpret_cast<specifier type&>(preferencesStorage); \\\n    }\n\n#define PREFERENCES_STORAGE_CAST_IMPL(specifier, type, kind) \\\n    PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\\n    PREFERENCES_STORAGE_REF_CAST_IMPL(specifier, type, kind)\n<fim-suffix><fim-middle>PREFERENCES_STORAGE_CAST_IMPL(const, PreferencesStorage, PreferencesStorageKind::Common)\nPREFERENCES_STORAGE_CAST_IMPL(, PreferencesStorage, PreferencesStorageKind::Common)\nPREFERENCES_STORAGE_CAST_IMPL(const, WingPreferencesStorage, PreferencesStorageKind::Wing)\nPREFERENCES_STORAGE_CAST_IMPL(, WingPreferencesStorage, PreferencesStorageKind::Wing)"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/stream\/TCPStream.h>\n#include <random>\n#include \"BinaryStreamBuffer.h\"\n\n#include <simple-websocket-server\/crypto.hpp>\n#include <simple-websocket-server\/utility.hpp>\n\nclass IWebsocketHandler\n{\npublic:\n    virtual ~IWebsocketHandler() = default;\n\n    virtual void HandleWebsocketConnected() = 0;\n    virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0;\n    virtual void HandleError(const tbricks::String & error) = 0;\n\n    virtual void HandleMessage(std::string_view message) = 0;\n};\n\nclass TbWebsocketClient : public tbricks::TCPStream::IHandler\n{\npublic:\n    struct Config\n    {\n        long timeout_request = 0;\n        long timeout_idle = 0;\n        std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)();\n        SimpleWeb::CaseInsensitiveMultimap header;\n        std::string proxy_server;\n        std::string proxy_auth;\n\n        unsigned short default_port = 80;\n    };\n\npublic:\n    TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf);\n    ~TbWebsocketClient();\n\n    void Connect();\n    void Shutdown(int status = 1000, const std::string & reason = \"\");\n\n    void SendWs(const tbricks::Binary & buffer, unsigned char fin_rsv_opcode = 129);\n    void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129);\n    void SendCloseWs(int status, const std::string & reason = \"\");\n\nprotected:\n    void HandleData(tbricks::TCPStream & stream, const tbricks::Binary & data) final;\n    void HandleStreamOpen(tbricks::TCPStream & stream) final;\n    void HandleStreamClose(tbricks::TCPStream & stream) final;\n\n    void UpgradeWs();\n\nprivate:\n    std::pair<std::string, unsigned short> parse_host_port(const std::string & host_port, int64_t default_port) const noexcept;\n\n    void ParseHttpReply(const tbricks::Binary & data);\n    std::size_t ReadWsReply(std::istream & data);\n    void ParseWsReply(std::istream & buffer, unsigned char fin_rsv_opcode, size_t length);\n\nprivate:\n    IWebsocketHandler & m_handler;\n    tbricks::TCPStream m_tcp;\n    std::random_device m_rd;\n    std::shared_ptr<std::string> nonce_base64;\n\n    Config m_config;\n<fim-suffix><fim-middle>    std::string host;\n    unsigned short port;\n    std::string path;\n    bool m_handshake_done = false;"}
{"content":"<fim-prefix>#pragma once #include <strategy\/test\/TestEngine.h> using namespace tbricks; using namespace tbricks::test; #ifndef TIMEOUT #define TIMEOUT tbricks::Duration::Seconds(5) #endif void Test(TestEngine &te); tbricks::String get_current_root(); tbricks::String get_apps_relative(); int main(int \/*argc*\/, char * \/*argv*\/[]) { TestEngine te(\"..\/system.xml\", \"..\/engine.xml\"); te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\"); te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString()); te.RunTest(Test, TIMEOUT); return 0; } namespace go_flat { tbricks::VenueIdentifier<fim-suffix><fim-middle>GetTestVenueId() { return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"};"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider<fim-suffix>DeribitMdp(); ~DeribitMdp() noexcept<fim-middle>{ public:"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *)<fim-suffix>} }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() +<fim-middle>p, (char *) p, (char *) p + l);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(&t), &data[m_index], sizeof(T));\n\n        m_index += sizeof(T);\n    }\n\n    void read(char * p, size_t size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + size) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        std::memcpy(reinterpret_cast<void *>(p), &data[m_index], size);\n\n        m_index += size;\n    }\n\n    void read(std::string & str, const unsigned int size)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        if ((m_index + str.size()) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");\n\n        auto data = static_cast<char *>(m_data.GetData());\n        str.assign(&data[m_index], size);\n\n        m_index += str.size();\n    }\n\nprivate:\n    tbricks::Binary m_data;\n    size_t m_index;\n};\n<fim-suffix><fim-middle>class Binary_ostream\n{\npublic:\n    Binary_ostream() { }"}
{"content":"<fim-prefix>#include <strategy\/type\/InstrumentIdentifier.h>\n#include <strategy\/type\/InstrumentGroupIdentifier.h>\n#include <strategy\/instrument\/InstrumentGroupAggregateParameters.h>\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/stream\/PositionStream.h>\n#include <shared\/Macros.h>\n#include <shared\/VersionTracker.hpp>\n#include <shared\/volatility\/InterpolatedVolatilityModel.h>\n#include <shared\/Comparators.h>\n#include <shared\/smart_pointers\/SharedPointer.hpp>\n#include <shared\/smart_pointers\/WeakPointer.hpp>\n#include <shared\/sdk_definitions.h>\n#include <shared\/metaprogramming\/Badge.hpp>\n#include <bitset>\n#include \"UnderlyingTickRules.h\"\n#include \"VolTuningData.h\"\n#include \"..\/VolatilitySurfaceSubscriptionManager.h\"\n#include \"..\/plotting\/ZoomingSettings.h\"\n#include \"..\/historical_data_analysis\/ICalculationStreamWrapper.h\"\n#include \"..\/VolatilityPointsCollector.h\"\n\nTB_FORWARD_DECLARE_CLASS(InstrumentVolatilityData);\nclass ProductGroupCache;\n\nclass MaturityData\n{\npublic:\n    class IProvider\n    {\n    public:\n        virtual const InstrumentGroupIdentifier & GetProductGroupId() const = 0;\n        virtual void GetInstrumentVolatilityDataForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 std::vector<const InstrumentVolatilityData*> & data) const = 0;\n        virtual bool GetStrikeRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId, Price & minStrike,\n                                                    Price & maxStrike, const Price & strikeThreshold) const = 0;\n        virtual bool GetStrikesWithImpliedsRangeForMaturityGroup(const InstrumentGroupIdentifier & groupId,\n                                                                 Price & minStrike, Price & maxStrike,\n                                                                 const Price & strikeThreshold) const = 0;\n        virtual const VolatilityModel GetVolatilityModelType() const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const InstrumentGroupIdentifier & groupId) const = 0;\n        virtual const TickRule * GetExampleInstrumentTickRule(const DateTime & maturityDate) const = 0;\n        virtual const TickRule * GetUnderlyingInstrumentTickRule(const InstrumentIdentifier & underlyingId) const = 0;\n        virtual std::pair<const MaturityData*,const MaturityData*> GetNeighboringMaturityData(const DateTime & maturityDate) const = 0;\n        virtual const MaturityData * FindMaturityData(const DateTime & maturityDate) const = 0;\n\n        virtual std::vector<InstrumentParameterDefinition> & GetVolatilitySurfaceTableDefinitionsMemCache() const = 0;\n\n        virtual const std::pair<DateTime, DateTime> & GetSampleDateTimePair() const = 0;\n<fim-suffix><fim-middle>        virtual const DateTime & GetValuationDate() const = 0;"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\" SUPPRESS_SF_API_CLANG_WARNINGS #include \"shared\/app\/app.h\" CLANG_RESTORE_WARNINGS #include <limits> using namespace tbricks; class ValuesRequest; struct ImpliedValue { void Clear(); friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value) { return value.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double implied_volatility; }; struct FairPriceValue { FairPriceValue & operator += (const FairPriceValue & fair_price_value); FairPriceValue & operator += (const Double & value); FairPriceValue operator * (const Double & mult) const; FairPriceValue & operator *= (const Double & mult); void Clear(); bool SetError(const String & error); friend std::ostream & operator << (std::ostream & strm, const FairPriceValue & price) { return price.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double fair_price; }; struct Greeks { Greeks & operator += (const Greeks & greeks); Greeks operator * (const Double & mult) const; Greeks & operator *= (const Double & mult); void Clear(); void ClearNoncombinationValues(); void Set(const Greeks & greeks); bool SetError(const String & error); void SetErrorToCCSVolatilityModelGreeks(const String & error); void SetErrorToWingVolatilityModelGreeks(const<fim-suffix>friend std::ostream & operator << (std::ostream & strm, const Greeks & greeks) { return greeks.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double forward_price; Double quanto_forward_price; Double spot_price; Double strike_price; Double delta; Double gamma; Double option_equivalent_gamma; Double vega; Double option_equivalent_vega; Double rho; Double rho_discounting; Double vanna; Double vomma; Double skew_delta; Double skew_gamma; Double calendar_theta; Double volatility_theta; Double rate_theta; Double calendar_charm; Double calendar_skew_charm; Double calendar_color; Double opening_theta; Double opening_charm; Double opening_skew_charm; Double opening_color; Double overnight_theta; Double overnight_charm; Double overnight_skew_charm; Double overnight_color; Double divit; Double speed; Double skew_speed; Double zomma; Double volatility; Double at_the_money_volatility; Double at_the_money_straddle_price; Double straddle_price; Boolean exercise_boundary_reached; Boolean exercise_boundary_div_reached; Integer moneyness; Double simple_put_moneyness; Double wing_slope_sensitivity; Double wing_call_curvature_sensitivity; Double wing_put_curvature_sensitivity; Double ccs_left_slope_sensitivity; Double ccs_right_slope_sensitivity; Double asian_average_fix; Double delta_ytm; Double gamma_ytm; Double fair_ytm; Double implicit_atm_forward; Double implicit_atm_volatility; Double implicit_wing_atm_slope; Double equity_leg_override_price; Double yield; Double synthetic_yield; Double<fim-middle>String & error); void ZeroFill();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h><fim-suffix>{ public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void<fim-middle>#include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"WingPreferencesStorage.h\"\n#include \"CCSPreferencesStorage.h\"\n#include \"SVIPreferencesStorage.h\"\n#include \"MyCustomPreferencesStorage.h\"\n#include <shared\/Macros.h>\n#include <shared\/SuppressSfApiClangWarnings.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/Exception.h>\n#include <strategy\/Logger.h>\nCLANG_RESTORE_WARNINGS\n#include <sstream>\n\nusing namespace tbricks;\n\nclass BadPreferencesStorageCast: public Exception\n{\nprivate:\n    static String PreferenceKindsToString(const PreferencesStorageKind from,\n                                          const PreferencesStorageKind to)\n    {\n        std::stringstream sstrm;\n        sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to;\n        return std::move(sstrm).str();\n    }\n\npublic:\n    BadPreferencesStorageCast(const PreferencesStorageKind from,\n                              const PreferencesStorageKind to) :\n        Exception(PreferenceKindsToString(from, to))\n    {}\n};\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage);\n\ntemplate <class PreferencesStoragePtr>\nPreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage);\n\ntemplate <class PreferencesStorageRef>\nPreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage);\n\ntemplate <class PreferencesStorageRef>\nPreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage);\n\n#define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\\n    template <> \\\n    inline specifier type * pref_storage_cast(specifier PreferencesStorage * pPreferencesStorage) \\\n    { \\\n<fim-suffix><fim-middle>        if (TB_UNLIKELY(!pPreferencesStorage)) { \\\n            return nullptr; \\\n        } \\\n        \\"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String&<fim-suffix>}; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String& str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double<fim-middle>str); protected: RapidDocument* m_doc;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler {<fim-suffix><fim-middle>public: class IHandler"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)<fim-suffix><fim-middle>{ TBDEBUG(__func__ << \", item = \" << item);"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData { public: UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String & str); protected: RapidDocument * m_doc; }; class ticker_update : public UpdateData { public: ticker_update(const tbricks::String & str); std::string_view GetInstrumentName(); int64_t GetTimestamp(); bool IsOpen(); double GetSettlementPrice(); double GetOpenInterest(); double GetMinPrice(); double GetMaxPrice(); double GetMarkPrice(); double GetLastPrice(); double GetIndexPrice(); double GetCurrentFunding(); double<fim-suffix><fim-middle>GetBid(); double GetAsk(); double GetBidVolume();"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { \/\/ Here is where we would<fim-suffix><fim-middle>open the DistributedValues::Stream }"}
{"content":"<fim-prefix>#include \"ApplyNotifier.h\"\n#include \"ATMStraddlePriceToVolConverter.h\"\n#include \"CurrentMaturityCommonValuesHandler.h\"\n#include \"CurrentProductCommonValuesHandler.h\"\n#include \"CurveQualityMetricsCalculator.h\"\n#include \"Exporter.h\"\n#include \"IFitSettingsManager.h\"\n#include \"MaturityDataExporter.h\"\n#include \"ImpliedVolatilitySourcesManager.h\"\n#include \"OptionFiltersWatcher.h\"\n#include \"HighlightingProcessor.h\"\n#include \"InstrumentTradingStatusTracker.h\"\n#include \"IPostModifyRunner.h\"\n#include \"OTMCalculatedValuesManager.h\"\n#include \"view\/CurrentProductStrikeMatrixView.h\"\n#include \"view\/StrikeMatrixMaturitiesListView.h\"\n#include \"ReferenceGroupWatcher.h\"\n#include \"VolatilitySurfaceSubscriptionManager.h\"\n#include \"automatic_fit\/AutoFitManager.h\"\n#include \"automatic_fit\/AutoFitRealTimeDiagnostic.h\"\n#include \"automatic_fit\/QuotingRecommendationManager.h\"\n#include \"cache\/UnderlyingTickRules.h\"\n#include \"cache\/ProductGroupCacheHandler.h\"\n#include \"term_structure\/TermStructureManager.h\"\n#include \"volatility_models\/WeightFunctions.h\"\n#include \"preferences\/PersistentPreferencesManager.h\"\n#include \"StaticArbitrageChecker.h\"\n#include \"historical_data_analysis\/HistoricalData.h\"\n#include <shared\/sdk_definitions.h>\n#include <shared\/IScheduledEventHandler.h>\n#include <shared\/notification_handler\/NotificationHandler.h>\n#include <shared\/group_retriever\/GroupsFromInstrumentRetriever.h>\n#include <shared\/Macros.h>\n#include <shared\/subscription\/SubscribersHandler.hpp>\n#include <shared\/sub_strategy\/SubStrategiesManager.h>\n#include <strategy\/stream\/InstrumentGroupStream.h>\n#include <strategy\/LatencyTimer.h>\n#include <strategy\/Timer.h>\n#include <strategy\/VisualizationApp.h>\n#include <memory>\n\nusing namespace tbricks;\n\nTB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManager);\nTB_FORWARD_DECLARE_CLASS(IVolatilityInterpolator);\nTB_FORWARD_DECLARE_CLASS(AlertRiser);\nTB_FORWARD_DECLARE_CLASS(IVolatilityCurveManager);\nTB_FORWARD_DECLARE_CLASS(OptionFiltersWatcher);\n\nclass IVolatilityManager: public VisualizationApp,\n                          public IScheduledEventHandler::IManager,\n                          public ApplyNotifier,\n                          public AutoFitManager::IHandler,\n                          public GroupsFromInstrumentRetriever::IHandler,\n                          public Exporter::CallbackHandler,\n                          public ReferenceGroupWatcher::IHandler,\n                          public ATMStraddlePriceToVolConverter::IHandler,\n                          public ImpliedVolatilitySourcesManager::IHandler,\n                          public IFitSettingsManager,\n                          public InstrumentGroupStream::IHandler,\n                          public IRequestReplyHandler,\n                          public IPostModifyRunner::IManager,\n                          public ITimerEventHandler,\n                          public PersistentPreferencesManagerCore::IHandler\n{\npublic:\n    TB_FORWARD_DECLARE_CLASS(ValidationProcessor);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductGroupWatchersManager);\n    TB_FORWARD_DECLARE_CLASS(AutoFitManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(QRManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractTermStructureManagerController);\n    TB_FORWARD_DECLARE_CLASS(ATMVolTermStructureVerticalShiftDelegateManager);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductValuesHandlerProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentMaturityTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductTableViewProvider);\n    TB_FORWARD_DECLARE_CLASS(ProductGroupCacheSnapshotHandler);\n    TB_FORWARD_DECLARE_CLASS(PersistentPreferencesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(OptionFiltersWatcherProvider);\n    TB_FORWARD_DECLARE_CLASS(ATMStraddlePriceToVolConverterProvider);\n    TB_FORWARD_DECLARE_CLASS(OTMCalculatedValuesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(StrikeMatrixMaturitiesListViewProvider);\n    TB_FORWARD_DECLARE_CLASS(CurrentProductStrikeMatrixViewProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductGridViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(StaticArbitrageCheckerProvider);\n    TB_FORWARD_DECLARE_CLASS(ImpliedVolatilitySourcesManagerProvider);\n    TB_FORWARD_DECLARE_CLASS(HistoricalDataProvider);\n    TB_FORWARD_DECLARE_CLASS(AutoFitRealTimeDiagnosticProvider);\n\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewCoreProvider);\n    TB_FORWARD_DECLARE_CLASS(AbstractCurrentProductVolTuningTableViewProvider);\n\nprotected:\n    IVolatilityManager(const StrategyParameters & parameters, const InitializationReason & reason,\n                       const VolatilityModel volatilityModelType, IVolatilityInterpolator * pVolatilityInterpolator,\n                       AbstractTermStructureManagerController * pTermStructureManagerController);\n\npublic:\n    virtual ~IVolatilityManager();\n\n    const VolatilityModel GetVolatilityModelType() const { return m_volatilityModelType; }\n    VolatilitySurfaceSubscriptionManager & GetVolatilitySurfaceSubscriptionManager() { return m_volatilitySurfaceSubscriptionManager; }\n    NotificationHandler & GetNotificationHandler() const { return m_notificationHandler; }\n    UnderlyingTickRules & GetUnderlyingTickRules() const { return m_underlyingTickRules; }\n    IVolatilityInterpolator & GetVolatilityInterpolator();\n\n    SubStrategiesManager & GetSubStrategiesManager();\n    ValidationProcessor & GetValidationProcessor();\n    ProductGroupCacheProvider & GetProductGroupCacheProvider();\n    CurrentMaturityWatchersManager & GetCurrentMaturityWatchersManager();\n    CurrentProductGroupWatchersManager & GetCurrentProductGroupWatchersManager();\n    InstrumentTradingStatusTracker & GetInstrumentTradingStatusTracker() { return m_instrumentTradingStatusTracker; }\n    AutoFitManager & GetAutoFitManager() { return m_autoFitManager; }\n    QuotingRecommendationManager & GetQuotingRecommendationManager() { return m_quotingRecommendationManager; }\n    ImpliedVolatilitySourcesManager & GetImpliedVolatilitySourcesManager();\n    TermStructureManager & GetTermStructureManager() { return m_termStructureManager; }\n    OptionFiltersWatcher & GetOptionFiltersWatcher() { return m_optionFiltersWatcher; }\n    HighlightingProcessor & GetHighlightingProcessor() { return m_highlightingProcessor; }\n    PersistentPreferencesManager & GetPersistentPreferencesManager() { return m_persistentPreferencesManager; }\n    StrikeMatrixMaturitiesListView & GetStrikeMatrixMaturitiesListView() { return m_currentProductGroupControllerView; }\n    StaticArbitrageChecker & GetStaticArbitrageChecker() { return m_staticArbitrageChecker; }\n    const AutoFitRealTimeDiagnostic & GetAutoFitRealTimeDiagnostic() const { return m_autoFitRealTimeDiagnostic; }\n    MaturityDataExporter & GetMaturityDataExporter() { return m_maturityDataExporter; }\n    CurveQualityMetricsCalculator & GetCurveQualityMetricsCalculator() { return m_curveQualityMetricsCalculator; }\n\n    const PortfolioIdentifier & GetPortfolioIdentifier() const { return m_portfolioId.GetPortfolioIdentifier(); }\n    bool IsPortfolioSubscriptionEnabled() const;\n\n    bool ParallelVerticalShift() const;\n\n    const InstrumentGroup & GetCurrentProductGroup() const { return m_instrumentGroup.GetInstrumentGroup(); }\n    const InstrumentGroup & GetReferenceInstrumentGroup() const { return m_refInstrumentGroup.GetInstrumentGroup(); }\n\n    const InstrumentIdentifier & GetFocusInstrumentIdentifier() const { return m_followedInstrumentId.GetInstrumentIdentifier(); }\n    const Integer & GetFocusInstrumentGroupType() const { return m_instrumentGroupType.GetInteger(); }\n\n    bool NoLayoutInterfaceMode() const { return !m_noLayoutInterfaceMode.Empty() && m_noLayoutInterfaceMode.GetBoolean(); }\n\n    bool GlobalAutoApplyManualFit() const { return !m_globalAutoApplyManualFit.Empty() && m_globalAutoApplyManualFit.GetBoolean(); }\n\n    bool GlobalAutoSuggest() const { return !m_globalAutoSuggest.Empty() && m_globalAutoSuggest.GetBoolean(); }\n\n    int CurveShiftUnits() const;\n\n    bool UseExoticOptions() const { return m_currentProductCommonValuesHandler.UseExoticOptions(); }\n    const CalculatedPropertyFilter & GetInstrumentFilter() const { return m_currentProductCommonValuesHandler.GetInstrumentFilter(); }\n\n    bool IsLiveFeedDisabled() const { return !m_disableLiveFeed.Empty() && m_disableLiveFeed.GetBoolean(); }\n\n<fim-suffix><fim-middle>    const Integer & GetForegroundCalculationThrottlingMilliseconds() { return m_calculationStreamThrottlingMilliseconds.GetInteger(); }"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override;<fim-suffix>void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override;<fim-middle>void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/EventProcessor.h>\n#include <future>\n\nnamespace misc {\n\nclass AsyncProcessor\n{\nprivate:\n    const tbricks::EventProcessor& m_proc;\n    tbricks::StrategyIdentifier m_id;\n    std::string m_result;\n<fim-suffix><fim-middle>public:\n    AsyncProcessor(const tbricks::EventProcessor& proc, const tbricks::StrategyIdentifier& appId) : m_proc(proc), m_id(appId) {};"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } \/\/ fake data for now status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume {0}; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to DE\"); status.SetVenueInstrumentTradingStatus(String()); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo);<fim-suffix>{ InstrumentStatus status; BestPrice bbo; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Unable to open stream to DE\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.PartialUpdate(bbo); m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::SendSnapshotDoneIfNeeded() { TBDEBUG(__func__); if (TB_UNLIKELY(!m_snapshotDone)) { m_mdItem.SendSnapshotDone(); m_snapshotDone =<fim-middle>m_mdItem.Flush(); SendSnapshotDoneIfNeeded(); } void DeribitModel::Fail()"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace<fim-suffix>DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item =<fim-middle>tbricks;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n<fim-suffix><fim-middle>void TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"ReversalManager.h\" class PositionReversalsPlugin : public tbricks::VisualizationApp , public ReversalManager::IHandler { public: PositionReversalsPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~PositionReversalsPlugin() = default; bool CanRun(tbricks::String& error); void DoRun(); void DoPause(); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ VizualizationApp methods void HandleStrategyViewCreate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleStrategyViewUpdate( tbricks::visualization::models::AppViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleStrategyViewDelete( tbricks::visualization::models::AppViewModel& viewModel) final; void HandleGridViewCreate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleGridViewUpdate( tbricks::visualization::models::GridViewModel& viewModel, const tbricks::visualization::ViewModelUpdate& update) final; void HandleGridViewDelete(tbricks::visualization::models::GridViewModel& viewModel) final; \/\/ ReversalManager::IHandler methods void HandleError(const tbricks::String& error) final; void HandlePositionsReversed() final;<fim-suffix><fim-middle>private: ReversalManager m_manager;"}
{"content":"<fim-prefix>#include \"volatility\/VolatilityCurveHandler.h\"\n#include \"PricingPlugin.h\"\n#include \"volatility\/CustomVolatilityModel.h\"\n#include \"shared\/volatility\/InterpolatedVolatilityModel.h\"\n#include <utility>\n\nusing namespace tbricks;\n<fim-suffix><fim-middle>VolatilityCurveHandler::VolatilityCurveHandler(PricingPlugin & plugin\n    , const StreamSettingsPtr & stream_settings_ptr\n    , const InstrumentGroupIdentifier & group\n    , const DateTime & maturity_date)"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n#include <strategy\/stream\/InstrumentStream.h>\n<fim-suffix><fim-middle>class InstrumentManager : public tbricks::InstrumentStream::IHandler\n                        , public tbricks::InstrumentAggregateParameters::Stream::IHandler\n                        , public tbricks::CalculatedInstrumentValues::Stream::IHandler\n                        , public tbricks::IRequestReplyHandler"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n\n    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes\n\n\n    out_header_and_message << static_cast<char>(fin_rsv_opcode);\n\n<fim-suffix><fim-middle>    if (length >= 126)\n    {\n        std::size_t num_bytes;"}
{"content":"<fim-prefix>#include <shared\/volatility\/VolatilityModelTypeMismatchException.h> #include <shared\/volatility\/ClampedCubicSpline.h> #include <shared\/volatility\/StochasticVolatilityInspired.h> #include <shared\/volatility\/WingVolatilityModel.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <shared\/sdk_definitions.h> CLANG_RESTORE_WARNINGS \/\/ Declare the generic cast functions but don't implement them to cause compilation error on attempt to use them with unsupported volatility model types template <class ModelTypePtr> ModelTypePtr vol_model_cast(volatility::IVolatilityModel * pModel); template <class ModelTypePtr> ModelTypePtr vol_model_cast(const volatility::IVolatilityModel * pModel); template <class ModelTypeRef> ModelTypeRef vol_model_cast(volatility::IVolatilityModel & model); template <class ModelTypeRef> ModelTypeRef vol_model_cast(const volatility::IVolatilityModel & model); #define VOL_MODEL_PTR_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model * vol_model_cast(specifier volatility::IVolatilityModel * pModel) \\ { \\ if (TB_UNLIKELY(!pModel)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY(pModel->GetVolatilityModelType() != type)) { \\ TBWARNING(\"Detected attempt to cast volatility model of type \" << pModel->GetVolatilityModelType() << \" to type \" << type); \\ throw volatility::VolatilityModelTypeMismatchException(pModel->GetVolatilityModelType(), type); \\ } \\ \\ return reinterpret_cast<specifier volatility::model*>(pModel); \\ } #define VOL_MODEL_REF_CAST_IMPL(specifier, model, type) \\ template <> \\ inline specifier volatility::model & vol_model_cast(specifier volatility::IVolatilityModel & rModel) \\ { \\ if (TB_UNLIKELY(rModel.GetVolatilityModelType()<fim-suffix><fim-middle>!= type)) { \\"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <strategy\/stream\/InstrumentStream.h> using InstrumentCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::Instrument>; using UnderlyingCache = tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::InstrumentIdentifier>; class InstrumentManager : public tbricks::InstrumentStream::IHandler , public tbricks::InstrumentAggregateParameters::Stream::IHandler , public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::InstrumentGroup& GetInstrumentGroup() = 0; virtual const tbricks::InstrumentIdentifier& GetUnderlyingInstrument() = 0; virtual const tbricks::DateTime& GetMaturityDate() = 0; virtual void HandleImportComplete(const tbricks::String& status) = 0; virtual void HandleInstrumentManagerFailed(const tbricks::String& reason) = 0; }; InstrumentManager(IHandler& handler); ~InstrumentManager(); void Start(); void Stop(); protected: \/\/ Stream::IHandler void HandleStreamOpen(const tbricks::StreamIdentifier& stream) final; void HandleStreamStale(const tbricks::StreamIdentifier& stream) final; void HandleStreamFailed(const tbricks::StreamIdentifier& stream) final; void HandleSnapshotEnd(const tbricks::StreamIdentifier& stream) final; \/\/ InstrumentStream::IHandler void HandleInstrument(const tbricks::StreamIdentifier& stream, const tbricks::Instrument& instrument) final;<fim-suffix>\/\/ InstrumentAggregateParameters::Stream::IHandler void HandleInstrumentAggregateParameters(const tbricks::StreamIdentifier & streamID, const tbricks::InstrumentIdentifier & instrumentID, const tbricks::InstrumentAggregateParameters::Update & update) override; \/\/ IRequestReplyHandler void HandleRequestReply(const tbricks::Identifier& id, tbricks::Status status, const tbricks::String& status_text) final; private: void OpenInstrumentStream(); void OpenIAPStream(); void EnrichInstruments(); void ModifyGroup(); void CheckResolutionStatus(); void<fim-middle>void HandleInstrumentInvalidate(const tbricks::StreamIdentifier& stream, const tbricks::InstrumentIdentifier& id) final {};"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default; \/\/ tbricks::ITimerEventHandler void HandleTimerEvent(tbricks::Timer&<fim-suffix><fim-middle>timer) override; void Update(const tbricks::StrategyParameters& strategyParameters);"}
{"content":"<fim-prefix>UNDER(underlying_price, Price, UnderlyingPrice) UNDER(underlying_bid_price, Price, UnderlyingBidPrice) UNDER(underlying_ask_price, Price, UnderlyingAskPrice) UNDER(underlying_bid_volume_used, Volume, UnderlyingBidVolumeUsed) UNDER(underlying_ask_volume_used, Volume, UnderlyingAskVolumeUsed) UNDER(underlying_market_data_status, Integer, UnderlyingMarketDataStatus) UNDER(underlying_trading_status, Integer, UnderlyingTradingStatus) UNDER(underlying_trading_phase, Integer, UnderlyingTradingPhase) UNDER(underlying_price_source_used, Integer, UnderlyingPriceSourceUsed) UNDER(underlying_price_within_range, Boolean, UnderlyingWithinRange) UNDER(underlying_price_quality, Double, UnderlyingPriceQuality) FAIR(fair_market_price, Price, FairMarketPrice) FAIR(fair_bid_price, Price, FairBidPrice) FAIR(fair_ask_price, Price, FairAskPrice) GREEK(forward_price, Price, ForwardPrice) GREEK(quanto_forward_price, Price, QuantoForwardPrice) GREEK(spot_price, Price, SpotPrice) GREEK(strike_price, Price, StrikePriceInUnderlyingCurrency) GREEK(delta, Double, Delta) GREEK(gamma, Double, Gamma) GREEK(option_equivalent_gamma, Double, OptionEquivalentGamma) GREEK(vega, Double, Vega) GREEK(option_equivalent_vega, Double, OptionEquivalentVega) GREEK(rho, Double, Rho) GREEK(rho_discounting, Double, RhoDiscounting) GREEK(vanna, Double, Vanna) GREEK(vomma, Double, Vomma) GREEK(skew_delta, Double, SkewDelta) GREEK(skew_gamma, Double, SkewGamma) GREEK(calendar_theta, Double, CalendarTheta) GREEK(volatility_theta, Double, VolatilityTheta) GREEK(rate_theta, Double, RateTheta) GREEK(calendar_charm, Double, CalendarCharm) GREEK(calendar_skew_charm, Double, CalendarSkewCharm) GREEK(calendar_color, Double, CalendarColor) GREEK(opening_theta, Double, OpeningTheta) GREEK(opening_charm, Double, OpeningCharm) GREEK(opening_skew_charm, Double, OpeningSkewCharm) GREEK(opening_color, Double, OpeningColor) GREEK(overnight_theta, Double, OvernightTheta) GREEK(overnight_charm, Double, OvernightCharm) GREEK(overnight_skew_charm, Double, OvernightSkewCharm) GREEK(overnight_color, Double, OvernightColor) GREEK(divit, Double, Divit) GREEK(speed, Double, Speed) GREEK(skew_speed, Double, SkewSpeed) GREEK(zomma, Double, Zomma) GREEK(volatility, Double, Volatility) GREEK(at_the_money_volatility, Double, AtTheMoneyVolatility) GREEK(at_the_money_straddle_price, Price, AtTheMoneyStraddlePrice) GREEK(straddle_price, Price, StraddlePrice) GREEK(exercise_boundary_reached, Boolean, ExerciseBoundaryReached) GREEK(exercise_boundary_div_reached, Boolean, ExerciseBoundaryDivReached) GREEK(moneyness, Integer, Moneyness) GREEK(simple_put_moneyness,<fim-suffix><fim-middle>Double, SimplePutMoneyness) GREEK(wing_slope_sensitivity, Double, WingSlopeSensitivity)"}
{"content":"<fim-prefix>#pragma once #include <string_view> #include <strategy\/type\/String.h> namespace deribit { struct RapidDocument; class UpdateData {<fim-suffix>UpdateData(); virtual ~UpdateData(); std::string_view ToString(); void Parse(const tbricks::String& str); protected: RapidDocument* m_doc; }; class ticker_update :<fim-middle>public:"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n<fim-suffix><fim-middle>void DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <optional> struct DeribitInstrument { tbricks::String instrument_name; tbricks::String instrument_type; tbricks::String kind; tbricks::String settlement_currency; tbricks::String settlement_period; tbricks::String quote_currency; tbricks::String counter_currency; tbricks::String option_type; \/\/ \"call\" or \"put\" for options std::optional<tbricks::Double> strike; \/\/ Only for options tbricks::DateTime expiration_timestamp; tbricks::Double tick_size; tbricks::Double contract_size; tbricks::Boolean is_active; \/\/ Constructor that safely extracts data from rapidjson Value static std::optional<DeribitInstrument> FromJson(const rapidjson::Value& value) { DeribitInstrument data; \/\/ Required fields - if any of these are missing, return nullopt if (!value.HasMember(\"instrument_name\") || !value[\"instrument_name\"].IsString() || !value.HasMember(\"kind\") || !value[\"kind\"].IsString() || !value.HasMember(\"settlement_currency\") || !value[\"settlement_currency\"].IsString() || !value.HasMember(\"counter_currency\") || !value[\"counter_currency\"].IsString() || !value.HasMember(\"is_active\") || !value[\"is_active\"].IsBool()) { return std::nullopt; } data.instrument_name = value[\"instrument_name\"].GetString(); data.kind = value[\"kind\"].GetString(); data.settlement_currency = value[\"settlement_currency\"].GetString(); data.counter_currency = value[\"counter_currency\"].GetString(); data.is_active = value[\"is_active\"].GetBool(); \/\/ Optional fields - use safe accessors data.instrument_type = value.HasMember(\"instrument_type\") && value[\"instrument_type\"].IsString() ? value[\"instrument_type\"].GetString() : \"\"; data.quote_currency = value.HasMember(\"quote_currency\") && value[\"quote_currency\"].IsString() ? value[\"quote_currency\"].GetString() : \"\"; data.option_type<fim-suffix>? value[\"option_type\"].GetString() : \"\"; data.settlement_period = value.HasMember(\"settlement_period\") && value[\"settlement_period\"].IsString() ? value[\"settlement_period\"].GetString() :<fim-middle>= value.HasMember(\"option_type\") && value[\"option_type\"].IsString()"}
{"content":"<fim-prefix>#pragma once #include \"DeribitMethods.h\" #include <third_party\/include\/rapidjson\/document.h> #include <third_party\/include\/rapidjson\/writer.h> namespace deribit { class Json { public: virtual ~Json() = default; Json(); Json(Json &&); std::string_view ToString(); std::string_view GetId(); void Parse(std::string_view str); DeribitMethod Parse(std::string_view str, const std::vector<Method> & methods); protected: rapidjson::Document msg; rapidjson::StringBuffer buffer; }; class JsonCall : public Json { public: virtual ~JsonCall() = default; JsonCall(const std::string_view id, DeribitMethod method); }; class JsonReply : public Json { public: struct Error { int code = 0; std::string_view message; rapidjson::Value data; }; public: virtual ~JsonReply() = default; JsonReply(std::string_view json); JsonReply(std::string_view json, const std::vector<Method> & methods); JsonReply(JsonReply &&); bool IsError() const; const Error & GetError() const; bool IsTest() const; const rapidjson::Value & GetResult(); std::string_view GetResultString(); const DeribitMethod GetMethod() const; private: Error err; bool isTest = true; bool isError = false; DeribitMethod jrpcMethod = DeribitMethod::NONE; }; class public_auth : public JsonCall { public: enum class GrantType { CLIENT_CREDENTIALS, CLIENT_SIGNATURE, REFRESH_TOKEN }; public: public_auth(const std::string_view id); void SetGrantType(GrantType type); void SetClientId(const std::string_view val); void SetClientSecret(const std::string_view val); void SetRefreshToken(const std::string_view val); }; class public_set_heartbeat : public JsonCall { public:<fim-suffix><fim-middle>public_set_heartbeat(const std::string_view id);"}
{"content":"<fim-prefix>#pragma once #include <strategy\/stream\/TCPStream.h> #include <random> #include \"BinaryStreamBuffer.h\" #include <simple-websocket-server\/crypto.hpp> #include <simple-websocket-server\/utility.hpp> class IWebsocketHandler { public: virtual ~IWebsocketHandler() = default; virtual void HandleWebsocketConnected() = 0; virtual void HandleWebsocketDisconnected(const tbricks::String & reason) = 0; virtual void HandleError(const tbricks::String & error) = 0; virtual void HandleMessage(std::string_view message) = 0; }; class TbWebsocketClient : public tbricks::TCPStream::IHandler { public: struct Config { \/\/\/ Timeout on request handling. Defaults to no timeout. long timeout_request = 0; \/\/\/ Idle timeout. Defaults to no timeout. long timeout_idle = 0; \/\/\/ Maximum size of incoming messages. Defaults to architecture maximum. \/\/\/ Exceeding this limit will result in a message_size error code and the connection will be closed. std::size_t max_message_size = (std::numeric_limits<std::size_t>::max)(); \/\/\/ Additional header fields to send when performing WebSocket upgrade. \/\/\/ Use this variable to for instance set Sec-WebSocket-Protocol. SimpleWeb::CaseInsensitiveMultimap header; \/\/\/ Set proxy server (server:port) std::string proxy_server; \/\/\/ Set proxy authorization (username:password) std::string proxy_auth; unsigned short default_port = 80; }; public: TbWebsocketClient(IWebsocketHandler & handler, const tbricks::String & host_port_path, const TbWebsocketClient::Config & conf); ~TbWebsocketClient(); void Connect(); void Shutdown(int status = 1000, const std::string & reason = \"\"); \/\/\/ fin_rsv_opcode: 129=one fragment, text, 130=one fragment, binary, 136=close connection. \/\/\/ See http:\/\/tools.ietf.org\/html\/rfc6455#section-5.2 for more information. void SendWs(const tbricks::Binary & buffer, unsigned<fim-suffix>void SendWs(std::string_view out_message_str, unsigned char fin_rsv_opcode = 129); void SendCloseWs(int status, const std::string & reason = \"\"); protected: \/\/TCPStream::IHandler void HandleData(tbricks::TCPStream & stream, const tbricks::Binary &<fim-middle>char fin_rsv_opcode = 129);"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n\n        return true;\n    }\n\n    const char * get_internal_data()\n    {\n        return static_cast<char *>(m_data.GetData());\n    }\n\n    const tbricks::Binary & GetBinary()\n    {\n        return m_data;\n    }\n\n    void SetData(const void * data, size_t size)\n    {\n        m_data.Clear();\n        m_data.Set(data, size);\n    }\n\n    template <typename T>\n    void read(T & t)\n    {\n        if (eof())\n            throw std::runtime_error(\"Premature end of array!\");\n<fim-suffix><fim-middle>        if ((m_index + sizeof(T)) > m_data.GetSize())\n            throw std::runtime_error(\"Premature end of array!\");"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler, visualization::Grid& instrumentsGrid)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_calculatedValuesStream(*this)\n    , m_failed(0)\n    , m_tasksDone(false)\n    , m_instrumentsGrid(instrumentsGrid)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n    m_iapStream.Close();\n    m_calculatedValuesStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n    m_tasksDone = false;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::OpenCIVStream()\n{\n    CalculatedInstrumentValues::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrumentVenueIdentification(InstrumentVenueIdentification(instId));\n    }\n    options.AddValue(calculated_values::UnderlyingPrice());\n\n    auto throttle = MaximumUpdateTimeThrottle(Duration::Seconds(5));\n    options.SetThrottle(throttle);\n    m_calculatedValuesStream.Open(Stream::SNAPSHOT_AND_LIVE, options);\n\n    TBDEBUG(\"Opened calculated instrument values stream : \" << m_calculatedValuesStream.GetIdentifier() << \" with options : \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n        OpenCIVStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n<fim-suffix><fim-middle>    {\n        EnrichInstruments();\n    }\n}"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) :<fim-suffix>{ } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { } Binary_istream(tbricks::Binary && src) : m_data(std::move(src)) , m_index(0) { } Binary_istream(const tbricks::Binary & src) { open(static_cast<const char *>(src.GetData()), src.GetSize()); } void open(const char * mem, size_t size) { m_index = 0; m_data.Clear(); m_data.Resize(size); m_data.Set(mem, size); } void close() { m_data.Clear(); } bool eof() const { return m_index >= m_data.GetSize(); } std::istream::pos_type tellg() { return m_index; } bool seekg(size_t pos) { if (pos < m_data.GetSize()) m_index = pos; else return false; return true; } bool seekg(std::streamoff offset, std::ios_base::seekdir way) { if (way == std::ios_base::beg && offset < m_data.GetSize()) m_index = offset; else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize()) m_index += offset; else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize()) m_index = m_data.GetSize() + offset; else return false; return true; } const char * get_internal_data() { return static_cast<char *>(m_data.GetData()); } const tbricks::Binary & GetBinary() { return m_data; } void SetData(const void<fim-middle>MemStream(static_cast<const char *>(data.GetData()), data.GetSize())"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" class ExampleCalcAppPlugin2 : public tbricks::Pricing { public: ExampleCalcAppPlugin2(const tbricks::PricingRequest & request); void HandlePricingModifyRequest(const tbricks::PricingModifyRequest & request) override; bool HandlePartialPricingModifyRequest(const tbricks::CalculatedValuesRequestUpdate &update) override; private: using RequestAndIVIDs = tbricks::Hash<tbricks::Uuid, tbricks::InstrumentVenueIdentification>; void<fim-suffix>void HandleRunRequest() override {}; void HandlePauseRequest() override {}; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) override {}; void HandleValidateRequest(tbricks::ValidationContext &context) override {}; void<fim-middle>HandleDeleteRequest() override {};"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n<fim-suffix><fim-middle>void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template <> void Binary_istream::read(tbricks::Binary & out) { out = m_data; } template <> void Binary_ostream::write(const tbricks::Binary & in) {<fim-suffix>Binary_ostream & operator<<(Binary_ostream & ostm, const std::string & val) { if (val.size() <= 0) return ostm; ostm.write(val.c_str(), val.size()); return ostm; } Binary_ostream & operator<<(Binary_ostream & ostm, const char * val) { int size = std::strlen(val); if (size <= 0) return ostm; ostm.write(val,<fim-middle>m_data.Append(in); } template <>"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        DateTime tbMaturityDate;\n        instrument.GetAttribute(instrument_attributes::MaturityDate(), tbMaturityDate);\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n<fim-suffix><fim-middle>    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);\n\n    return false;\n}\n\nvoid DeribitMdp::GetDiagnostics(Diagnostics & diagnostics)\n<fim-suffix><fim-middle>{\n    diagnostics.GetDebugStream() << \"Market aggregator diagnostic \";"}
{"content":"<fim-prefix>#include \"BinaryStreamBuffer.h\" template <> Binary_istream & operator>>(Binary_istream & istm, std::string & val) { int size = 0; istm.read(size); if (size <= 0) return istm; istm.read(val, size); return istm; } template<fim-suffix><fim-middle><> void Binary_istream::read(tbricks::Binary & out)"}
{"content":"<fim-prefix>#include \"DeribitProtocol.h\"\n#include <third_party\/include\/rapidjson\/pointer.h>\n#include <algorithm>\n\n#define SET_STRING_VIEW(key, string)                               \\\n    auto & params = msg[\"params\"];                                 \\\n    Value v;                                                       \\\n    v.SetString(string.data(), string.size(), msg.GetAllocator()); \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\n#define SET_INTEGER(key, number)   \\\n    auto & params = msg[\"params\"]; \\\n    Value v;                       \\\n    v.SetInt(number);              \\\n    params.AddMember(#key, v, msg.GetAllocator());\n\nnamespace deribit {\n<fim-suffix><fim-middle>using namespace rapidjson;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy, public tbricks::IDistributionApp, public DeribitClient::IHandler { public: DeribitContributor(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); ~DeribitContributor() noexcept override = default; protected: \/\/ public tbricks::Strategy, public tbricks::IDistributionApp void HandleRunRequest() override; void HandlePauseRequest() override; void HandleDeleteRequest() override; void HandleModifyRequest(const tbricks::StrategyModifier & modifier) override; void HandleValidateRequest(tbricks::ValidationContext & context) override; void HandleDistributedValuesRequest(const tbricks::DistributedValuesRequest & request) override; void HandleDistributedValuesSubscription(const tbricks::DistributedValuesRequest & request) override; \/\/ DeribitClient::IHandler void HandleDeribitConnected() override; void HandleDeribitDisconnected() override; void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) override; private: void FailWithReason(const tbricks::String & reason); std::pair<bool, tbricks::VenueInstrumentIdentifier> ExtractVIID(const tbricks::Instrument & instrument); \/\/ app parameters tbricks::StringParameter m_clientID; tbricks::StringParameter m_clientSecret; tbricks::StringParameter m_endpoint;<fim-suffix><fim-middle>std::unique_ptr<DeribitClient> m_client; tbricks::SparseHash<tbricks::InstrumentIdentifier, tbricks::DistributedValuesRequest> m_requestMap;"}
{"content":"<fim-prefix>#include \"PositionReversalsPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nPositionReversalsPlugin::PositionReversalsPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_manager(*this)\n    , m_portfolio(position_reversals::strategy_parameters::Portfolio())\n    , m_startTime(position_reversals::strategy_parameters::PositionReversalStartTime())\n    , m_priceSource(position_reversals::strategy_parameters::PositionReversalPriceSource())\n    , m_status(position_reversals::strategy_parameters::StatusInformationText())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    SetState(StrategyState::PAUSED);\n\n    if (GetTransactionOperation().IsRun())\n    {\n        DoRun();\n    }\n\n}\n\nbool PositionReversalsPlugin::CanRun(tbricks::String& error)\n{\n    TBDEBUG(__func__);\n\n    if (m_portfolio.GetPortfolioIdentifier().Empty())\n    {\n        error = \"No portfolio selected\";\n        return false;\n    }\n\n    if (m_startTime.GetTime().Empty())\n    {\n        error = \"No start time selected\";\n        return false;\n    }\n\n    if (m_priceSource.GetInteger().Empty())\n    {\n        error = \"No price source selected\";\n        return false;\n    }\n\n    return true;\n}\n\nvoid PositionReversalsPlugin::DoRun()\n{\n    TBDEBUG(__func__);\n\n    SetTransactionPending(StrategyTransactionOperation::STRATEGY_RUN);\n    String error;\n    if (CanRun(error))\n    {\n        m_manager.Start(m_portfolio.GetPortfolioIdentifier(),\n                        m_priceSource.GetInteger(),\n                        m_startTime.GetTime());\n\n        SetState(StrategyState::RUNNING);\n    }\n    else\n    {\n        m_status = error;\n        SetTransactionFail(error);\n    }\n}\n\nvoid PositionReversalsPlugin::DoPause()\n{\n    m_manager.Stop();\n    SetState(StrategyState::PAUSED);\n}\n\nvoid PositionReversalsPlugin::HandleRunRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n    }\n    else\n    {\n        DoRun();\n    }\n}\n\nvoid PositionReversalsPlugin::HandlePauseRequest(void)\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsPaused())\n    {\n        TBDEBUG(\"Already paused\");\n    }\n    else\n    {\n        DoPause();\n    }\n}\n\nvoid PositionReversalsPlugin::HandleDeleteRequest(void)\n{\n    TBDEBUG(__func__);\n    DoPause();\n    SetState(StrategyState::DELETED);\n}\n\nvoid PositionReversalsPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n{\n    TBSTATUS(__func__ << \" modifier: \" << modifier);\n\n    GetParameters().Merge(modifier.GetParameters());\n    MergeAttributes(modifier.GetAttributes());\n}\n\nvoid PositionReversalsPlugin::HandleValidateRequest(ValidationContext &context)\n{\n    TBDEBUG(__func__ << \" constext:\"  << context);\n\n    context.SendReply();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewCreate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewUpdate(\n        visualization::models::AppViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \", update: \" << update);\n\n    m_status = \"\";\n    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n}\n\nvoid PositionReversalsPlugin::HandleStrategyViewDelete(visualization::models::AppViewModel& viewModel)\n{\n    TBDEBUG(__func__);\n}\n\nvoid PositionReversalsPlugin::HandleGridViewUpdate(visualization::models::GridViewModel& viewModel, const visualization::ViewModelUpdate& update)\n{\n    TBDEBUG(__func__ << \" update = \" << update);\n<fim-suffix><fim-middle>    viewModel.MergeUpdate(update);\n    viewModel.ApplyModifications();\n    viewModel.RejectUnconfirmedModifications();\n}"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n<fim-suffix><fim-middle>{\n    Shutdown(1000, \"Destructor called\");\n}"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionRetriever : public tbricks::PositionStream::IHandler { public: class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId); void Stop(); \/\/ Common Stream methods void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final; void HandleStreamStale(const tbricks::StreamIdentifier &stream) final;<fim-suffix>void HandleSnapshotEnd(const tbricks::StreamIdentifier &stream) final; \/** * PositionStream::IHandler *\/ void HandlePosition(const tbricks::StreamIdentifier & stream_id, const tbricks::Position & position) final; void HandlePositionInvalidate( const tbricks::StreamIdentifier & stream_id, const tbricks::Identifier & id) final; private: IHandler& m_callback; tbricks::PositionStream m_positionStream; bool m_wasStreamStale{false}; std::map<tbricks::Identifier, tbricks::Position><fim-middle>void HandleStreamFailed(const tbricks::StreamIdentifier &stream) final;"}
{"content":"<fim-prefix>#include \"PositionReverser.h\" #include \"tbricks_definitions.h\" #include <cmath> using namespace tbricks; void PositionReverser::ReversePosition( const Position& position, const Price& atPrice) { Trade reversedTrade; Volume netPosition = position.GetNetPosition(); if (netPosition > 0) { reversedTrade.SetSide(Side::SELL); } else { reversedTrade.SetSide(Side::BUY); } reversedTrade.SetPrice(atPrice); reversedTrade.SetType(TradeType::POSITION_ADJUSTMENT); reversedTrade.SetCurrency(position.GetCurrency()); reversedTrade.SetClient(position.GetClient()); reversedTrade.SetVolume(std::fabs(position.GetNetPosition())); reversedTrade.SetCounterpart(position.GetCounterpart()); Trade::RequestResult reqCreate = Trade::SendCreateRequest(reversedTrade, *this); m_reversedPositions[reqCreate.GetRequestIdentifier()] = position.GetIdentifier(); TBDEBUG(\"Requested to reverse position: \" << position.GetIdentifier() << \" with trade: \" << reqCreate.GetTradeIdentifier()); } void PositionReverser::HandleRequestReply(const tbricks::Identifier & id, tbricks::Status status, const tbricks::String & status_text) { TBDEBUG(__func__ << \" \" << id << \" with status \" << status << \" \" << status_text); auto iterCreate = m_reversedPositions.find(id); bool isCreateRequest = (iterCreate != m_reversedPositions.end()); if (not isCreateRequest) { TBDEBUG(\"Received unknow request reply.\"); return; } if (status == Status::FAIL) {<fim-suffix><fim-middle>TBWARNING(\"Could not reverse position: \" << iterCreate->second << \" reason: \" << status_text);"}
{"content":"<fim-prefix>#include \"DeribitClient.h\"\n#include \"DeribitProtocol.h\"\n#include <strategy\/Logger.h>\n#include <algorithm>\n\nusing namespace tbricks;\n\nbool DeribitClient::Session::IsExpired() const\n{\n    return DateTime::Now() > expires_datetime;\n}\n\nvoid DeribitClient::Session::SetExpires(int seconds)\n{\n    expires = seconds;\n    expires_datetime = DateTime::Now() + Duration::Seconds(expires.GetInt());\n}\n<fim-suffix><fim-middle>void DeribitClient::Session::Reset()\n{\n    connected = false;\n    logged_in = false;"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\"\n#include \"..\/VolatilityManagerSettings.h\"\n#include \"..\/ImpliedVolatilitySourcesManagerCore.h\"\n#include \"..\/..\/preferences_editor\/tbricks_definitions.h\" \/\/ FIXME: Remove when cp definitions are generated for shared\/system meta (TB-103467)\n#include <shared\/Macros.h>\nSUPPRESS_SF_API_CLANG_WARNINGS\n#include <strategy\/type\/String.h>\n#include <strategy\/Instrument.h>\n#include <strategy\/Definitions.h>\n#include <strategy\/Logger.h>\n#include <shared\/sdk_definitions.h>\nCLANG_RESTORE_WARNINGS\n#include <iostream>\n#include <cmath>\n\nconst CalculatedPropertyFilter PreferencesStorage::dummyFilter = CalculatedPropertyFilter::Condition(\n    vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::NE, Integer());\n\nPreferencesStorage::PreferencesStorage() :\n    autoFit(false),\n    autoApplyAutoFit(false),\n    globalAvoidExtraFits(true),\n    globalUnderlyingTradingStatusTracking(true),\n    optionTradingStatusTracking(volatility_manager_settings::DEFAULT_AUTO_FIT_OPTION_TRADING_STATUS_TRACKING),\n    loggingMode(enumerations::VolatilityManagerLoggingModeVerbose),\n    maxAllowedFitRejects(),\n    maturityExcludedFromGlobalActions(false),\n    sendQuotingRecommendations(false),\n    quotingRecommendations(),\n    parallelShift(true),\n    curveShiftUnits(enumerations::VolatilityManagerCurveShiftUnitsVolatility),\n    ATMVolatilityShiftMode(ATM_VolatilityShiftModeShiftSingleATM_Point),\n    includeExoticOptions(volatility_manager_settings::DEFAULT_USE_EXOTIC_OPTIONS_OPTION),\n    autoFetchATMVolatilityPath(false),\n    globalAutoFetchATMVolatilityPath(volatility_manager_settings::DEFAULT_ATM_VOL_PATH_AUTO_FETCH_OPTION),\n    instrumentGroupType(VolatilityManagerInstrumentGroupTypeDerivative),\n    suggestContext(parameter_contexts::VM_Suggest()),\n    trackingAreaType(enumerations::VolatilityManagerTrackingAreaTypeBasedOnAllStrikes),\n    volatilityCurveSafetyCheckEnabled(false),\n    safetyParameterChange(volatility_manager_settings::DEFAULT_SAFETY_PARAMETERS_CHANGES),\n    safetyModelChange(volatility_manager_settings::DEFAULT_SAFETY_MODEL_CHANGES),\n    checkForStaticArbitrage(false),\n    calendarSpreadArbitrageTolerance(volatility_manager_settings::DEFAULT_CALENDAR_SPREAD_ARBITRAGE_TOLERANCE),\n    butterflyArbitrageTolerance(volatility_manager_settings::DEFAULT_BUTTERFLY_ARBITRAGE_TOLERANCE),\n    enableCurveQualityMetrics(false),\n    fitWeighting(FitWeightingInvertedSpread),\n    autocorrectFitWeights(true),\n    fitOnlyATMVol(false),\n    addVirtualBids(volatility_manager_settings::DEFAULT_ADD_VIRTUAL_BIDS),\n    virtualBidRatio(volatility_manager_settings::DEFAULT_VIRTUAL_BID_MULTIPLIER),\n    robustFittingOnWings(false),\n    robustFittingOnWingsStrength(volatility_manager_settings::DEFAULT_ROBUST_FITTING_ON_WINGS_STRENGTH),\n    autoResetSwimRefPriceToATM(false),\n    crossingProcessing(tbricks::enumerations::VolatilityManagerCrossingProcessingSkip),\n    anomalyDetection(false),\n    anomalyDetectionSensitivity(volatility_manager_settings::DEFAULT_ANOMALY_DETECTION_SENSITIVITY),\n    enableAmerican(true),\n    enableATM(true),\n    enableDeepITM(true),\n    enableDeepOTM(true),\n    enableEuropean(true),\n    enableITM(true),\n    enableCashDelivery(true),\n    enableCrossings(true),\n    enableLowBids(true),\n    enablePhysicalDelivery(true),\n    enableSmallDelta(true),\n    enableWideSpreads(true),\n    enableNoSpreads(true),\n    enableOTM(true),\n    enableLowVolumes(true),\n    minimumBidPrice(),\n    minimumVolume(),\n    manuallyToggledPoints(),\n    impliedVolatilitySources(),\n    tradingPhaseProcessing(enumerations::VolatilityManagerTradingPhaseProcessingAllTradingPhases),\n    showExcludedPoints(volatility_manager_settings::DEFAULT_SHOW_EXCLUDED_VOL_POINTS),\n    autocorrectVolatilityChartZooming(true),\n    deltaValueForVerticalLines(volatility_manager_settings::DEFAULT_DELTA_VALUE_FOR_VERTICAL_LINES),\n    showVerticalLinesAtGivenDelta(volatility_manager_settings::DEFAULT_SHOW_VERTICAL_LINES_AT_DELTA),\n    volatilityCurveChartAutoRangePadding(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_PADDING),\n    portfolio(),\n    preserveZooming(volatility_manager_settings::DEFAULT_PRESERVE_ZOOMING_OPTION),\n    distanceBetweenCurvePoints(volatility_manager_settings::CHART_DEFAULT_CURVE_DISTANCE_BETWEEN_DRAWN_POINTS),\n    autoRangeMode(volatility_manager_settings::CHART_DEFAULT_AUTO_RANGE_MODE),\n    showReferenceVols(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_VOLS),\n    showReferenceCurve(volatility_manager_settings::DEFAULT_SHOW_REFERENCE_CURVE),\n    showBidAskRange(volatility_manager_settings::DEFAULT_SHOW_BID_ASK_RANGE),\n    putCallColors(enumerations::VolatilityManagerPut_DIV_CallColorsDefault),\n    colorScheme(enumerations::VolatilityManagerChartColorSchemePale)\n{\n    Table impliedVolSources;\n    ImpliedVolatilitySourcesManagerCore::SetupTable(impliedVolSources, \/* useTreeNodes = *\/ true);\n    impliedVolatilitySources.SetDefault(impliedVolSources);\n\n    m_scopeLevelAnchoredPreferences = {\n        tree_node_parameters::VolatilityManagerAutomaticFit(),\n        tree_node_parameters::VolatilityManagerAutoApplyAutoFit(),\n        tree_node_parameters::VolatilityManagerAutoResetSwimReferencePrice(),\n        tree_node_parameters::VolatilityManagerMaturityExcluded(),\n        tree_node_parameters::VolatilityManagerManuallyToggledVolatilityPoints()\n    };\n\n    CalculatedPropertyFilter defaultInstrumentFilter = CalculatedPropertyFilter::Condition(\n        vmpe::calculated_properties::instrument::CFI_Variant(), Filter::Relation::EQ, Enumeration(Instrument::CFI_Variant::Undefined));\n\n    instrumentFilter.SetDefault(defaultInstrumentFilter);\n}\n\nPreferencesStorage::~PreferencesStorage()\n<fim-suffix><fim-middle>{}"}
{"content":"<fim-prefix>#include \"TbOrderMinion.h\"\n#include \"shared\/order_minion\/OrderMinionCancelRequest.h\"\n#include \"shared\/order_minion\/tbricks_definitions.h\"\n#include \"shared\/sdk_definitions.h\"\n\nusing namespace tbricks;\n\nnamespace execution {\n\nTbOrderMinion::TbOrderMinion(IExecutionHandler& handler, Strategy& app, const InitializationReason & reason, const StrategyParameters & parameters)\n: OrderExecutor(handler)\n, m_controller( reason, app)\n{\n    TBDEBUG(__func__);\n\n}\n\nTbOrderMinion::~TbOrderMinion()\n{\n    TBDEBUG(__func__);\n    DeleteOrders();\n}\n\nvoid TbOrderMinion::CreateOrder(\n        const InstrumentVenueIdentification& ivid,\n        const Volume& volume, \/\/ negative for sell\n        const PortfolioIdentifier& portfolio)\n{\n    TBDEBUG(__func__ << \" : ivid=\" << ivid << \", volume=\" << volume << \", portfolio=\" << portfolio);\n\n    OrderMinionRequest req(this);\n    req.SetExecution(enumerations::OrderMinionExecutionHitRepeatedly);\n    req.SetIVID(ivid);\n    req.SetMarketDataIVID(ivid);\n    req.SetPortfolio(portfolio);\n    req.SetSide((volume > 0.0 ? Side::BUY : Side::SELL));\n    req.SetVolume(volume.Abs());\n    req.SetPriceMode(enumerations::OrderMinionPrice::OrderMinionPriceBestPossible);\n<fim-suffix><fim-middle>    auto result = m_controller.Request(req);\n    if (result == OrderMinionController::FAILURE)\n    {\n        m_handler.PanicStop(result.GetError());"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \"<fim-suffix>{<fim-middle><< item); } bool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)"}
{"content":"<fim-prefix>#pragma once #include \"TbWebsocketClient.h\" #include \"DeribitMethods.h\" #include <strategy\/type\/DateTime.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/String.h> #include <shared\/Hash.h> #include <unordered_map> #include <strategy\/Timer.h> enum class DeribitHost { DERIBIT_TEST, DERIBIT_PROD, NONE }; static std::string Resolve(DeribitHost e) { switch (e) { case DeribitHost::DERIBIT_TEST: return \"test.deribit.com\"; case DeribitHost::DERIBIT_PROD: return \"www.deribit.com\"; default: return {}; } } namespace deribit { class JsonCall; class JsonReply; } \/\/ namespace deribit struct SingleTransaction { tbricks::Identifier id; DeribitMethod method =<fim-suffix><fim-middle>DeribitMethod::NONE; std::unique_ptr<deribit::JsonCall> call; std::unique_ptr<deribit::JsonReply> reply;"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n\nusing namespace tbricks;\n\nTbWebsocketClient::TbWebsocketClient(IWebsocketHandler & handler, const String & host_port_path, const TbWebsocketClient::Config & conf)\n    : m_handler(handler)\n    , m_tcp(*this)\n    , m_config(conf)\n{\n    TBDEBUG(__func__ << \" : \" << host_port_path << \" (default port \" << conf.default_port << \")\");\n    std::string temp(host_port_path.GetCString());\n    auto host_port_end = temp.find('\/');\n    auto host_port = parse_host_port(temp.substr(0, host_port_end), conf.default_port);\n    host = std::move(host_port.first);\n    port = host_port.second;\n\n    if (host_port_end != std::string::npos)\n        path = temp.substr(host_port_end);\n    else\n        path = \"\/\";\n}\n\nTbWebsocketClient::~TbWebsocketClient()\n{\n    Shutdown(1000, \"Destructor called\");\n}\n\nvoid TbWebsocketClient::Connect()\n{\n    std::pair<std::string, std::string> host_port;\n    if (m_config.proxy_server.empty())\n        host_port = {host, std::to_string(port)};\n    else\n    {\n        auto proxy_host_port = parse_host_port(m_config.proxy_server, 8080);\n        host_port = {proxy_host_port.first, std::to_string(proxy_host_port.second)};\n    }\n    TBDEBUG(__func__ << \" - \" << host << \":\" << port);\n    m_tcp.Connect(host, port);\n}\n\nvoid TbWebsocketClient::Shutdown(int status, const std::string & reason)\n{\n    TBDEBUG(__func__ << \" : status=\" << status << \" - reason=\" << reason);\n    if (m_tcp.IsOpen())\n    {\n        SendCloseWs(status, reason);\n        m_tcp.Close();\n    }\n    m_handshake_done = false;\n    m_handler.HandleWebsocketDisconnected(reason);\n}\n\nstd::pair<std::string, unsigned short> TbWebsocketClient::parse_host_port(const std::string & host_port, int64_t default_port) const noexcept\n{\n    std::pair<std::string, unsigned short> parsed_host_port;\n    std::size_t host_end = host_port.find(':');\n    if (host_end == std::string::npos)\n    {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = static_cast<unsigned short>(default_port);\n    }\n    else\n    {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        try\n        {\n            parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n        }\n        catch (...)\n        {\n            parsed_host_port.second = default_port;\n        }\n    }\n    return parsed_host_port;\n}\n\nvoid TbWebsocketClient::SendWs(const Binary & buffer, unsigned char fin_rsv_opcode)\n{\n    std::array<unsigned char, 4> mask;\n    std::uniform_int_distribution<unsigned short> dist(0, 255);\n    for (std::size_t c = 0; c < 4; c++)\n        mask[c] = static_cast<unsigned char>(dist(m_rd));\n<fim-suffix><fim-middle>    std::size_t length = buffer.GetSize();\n    Binary_ostream out_header_and_message;\n    std::size_t max_additional_bytes = 14; \/\/ ws protocol adds at most 14 bytes"}
{"content":"<fim-prefix>#pragma once #include \"OrderExecutor.h\" #include \"shared\/order_minion\/OrderMinionController.h\" #include \"shared\/order_minion\/OrderMinionRequest.h\" namespace execution { class TbOrderMinion : public OrderExecutor, public OrderMinionRequest::IHandler { public: TbOrderMinion(IExecutionHandler& handler, tbricks::Strategy& app, const tbricks::InitializationReason& reason, const tbricks::StrategyParameters& parameters); ~TbOrderMinion(); \/\/ OrderExecutor void DeleteOrders() override; void CreateOrder( const tbricks::InstrumentVenueIdentification& ivid, const tbricks::Volume& volume, \/\/ negative<fim-suffix><fim-middle>for sell const tbricks::PortfolioIdentifier& portfolio) override;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n<fim-suffix><fim-middle>    {\n        m_plugInStatusDescription.Clear();"}
{"content":"<fim-prefix>#include \"DeribitMdp.h\" #include \"tbricks_definitions.h\" using namespace tbricks; DeribitMdp::DeribitMdp() { TBDEBUG(\"Constructor: \" << GetVenueIdentifier()); } void DeribitMdp::HandleSubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleUnsubscribe(MarketDataItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item) { TBDEBUG(__func__ << \", item = \" << item); } void DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)<fim-suffix><fim-middle>{ TBDEBUG(__func__ << \", item = \" << item);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <third_party\/include\/rapidjson\/document.h> #include <deribit\/DeribitInstrument.h> class InstrumentManager : public tbricks::InstrumentStream::IHandler, public tbricks::IRequestReplyHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual const tbricks::VenueIdentifier & GetVenueIdentifier() const = 0; virtual void HandleInstrumentManagerReady() = 0; virtual void HandleInstrumentCreated(const tbricks::InstrumentIdentifier & id) = 0; virtual void HandleInstrumentError(const tbricks::String & error) = 0; }; explicit InstrumentManager(IHandler & handler); ~InstrumentManager() override; \/\/ Add instruments from Deribit void AddInstrument(const std::shared_ptr<DeribitInstrument> & deribitInstrument); \/\/ Core functionality void Start(); void SyncInstruments(); void Clear(); bool IsReady() const { return m_instrumentStream.IsSnapshotDone(); } protected: \/\/ Common stream callbacks void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ Instrument::Stream callbacks void HandleInstrument(const tbricks::StreamIdentifier & stream, const tbricks::Instrument & instrument) override; void HandleInstrumentInvalidate(const tbricks::StreamIdentifier & stream, const tbricks::InstrumentIdentifier & id) override; \/\/ IRequestReplyHandler callback void HandleRequestReply(const tbricks::Identifier & request_id, tbricks::Status status, const tbricks::String & status_text) override; private: \/\/ Helper<fim-suffix><fim-middle>functions void OpenInstrumentStream(); static tbricks::String GetInstrumentKey(const tbricks::Instrument & instrument);"}
{"content":"<fim-prefix>#pragma once #include \"DeribitModel.h\" #include <shared\/API.h> class DeribitMdp : public tbricks::MarketDataProvider, public tbricks::DistributedValues::Stream::IHandler { public: DeribitMdp(); ~DeribitMdp() noexcept override = default; protected: \/\/ MarketDataProvider void HandleSubscribe(tbricks::MarketDataItem & item) override; void HandleUnsubscribe(tbricks::MarketDataItem & item) override; void HandleOrderBookSubscribe(tbricks::OrderBookItem & item) override; void HandleOrderBookUnsubscribe(tbricks::OrderBookItem & item) override; bool IsMarketDataSupported(const tbricks::InstrumentVenueIdentification & ivid) override; void GetDiagnostics(tbricks::Diagnostics & diagnostics) override; \/\/ Stream void HandleStreamOpen(const tbricks::StreamIdentifier & stream) override; void HandleStreamStale(const tbricks::StreamIdentifier & stream) override; void HandleStreamFailed(const tbricks::StreamIdentifier & stream) override; void HandleSnapshotEnd(const tbricks::StreamIdentifier & stream) override; \/\/ DistributedValues Stream IHandler void HandleDistributedValues(const tbricks::StreamIdentifier & stream_id, const tbricks::DistributedValues::Update & update) override; std::optional<DeribitModel *> GetModel(const tbricks::StreamIdentifier & stream); std::optional<DeribitModel *> GetModel(const tbricks::InstrumentIdentifier & instrument); private: std::map<tbricks::StreamIdentifier, tbricks::InstrumentIdentifier> m_streams; std::map<tbricks::InstrumentIdentifier,<fim-suffix><fim-middle>DeribitModel> m_models; };"}
{"content":"<fim-prefix>#include \"PreferencesStorage.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" #include <shared\/Macros.h> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/Exception.h> #include <strategy\/Logger.h> CLANG_RESTORE_WARNINGS #include <sstream> using namespace tbricks; class BadPreferencesStorageCast: public Exception { private: static String PreferenceKindsToString(const PreferencesStorageKind from, const PreferencesStorageKind to) { std::stringstream sstrm; sstrm << \"BadPreferencesStorageCast: from = \" << from << \", to = \" << to; return std::move(sstrm).str(); } public: BadPreferencesStorageCast(const PreferencesStorageKind from, const PreferencesStorageKind to) : Exception(PreferenceKindsToString(from, to)) {} }; template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(PreferencesStorage * pPreferencesStorage); template <class PreferencesStoragePtr> PreferencesStoragePtr pref_storage_cast(const PreferencesStorage * pPreferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(PreferencesStorage & preferencesStorage); template <class PreferencesStorageRef> PreferencesStorageRef pref_storage_cast(const PreferencesStorage & preferencesStorage); #define PREFERENCES_STORAGE_PTR_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type * pref_storage_cast(specifier PreferencesStorage *<fim-suffix>{ \\ if (TB_UNLIKELY(!pPreferencesStorage)) { \\ return nullptr; \\ } \\ \\ if (TB_UNLIKELY((pPreferencesStorage->GetKind() != kind) && (kind != PreferencesStorageKind::Common))) { \\ throw BadPreferencesStorageCast(pPreferencesStorage->GetKind(), kind); \\ } \\ \\ return reinterpret_cast<specifier type*>(pPreferencesStorage); \\ } #define PREFERENCES_STORAGE_REF_CAST_IMPL(specifier, type, kind) \\ template <> \\ inline specifier type<fim-middle>pPreferencesStorage) \\"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/type\/Binary.h>\n#include <cstring>\n\nclass MemBuf : public std::basic_streambuf<char>\n{\npublic:\n    MemBuf(const char * p, size_t l)\n    {\n        setg((char *) p, (char *) p, (char *) p + l);\n    }\n};\n\nclass MemStream : public std::istream\n{\npublic:\n    MemStream(const char * p, size_t l)\n        : std::istream(&_buffer)\n        , _buffer(p, l)\n    {\n        rdbuf(&_buffer);\n    }\n\n    MemStream(const tbricks::Binary & data)\n        : MemStream(static_cast<const char *>(data.GetData()), data.GetSize())\n    {\n    }\n\nprivate:\n    MemBuf _buffer;\n};\n\nclass Binary_istream\n{\npublic:\n    Binary_istream()\n        : m_index(0)\n    {\n    }\n    Binary_istream(tbricks::Binary && src)\n        : m_data(std::move(src))\n        , m_index(0)\n    {\n    }\n    Binary_istream(const tbricks::Binary & src)\n    {\n        open(static_cast<const char *>(src.GetData()), src.GetSize());\n    }\n    void open(const char * mem, size_t size)\n    {\n        m_index = 0;\n        m_data.Clear();\n        m_data.Resize(size);\n        m_data.Set(mem, size);\n    }\n    void close()\n    {\n        m_data.Clear();\n    }\n    bool eof() const\n    {\n        return m_index >= m_data.GetSize();\n    }\n    std::istream::pos_type tellg()\n    {\n        return m_index;\n    }\n    bool seekg(size_t pos)\n    {\n        if (pos < m_data.GetSize())\n            m_index = pos;\n        else\n            return false;\n\n        return true;\n    }\n    bool seekg(std::streamoff offset, std::ios_base::seekdir way)\n    {\n        if (way == std::ios_base::beg && offset < m_data.GetSize())\n            m_index = offset;\n        else if (way == std::ios_base::cur && (m_index + offset) < m_data.GetSize())\n            m_index += offset;\n        else if (way == std::ios_base::end && (m_data.GetSize() + offset) < m_data.GetSize())\n            m_index = m_data.GetSize() + offset;\n        else\n            return false;\n<fim-suffix><fim-middle>        return true;\n    }"}
{"content":"<fim-prefix>#include \"DeribitModel.h\" #include \"tbricks_definitions.h\" #include <deribit\/DeribitSubscriptionUpdates.h> using namespace tbricks; DeribitModel::DeribitModel(MarketDataItem & item, DistributedValues::Stream::IHandler & handler) : m_stream(handler) , m_mdItem(item) { DistributedValues::Stream::Options options; StrategyParameters objectParams; InstrumentStatus status; auto instrument_id = m_mdItem.GetInstrumentVenueIdentification().GetInstrumentIdentifier(); objectParams.SetParameter(strategy_parameters::Instrument(), instrument_id); options.AddObject(objectParams); m_tickerId = options.AddValue(deribit_mdp::distributed_values::DeribitTicker(), {}); m_stream.Open(Stream::Type::SNAPSHOT_AND_LIVE, options); status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusUnknown); status.SetVenueInstrumentMarketDataStatus(\"Waiting FX value\"); status.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); m_mdItem.PartialUpdate(status); m_mdItem.Flush(); } void DeribitModel::HandleDistributedValuesUpdate(const DistributedValues::Update & update) { TBDUMP(update); BestPrice bbo; InstrumentStatus status; Statistics stats; for (auto i = update.begin(); i != update.end(); ++i) { ApplyDistributedValueUpdate(i.GetIdentification(), i, bbo, status, stats); } TBDUMP(bbo); m_mdItem.PartialUpdate(bbo); if (not stats.Empty()) { m_mdItem.PartialUpdate(stats); } if (not status.Empty()) { TBDUMP(status); m_mdItem.PartialUpdate(status); } m_mdItem.Flush(); } void DeribitModel::ApplyDistributedValueUpdate(const DistributedValueIdentification & id, const DistributedValues::Update::Iterator & it, BestPrice & bbo, InstrumentStatus & iStatus, Statistics & stats) { String value; it.GetValue(value); TBSTATUS(__func__ << \": id=\" << id << \", value=\" << value); if (id.second != m_tickerId) { TBDEBUG(\"Received an update on stream: \" << m_stream.GetIdentifier() << \" for unknown DV: \" << id); return; } if (value.Empty() or (value == \"{}\") or value.HasError()) { Price emptyPrice; Volume emptyVolume {0}; iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); iStatus.SetVenueInstrumentMarketDataStatus(\"Empty data from DE app - unsubscribed\"); iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseUnknown); bbo.SetAskPrice(emptyPrice); bbo.SetBidPrice(emptyPrice); bbo.SetAskVolume(emptyVolume); bbo.SetBidVolume(emptyVolume); return; } iStatus.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusOk); iStatus.SetVenueInstrumentMarketDataStatus(\"OK\"); deribit::ticker_update update(value); \/\/ Handle the trading phase if (update.IsOpen())<fim-suffix>iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingAllowed); } else { iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseClosed); iStatus.SetInstrumentTradingStatus(InstrumentStatus::InstrumentTradingStatusTradingNotAllowed); } \/\/ BBO bbo.SetAskPrice(update.GetAsk()); bbo.SetBidPrice(update.GetBid()); bbo.SetAskVolume(update.GetAskVolume()); bbo.SetBidVolume(update.GetBidVolume()); auto millis = update.GetTimestamp(); DateTime timestamp = DateTime::Now(); if (millis > 0) { timestamp = DateTime::Create(millis \/ 1000); } bbo.SetExchangeModifiedDatetime(timestamp); \/\/ Statistics stats.SetLastPrice(update.GetLastPrice()); stats.SetOpenInterest(update.GetOpenInterest()); stats.SetDailySettlementPrice(update.GetSettlementPrice()); stats.SetHighPrice(update.GetMaxPrice()); stats.SetLowPrice(update.GetMinPrice()); } void DeribitModel::Reset() { InstrumentStatus status; BestPrice bbo; Price emptyPrice; Volume emptyVolume; status.SetInstrumentMarketDataStatus(InstrumentStatus::InstrumentMarketDataStatusStale); status.SetVenueInstrumentMarketDataStatus(\"Lost connection to<fim-middle>{ iStatus.SetInstrumentTradingPhase(InstrumentStatus::InstrumentTradingPhaseTrading);"}
{"content":"<fim-prefix>#include <shared\/sdk_definitions.h> #include <cstddef> using std::size_t; namespace volatility_model_constants { const size_t EXCLUDE_VOLATILITY_POINTS_MIN_NUMBER_THRESHOLD = 5; const double EXCLUDE_VOLATILITY_POINTS_RELATIVE_BOUND_FOR_VOLATILITY_POINTS_STRIKES_SET = 0.5; const double EXCLUDE_VOLATILITY_POINTS_WEIGHT_RATIO_THRESHOLD = 3.0; const double VM_MINIMAL_VOLATILITY_LEVEL = 1.0e-4; const double VM_MINIMAL_FORWARD_VALUE = 1.0e-4; const double VM_MINIMAL_VOLATILITY_VALUE = 0.9e-4; const double VM_COMPARISON_TOLERANCE = 1.0e-9; const double VM_MINIMUM_ACCEPTABLE_DELTA_DIFFERENCE = 0.1; const double VM_ACCEPTABLE_DELTA_DIFFERENCE = 0.005; const double VM_MINIMUM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.1; \/\/ This translates to 10% const double VM_ACCEPTABLE_STRIKE_RELATIVE_DIFFERENCE = 0.005; \/\/ This translates to .5% const double VM_MINIMAL_VOLATILITY_TIME = 0.0; const double VM_DEFAULT_SWIM_CORRELATION = 1.0; const double VM_MAXIMAL_PERCENTAGE = 1.0; const double VM_MINIMAL_PERCENTAGE = 0.0; const double VM_DEFAULT_ATM_VOLATILITY = 0.2; const double VM_DEFAULT_FORWARD_PRICE = 100.0; const double VM_DEFAULT_VOLATILITY_TIME = 1.0; const double VM_MINIMAL_FORWARD_PRICE = 0.0; const double VM_MINIMAL_SWIM_REFERENCE_PRICE = VM_MINIMAL_FORWARD_PRICE; const double VM_MONEYNESS_MULTIPLIER_FOR_FIT_TO_ATM_ONLY = 10.0; const size_t ATM_VOL_PATH_MINIMAL_NUMBER_OF_POINTS_TO_FETCH = 5; const size_t MINIMAL_NUMBER_OF_POINTS_TO_SHIFT_WINGS = 4; const size_t WING_MODEL_NUMBER_OF_NONLINEAR_FIT_PARAMS = 9; const double WING_MODEL_MINIMAL_CUTOFF_VALUE = 0.01; const double WING_MODEL_MINIMAL_CUTOFF_UP_VALUE = WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_UP_VALUE = 0.5; const double WING_MODEL_MAXIMAL_CUTOFF_DOWN_VALUE = -WING_MODEL_MINIMAL_CUTOFF_VALUE; const double WING_MODEL_DEFAULT_CUTOFF_DOWN_VALUE = -0.5; const double WING_MODEL_CUTOFF_DOWN_BORDER = -WING_MODEL_MINIMAL_CUTOFF_VALUE + VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_UP_BORDER = WING_MODEL_MINIMAL_CUTOFF_VALUE - VM_COMPARISON_TOLERANCE; const double WING_MODEL_CUTOFF_TOLERANCE_MULT = 1.00000001; const double WING_MODEL_MINIMAL_SMOOTH_VALUE = 0.01; const double WING_MODEL_DEFAULT_SMOOTH_VALUE = 0.2; const double WING_MODEL_MULTIPLIER_FOR_RMSE_COMPARISON = 0.995; const double WING_MODEL_DEFAULT_ATM_SLOPE = 0.0; const double WING_MODEL_DEFAULT_CALL_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_CALL_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PUT_CURVATURE = 1.0; const double WING_MODEL_MINIMAL_PUT_CURVATURE = 0.0; const double WING_MODEL_DEFAULT_PENAL_PARAM_GAMMA = 0.95; const int WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE = tbricks::enumerations::WingVolatilityManagerRef_EQUAL_ATM_Mode::WingVolatilityManagerRef_EQUAL_ATM_ModeMoveTheCurveHorizontally; const double WING_MODEL_DEFAULT_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MAX_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 1.0; const double WING_MODEL_MIN_REF_EQUAL_ATM_MODE_APPROXIMATION_RANGE = 0.1; const double CCS_MODEL_MINIMAL_STRIKE = 1.0e-6; const double CCS_MODEL_MINIMAL_SMOOTHNESS = 0.0; const double CCS_MODEL_DEFAULT_SMOOTHNESS = 1.0; const int CCS_MODEL_MINIMAL_NUMBER_OF_CCS_POINTS = 2; const int CCS_MODEL_MAXIMAL_NUMBER_OF_CCS_POINTS = 30; const double CCS_MODEL_DEFAULT_SLOPE_LEFT = -0.05; const double CCS_MODEL_DEFAULT_SLOPE_RIGHT = 0.05; const double CCS_MODEL_DEFAULT_BREAKPOINT_SCALE_FACTOR = 1.0; const double CCS_MODEL_MINIMAL_BREAKPOINT_SCALE_FACTOR = 0.0; const int CCS_MODEL_DEFAULT_ABSCISSA = 0; const double CCS_MODEL_DEFAULT_SLOPE_MULT = 1; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER = 1.0; const double CCS_MODEL_DEFAULT_CCS_BASE_SMILE_WEIGHT = 1.0; const double CCS_MODEL_DEFAULT_CCS_MULTIPLIER_SMILE_WEIGHT = 0.0; const double CCS_MODEL_DEFAULT_MULTIPLIER_RATIO = 0.0; const double SVI_MODEL_DEFAULT_A = 0.04; const double SVI_MODEL_DEFAULT_B = 0.4; const double SVI_MODEL_DEFAULT_RHO = -0.4; const double SVI_MODEL_DEFAULT_M = 0.05; const double SVI_MODEL_DEFAULT_SIGMA = 0.1; \/* * Volatility managers need Forward price to fit volatility model parameters * so when<fim-suffix><fim-middle>there is empty volatility model initially, Pricing cannot calculate"}
{"content":"<fim-prefix>#pragma once\n\n#include <third_party\/include\/rapidjson\/document.h>\n#include \"TbWebsocketClient.h\"\n#include \"DeribitMethods.h\"\n#include <strategy\/type\/DateTime.h>\n#include <strategy\/type\/Integer.h>\n#include <strategy\/type\/String.h>\n#include <shared\/Hash.h>\n#include <unordered_map>\n#include <strategy\/Timer.h>\n\nenum class DeribitHost\n{\n    DERIBIT_TEST,\n    DERIBIT_PROD,\n    NONE\n};\n\nstatic std::string Resolve(DeribitHost e)\n{\n    switch (e)\n    {\n    case DeribitHost::DERIBIT_TEST:\n        return \"test.deribit.com\";\n    case DeribitHost::DERIBIT_PROD:\n        return \"www.deribit.com\";\n    default:\n        return {};\n    }\n}\n\nnamespace deribit {\nclass JsonCall;\nclass JsonReply;\n} \/\/ namespace deribit\n\nstruct SingleTransaction\n{\n    tbricks::Identifier id;\n    DeribitMethod method = DeribitMethod::NONE;\n    std::unique_ptr<deribit::JsonCall> call;\n    std::unique_ptr<deribit::JsonReply> reply;\n\n    std::vector<std::string> reqChannels;\n\n    friend std::ostream & operator<<(std::ostream & strm, const SingleTransaction & t);\n};\n\nclass DeribitClient : public IWebsocketHandler, public tbricks::ITimerEventHandler\n{\npublic:\n    class IHandler\n    {\n    public:\n        virtual ~IHandler() = default;\n\n        virtual void HandleDeribitConnected() = 0;\n        virtual void HandleDeribitDisconnected() = 0;\n\n        virtual void HandleTickerUpdate(const tbricks::String & ticker, const std::string_view & json) = 0;\n        virtual void HandleInstrumentDownload(const rapidjson::Value & instruments) = 0;\n    };\n\npublic:\n    DeribitClient(IHandler & handler, const tbricks::String & endpoint, DeribitHost type = DeribitHost::NONE);\n    ~DeribitClient();\n\n    void Connect(const tbricks::String & userId, const tbricks::String & secret);\n    void Disconnect();\n\n    void SetHeartbeat(int seconds);\n\n    void SubscribeToTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void UnsubscribeFromTicker(const std::vector<tbricks::String> & tickers, bool isPublic = true, bool throttled = true);\n    void DownloadInstruments(const tbricks::Identifier & id, DeribitCurrency currency, DeribitKind kind = DeribitKind::ALL, bool expired = false);\n\nprotected:\n    void HandleWebsocketConnected() final;\n    void HandleWebsocketDisconnected(const tbricks::String & reason) final;\n    void HandleError(const tbricks::String & error) final;\n    void HandleMessage(std::string_view message) final;\n\n<fim-suffix><fim-middle>    void HandleTimerEvent(tbricks::Timer & timer) final;"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\" #include \"tbricks_definitions.h\" using namespace tbricks; InstrumentEnricherPlugin::InstrumentEnricherPlugin( const InitializationReason & reason, const StrategyParameters & parameters) : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup()) , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate()) , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription()) , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument()) , m_instrumentManager(*this) { TBSTATUS(\"Constructor: \" << reason); TBDEBUG(\"Parameters: \" << parameters); \/\/ Accept all parameter suggestions GetParameters().Merge(parameters); if (GetTransactionOperation().IsRun() && reason.IsRecovered()) { HandleRunRequest(); } } void InstrumentEnricherPlugin::HandleRunRequest() { TBDEBUG(__func__); if (GetState().IsRunning()) { TBDEBUG(\"Already running\"); return; } if (CheckRunningRequirement()) { m_plugInStatusDescription.Clear(); m_instrumentManager.Start(); SetState(StrategyState::RUNNING); } } void InstrumentEnricherPlugin::HandlePauseRequest() { TBDEBUG(__func__); SetState(StrategyState::PAUSED); } void InstrumentEnricherPlugin::HandleDeleteRequest() { TBDEBUG(__func__); SetState(StrategyState::DELETED); } void InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier) { TBSTATUS(__func__ << \" : \" << modifier); \/\/ Accept all modified parameters and attributes GetParameters().Merge(modifier.GetParameters()); MergeAttributes(modifier.GetAttributes()); } void InstrumentEnricherPlugin::HandleValidateRequest(ValidationContext &context) { TBDEBUG(__func__ << \" :<fim-suffix>auto direction = GetState().IsRunning() ? ParameterDefinition::OUTPUT : ParameterDefinition::INPUT_OUTPUT; context.GetItem(m_instrumentGroup).SetDirection(direction); context.GetItem(m_underlyingInstrument).SetDirection(direction); context.GetItem(m_maturityDate).SetDirection(direction); context.SendReply(); }<fim-middle>\" << context);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> class DeribitModel { public: DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler); ~DeribitModel() noexcept = default; void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update); const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); } bool IsSnapshotDone() const<fim-suffix>void Reset(); void Fail(); protected: void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats); void SendSnapshotDoneIfNeeded(); private: tbricks::DistributedValues::Stream m_stream; tbricks::MarketDataItem m_mdItem;<fim-middle>{ return m_snapshotDone; }"}
{"content":"<fim-prefix>#pragma once #include <strategy\/type\/Binary.h> #include <cstring> class MemBuf : public std::basic_streambuf<char> { public: MemBuf(const char * p, size_t l) { setg((char *) p, (char *) p, (char *) p + l); } }; class MemStream : public std::istream { public: MemStream(const char * p, size_t l) : std::istream(&_buffer) , _buffer(p, l) { rdbuf(&_buffer); } MemStream(const tbricks::Binary & data) : MemStream(static_cast<const char *>(data.GetData()), data.GetSize()) { } private: MemBuf _buffer; }; class Binary_istream { public: Binary_istream() : m_index(0) { }<fim-suffix><fim-middle>Binary_istream(tbricks::Binary && src) : m_data(std::move(src))"}
{"content":"<fim-prefix>#ifndef TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H #define TBRICKS_APPS_PRICING_CUSTOM_DEFINITIONS_H \/** * This file is intended to introduce definitions of the customized metadata * items like instrument parameters or calculated values that are not supported * in the original version of the Pricing app. * * The following inclusion statement assumes tbricks_definitions.h was generated * with the commands: * *<fim-suffix>* $ cd $TB_APPS\/production\/calculation\/custom_pricing * $ tbplugin<fim-middle>$ mkdir -p $TB_APPS\/production\/calculation\/custom_pricing"}
{"content":"<fim-prefix>#include <shared\/ValueWithDefault.hpp> #include <shared\/SuppressSfApiClangWarnings.h> SUPPRESS_SF_API_CLANG_WARNINGS #include <strategy\/type\/Price.h> #include <strategy\/type\/Integer.h> #include <strategy\/type\/Boolean.h> #include <strategy\/calculated_property\/CalculatedPropertyFilter.h> #include <strategy\/TreeNodeParameters.h> #include <strategy\/parameter\/StrategyParameters.h> #include <strategy\/parameter\/StrategyInstanceParameters.h> CLANG_RESTORE_WARNINGS #include <set> using namespace tbricks; enum class PreferencesStorageKind { Common = 0, Wing, CCS, SVI }; std::ostream & operator<<(std::ostream & strm, const PreferencesStorageKind kind); \/** * Struct representing the various settings common to all VMs; it is subclassed by structs * containing additional parameters relevant for particular VMs *\/ class PreferencesStorage: public Printable { public: PreferencesStorage(); protected: PreferencesStorage(const PreferencesStorage & storage) = default; PreferencesStorage & operator=(const PreferencesStorage & storage) = default; public: virtual ~PreferencesStorage(); virtual PreferencesStorageKind GetKind() const = 0; virtual void Clear(); virtual void Copy(const PreferencesStorage & preferencesStorage); virtual bool FillFromTreeNodeParameters(const TreeNodeParameters & parameters); virtual bool FillFromStrategyParameters(const StrategyParameters & parameters); virtual bool FillFromStrategyInstanceParameters(const StrategyInstanceParameters & parameters); virtual bool GetParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetParameters(TreeNodeParameters & parameters) const; virtual void GetParameters(StrategyParameters & parameters) const; virtual void GetParameters(StrategyInstanceParameters & parameters) const; virtual bool GetNonDefaultParameter(const TreeNodeParameterDefinition & def, AnyType & value) const; virtual bool GetNonDefaultParameter(const ParameterDefinition & def, AnyType & value) const; virtual void GetNonDefaultParameters(TreeNodeParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyParameters & parameters) const; virtual void GetNonDefaultParameters(StrategyInstanceParameters & parameters) const; \/\/ Update local values with non-empty values from the passed in preferences storage; \/\/ return true if something got changed as a result, false otherwise virtual bool Merge(const PreferencesStorage & preferencesStorage); virtual std::ostream & Print(std::ostream & strm) const override; \/\/ List<fim-suffix>\/\/ In case it is necessary to include all the exotic instruments, \/\/ we can't persist empty filter since it would be aggregated. \/\/ Hence, this dummy non-empty filter needs to be used for clear operations. static const CalculatedPropertyFilter dummyFilter; \/\/ Autofit settings ValueWithDefault<Boolean> autoFit; ValueWithDefault<Boolean> autoApplyAutoFit; ValueWithDefault<Boolean> globalAvoidExtraFits; ValueWithDefault<Boolean> globalUnderlyingTradingStatusTracking; ValueWithDefault<Boolean> optionTradingStatusTracking;<fim-middle>of preferences that shouldn't be copied to other scope levels     virtual const std::set<TreeNodeParameterDefinition> & GetLevelAnchoredParameters() const { return m_scopeLevelAnchoredPreferences; }"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include <map> class PositionRetriever : public tbricks::PositionStream::IHandler { public: class IHandler; PositionRetriever(IHandler& callback); void RetreivePositions(const tbricks::PortfolioIdentifier& portfolioId); void Stop(); \/\/ Common Stream methods void HandleStreamOpen(const tbricks::StreamIdentifier &stream) final; void<fim-suffix><fim-middle>HandleStreamStale(const tbricks::StreamIdentifier &stream) final;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"InstrumentManager.h\" class InstrumentEnricherPlugin : public tbricks::Strategy , public InstrumentManager::IHandler { public: InstrumentEnricherPlugin(const tbricks::InitializationReason & reason, const tbricks::StrategyParameters & parameters); \/\/ Strategy methods void HandleDeleteRequest() final; void HandleRunRequest() final; void HandlePauseRequest() final; void HandleModifyRequest(const tbricks::StrategyModifier &modifier) final; void HandleValidateRequest(tbricks::ValidationContext &context) final; \/\/ InstrumentManager::IHandler void HandleImportComplete(const tbricks::String& status) final; void HandleInstrumentManagerFailed(const tbricks::String&<fim-suffix><fim-middle>reason) final; const tbricks::InstrumentGroup& GetInstrumentGroup() final { return m_instrumentGroup.GetInstrumentGroup(); }"}
{"content":"<fim-prefix>#include \"InstrumentManager.h\"\n\nusing namespace tbricks;\n\nInstrumentManager::InstrumentManager(IHandler& handler)\n    : m_handler(handler)\n    , m_instrumentStream(*this)\n    , m_iapStream(*this)\n    , m_failed(0)\n{\n    TBDEBUG(__func__ << \" ctor\");\n}\n\nInstrumentManager::~InstrumentManager()\n{\n    TBDEBUG(__func__ << \" dtor\");\n    Stop();\n}\n\nvoid InstrumentManager::Stop()\n{\n    TBDEBUG(__func__);\n    m_instrumentCache.clear();\n    m_underlyingCache.clear();\n    m_instrumentModifyRequests.clear();\n    m_instrumentStream.Close();\n}\n\nvoid InstrumentManager::Start()\n{\n    TBDEBUG(__func__);\n    m_failed = 0;\n\n    Stop();\n    OpenInstrumentStream();\n}\n\nvoid InstrumentManager::OpenInstrumentStream()\n{\n    TBDEBUG(__func__);\n\n    InstrumentStream::Options options;\n    options.SetFilter(InstrumentStream::Filters::ByGroupFilter(m_handler.GetInstrumentGroup()));\n    m_instrumentStream.Open(Stream::SNAPSHOT, options);\n\n    TBDEBUG(\"Opened instrument stream (\" << m_instrumentStream.GetIdentifier() << \") with filter = \" << options.GetFilter());\n}\n\nvoid InstrumentManager::OpenIAPStream()\n{\n    TBDEBUG(__func__);\n    tbricks::InstrumentAggregateParameters::Stream::Options options;\n\n    for (const auto& [instId, _] : m_instrumentCache)\n    {\n        options.AddInstrument(instId);\n    }\n    options.SetParameterDefinitions({tbricks::instrument_parameters::UnderlyingInstrument()});\n    \n    m_iapStream.Close();\n    m_iapStream.Open(tbricks::Stream::SNAPSHOT_AND_LIVE, options);\n    TBDEBUG(\"Opened instrument aggregate parameters stream = \" << m_iapStream.GetIdentifier() << \", options = \" << options);\n}\n\nvoid InstrumentManager::HandleStreamOpen(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamStale(const StreamIdentifier & streamID)\n{\n    TBWARNING(\"Instrument cache stream staled = \" << streamID);\n}\n\nvoid InstrumentManager::HandleStreamFailed(const StreamIdentifier & streamID)\n{\n    m_handler.HandleInstrumentManagerFailed(\"Instrument cache stream failed\");\n}\n\nvoid InstrumentManager::HandleSnapshotEnd(const StreamIdentifier & streamID)\n{\n    TBDEBUG(__func__ << \" : \" << streamID);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        TBDEBUG(\"Instruments snapshot done, opening parameters stream...\");\n        OpenIAPStream();\n    }\n    else if (streamID == m_iapStream.GetIdentifier())\n    {\n        EnrichInstruments();\n    }\n}\n\nvoid InstrumentManager::HandleInstrument(const StreamIdentifier & streamID, const Instrument & instrument)\n{\n    TBDEBUG(__func__ << \" : stream=\" << streamID << \", instrument=\" << instrument.GetIdentifier());\n    TBDUMP(instrument);\n\n    if (streamID == m_instrumentStream.GetIdentifier())\n    {\n        m_instrumentCache[instrument.GetIdentifier()] = instrument;\n    }\n    else\n    {\n        TBWARNING(\"Instrument update received from unknown stream = \" << streamID);\n    }\n}\n\nvoid InstrumentManager::HandleInstrumentAggregateParameters(const StreamIdentifier& streamID,\n                                                            const InstrumentIdentifier& instrumentID,\n                                                            const InstrumentAggregateParameters::Update& update)\n{\n    TBDEBUG(__func__ << \" stream = \" << streamID << \", instrument = \" << instrumentID << \", update = \" << update);\n\n    InstrumentIdentifier underlyingId;\n    if (update.GetParameter(instrument_parameters::UnderlyingInstrument(), underlyingId))\n    {\n        m_underlyingCache[instrumentID] = underlyingId;\n    }\n}\n<fim-suffix><fim-middle>void InstrumentManager::CheckModificationStatus()\n{\n    if (m_instrumentModifyRequests.empty() && m_groupModifyRequests.empty())\n    {"}
{"content":"<fim-prefix>#include \"TbWebsocketClient.h\"\n#include <strategy\/Logger.h>\n#include <array>\n\n#define BUFFER_MIN_SIZE 4\n<fim-suffix><fim-middle>using namespace tbricks;"}
{"content":"<fim-prefix>#include <optional>\n\n#include \"DeribitMdp.h\"\n#include \"tbricks_definitions.h\"\n\n#define MAX_INSTRUMENTS 10\n\nusing namespace tbricks;\n\nDeribitMdp::DeribitMdp()\n{\n    TBDEBUG(\"Constructor: \" << GetVenueIdentifier());\n}\n\nvoid DeribitMdp::HandleSubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model = DeribitModel(item, *this);\n    m_models.emplace(instrument_id, model);\n    m_streams.emplace(model.GetStreamId(), instrument_id);\n}\n\nvoid DeribitMdp::HandleUnsubscribe(MarketDataItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n    const auto & instrument_id = item.GetInstrumentVenueIdentification().GetInstrumentIdentifier();\n    auto model_opt = GetModel(instrument_id);\n    if (model_opt)\n    {\n        auto * model = *model_opt;\n        m_streams.erase(model->GetStreamId());\n        m_models.erase(instrument_id);\n    }\n}\n\nvoid DeribitMdp::HandleOrderBookSubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nvoid DeribitMdp::HandleOrderBookUnsubscribe(OrderBookItem & item)\n{\n    TBDEBUG(__func__ << \", item = \" << item);\n}\n\nbool DeribitMdp::IsMarketDataSupported(const InstrumentVenueIdentification & ivid)\n<fim-suffix><fim-middle>{\n    TBDEBUG(__func__ << \", ivid = \" << ivid);"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include \"tbricks_definitions.h\" class TimerController : public tbricks::ITimerEventHandler { public: class IHandler { public: virtual ~IHandler() = default; virtual void HandleTimerEventHit() = 0; virtual void HandleTimerControllerUpdate(const tbricks::String& update, bool error) = 0; }; explicit TimerController(IHandler& handler); ~TimerController() noexcept override = default;<fim-suffix><fim-middle>"}
{"content":"<fim-prefix>#pragma once\n\n#include <shared\/API.h>\n\nclass DeribitModel\n{\n\npublic:\n    DeribitModel(tbricks::MarketDataItem & item, tbricks::DistributedValues::Stream::IHandler & handler);\n    ~DeribitModel() noexcept = default;\n\n    void HandleDistributedValuesUpdate(const tbricks::DistributedValues::Update & update);\n\n    const tbricks::StreamIdentifier & GetStreamId() const { return m_stream.GetIdentifier(); }\n    \n    bool IsSnapshotDone() const { return m_snapshotDone; }\n\n    void Reset();\n    void Fail();\n    \nprotected:\n    void ApplyDistributedValueUpdate(const tbricks::DistributedValueIdentification & id, const tbricks::DistributedValues::Update::Iterator & it, tbricks::BestPrice & bbo, tbricks::InstrumentStatus & iStatus, tbricks::Statistics & stats);\n\n    void SendSnapshotDoneIfNeeded();\n<fim-suffix><fim-middle>private:\n    tbricks::DistributedValues::Stream m_stream;\n    tbricks::MarketDataItem m_mdItem;\n    tbricks::Identifier m_tickerId;"}
{"content":"<fim-prefix>#include \"PositionReverser.h\" #include \"tbricks_definitions.h\" #include <cmath> using namespace tbricks; void PositionReverser::ReversePosition( const Position& position, const Price& atPrice) { Trade reversedTrade; Volume netPosition = position.GetNetPosition(); if (netPosition > 0) { reversedTrade.SetSide(Side::SELL); } else { reversedTrade.SetSide(Side::BUY); } reversedTrade.SetPrice(atPrice); reversedTrade.SetType(TradeType::POSITION_ADJUSTMENT); reversedTrade.SetCurrency(position.GetCurrency()); reversedTrade.SetClient(position.GetClient()); reversedTrade.SetVolume(std::fabs(position.GetNetPosition())); reversedTrade.SetCounterpart(position.GetCounterpart()); Trade::RequestResult reqCreate = Trade::SendCreateRequest(reversedTrade, *this); m_reversedPositions[reqCreate.GetRequestIdentifier()] = position.GetIdentifier(); TBDEBUG(\"Requested to reverse position: \"<fim-suffix><fim-middle><< position.GetIdentifier()"}
{"content":"<fim-prefix>#pragma once #include<fim-suffix><fim-middle><strategy\/type\/String.h> #include <strategy\/type\/Volume.h> namespace execution {"}
{"content":"<fim-prefix>#include \"PreferencesStorageFactory.h\" #include \"WingPreferencesStorage.h\" #include \"CCSPreferencesStorage.h\" #include \"SVIPreferencesStorage.h\" std::unique_ptr<PreferencesStorage> PreferencesStorageFactory::Create(const VolatilityModel<fim-suffix>case VolatilityModelWing: return std::make_unique<WingPreferencesStorage>(); case VolatilityModelCCS: return<fim-middle>volModelType) { switch(volModelType) {"}
{"content":"<fim-prefix>#include \"shared\/SuppressSfApiClangWarnings.h\" SUPPRESS_SF_API_CLANG_WARNINGS #include \"shared\/app\/app.h\" CLANG_RESTORE_WARNINGS #include <limits> using namespace tbricks; class ValuesRequest; struct ImpliedValue { void Clear(); friend std::ostream & operator << (std::ostream & strm, const ImpliedValue & value) { return value.Print(strm); } std::ostream & Print(std::ostream & strm) const; uint64_t version = std::numeric_limits<uint64_t>::max(); Double implied_volatility; }; struct FairPriceValue { FairPriceValue & operator += (const FairPriceValue & fair_price_value); FairPriceValue & operator += (const Double & value); FairPriceValue operator * (const Double & mult) const; FairPriceValue & operator *= (const Double & mult); void Clear(); bool SetError(const String & error); friend std::ostream & operator << (std::ostream & strm, const FairPriceValue & price) { return price.Print(strm); } std::ostream & Print(std::ostream & strm)<fim-suffix>uint64_t version = std::numeric_limits<uint64_t>::max(); Double fair_price; }; struct Greeks {<fim-middle>const;"}
{"content":"<fim-prefix>#pragma once #include <shared\/API.h> #include <deribit\/DeribitClient.h> class DeribitContributor : public tbricks::Strategy,<fim-suffix><fim-middle>public tbricks::IDistributionApp, public DeribitClient::IHandler"}
{"content":"<fim-prefix>#include \"InstrumentEnricherPlugin.h\"\n#include \"tbricks_definitions.h\"\n\nusing namespace tbricks;\n\nInstrumentEnricherPlugin::InstrumentEnricherPlugin(\n    const InitializationReason & reason,\n    const StrategyParameters & parameters)\n    : m_instrumentGroup(instrument_enricher::strategy_parameters::InstrumentGroup())\n    , m_maturityDate(instrument_enricher::strategy_parameters::MaturityDate())\n    , m_plugInStatusDescription(instrument_enricher::strategy_parameters::PlugInStatusDescription())\n    , m_underlyingInstrument(instrument_enricher::strategy_parameters::UnderlyingInstrument())\n    , m_instrumentManager(*this)\n{\n    TBSTATUS(\"Constructor: \" << reason);\n    TBDEBUG(\"Parameters: \" << parameters);\n\n    GetParameters().Merge(parameters);\n\n    if (GetTransactionOperation().IsRun() && reason.IsRecovered())\n    {\n        HandleRunRequest();\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandleRunRequest()\n{\n    TBDEBUG(__func__);\n\n    if (GetState().IsRunning())\n    {\n        TBDEBUG(\"Already running\");\n        return;\n    }\n\n    if (CheckRunningRequirement())\n    {\n        m_plugInStatusDescription.Clear();\n        m_instrumentManager.Start();\n\n        SetState(StrategyState::RUNNING);\n    }\n}\n\nvoid InstrumentEnricherPlugin::HandlePauseRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::PAUSED);\n}\n\nvoid InstrumentEnricherPlugin::HandleDeleteRequest()\n{\n    TBDEBUG(__func__);\n    SetState(StrategyState::DELETED);\n}\n\nvoid InstrumentEnricherPlugin::HandleModifyRequest(const StrategyModifier & modifier)\n<fim-suffix><fim-middle>{\n    TBSTATUS(__func__ << \" : \" << modifier);"}
{"content":"<fim-prefix>#pragma once #include \"shared\/API.h\" #include \"PositionRetriever.h\" #include \"PositionReverser.h\" class ReversalManager : public PositionRetriever::IHandler, public tbricks::ITimerEventHandler { public: class IHandler; ReversalManager(IHandler& callback); ~ReversalManager() = default; void Start( const tbricks::PortfolioIdentifier& portfolioId, const tbricks::Integer& priceSource, const tbricks::Time& startTime); void Stop(); \/\/ Timer handler. void HandleTimerEvent(tbricks::Timer & timer) override; \/\/ PositionRetriever handler void HandleError(const tbricks::String& error) override;<fim-suffix>private: IHandler& m_callback; tbricks::Timer m_scheduledTimer; tbricks::PortfolioIdentifier m_portfolioId; tbricks::Integer m_priceSource; PositionRetriever<fim-middle>void HandlePositions(const std::map<tbricks::Identifier, tbricks::Position>& positions) override;"}
{"content":"<fim-prefix>#pragma once\n\n#include <strategy\/test\/TestEngine.h>\n\nusing namespace tbricks;\nusing namespace tbricks::test;\n\n#ifndef TIMEOUT\n#define TIMEOUT tbricks::Duration::Seconds(5)\n#endif\n\nvoid Test(TestEngine &te);\ntbricks::String get_current_root();\ntbricks::String get_apps_relative();\n\nint main(int  \/*argc*\/, char * \/*argv*\/[])\n{\n    TestEngine te(\"..\/system.xml\", \"..\/engine.xml\");\n    te.LoadMetadata(\"..\/..\/..\/..\/..\/examples\/strategy\/go_flat\/go_flat.metadata\");\n    te.LoadPlugin((get_current_root() + \"\/..\/..\/..\/..\/..\/examples\/strategy\/go_flat\").GetCString());\n    te.RunTest(Test, TIMEOUT);\n\n    return 0;\n}\n\nnamespace go_flat {\n\ntbricks::VenueIdentifier GetTestVenueId()\n{\n    return {\"b3899c44-d38e-11e7-b350-bac7e485efc7\"};\n}\n\ntbricks::PortfolioIdentifier GetPortfolioId()\n{\n    return {\"2eb2249c-bc89-11ee-a950-d946a31b499d\"};\n}\n\n} \/\/ namespace go_flat\n\n#include <filesystem>\n\nnamespace fs = std::filesystem;\n\ntbricks::String get_current_root()\n{\n    fs::path current(fs::current_path());\n    fs::path apps;\n    if (std::getenv(\"TB_APPS\") == nullptr)\n    {\n        apps = fs::path(\"\/opt\/tbricks\/apps\");\n    } else {\n        apps = fs::path(std::getenv(\"TB_APPS\"));\n    }\n    current = fs::relative(current, apps);\n    return tbricks::String(current.c_str());\n}\n\ntbricks::String get_apps_relative()\n{\n    fs::path apps;\n    if (std::getenv(\"TB_APPS\") == nullptr)\n    {\n        apps = fs::path(\"\/opt\/tbricks\/apps\");\n<fim-suffix><fim-middle>    } else {\n        apps = fs::path(std::getenv(\"TB_APPS\"));\n    }\n    return tbricks::String(fs::relative(apps).c_str());"}
